{
    "from": "arxiv",
    "scholar_id": null,
    "detail_id": "arXiv:2406.13185",
    "title": "LIVE: Learnable In-Context Vector for Visual Question Answering",
    "abstract": "As language models continue to scale, Large Language Models (LLMs) have exhibited emerging capabilities in In-Context Learning (ICL), enabling them to solve language tasks by prefixing a few in-context demonstrations (ICDs) as context. Inspired by these advancements, researchers have extended these techniques to develop Large Multimodal Models (LMMs) with ICL capabilities. However, applying ICL usually faces two major challenges: 1) using more ICDs will largely increase the inference time and 2) the performance is sensitive to the selection of ICDs. These challenges are further exacerbated in LMMs due to the integration of multiple data types and the combinational complexity of multimodal ICDs. Recently, to address these challenges, some NLP studies introduce non-learnable In-Context Vectors (ICVs) which extract useful task information from ICDs into a single vector and then insert it into the LLM to help solve the corresponding task. However, although useful in simple NLP tasks, these non-learnable methods fail to handle complex multimodal tasks like Visual Question Answering (VQA). In this study, we propose Learnable In-Context Vector (LIVE) to distill essential task information from demonstrations, improving ICL performance in LMMs. Experiments show that LIVE can significantly reduce computational costs while enhancing accuracy in VQA tasks compared to traditional ICL and other non-learnable ICV methods. The code is available at https: //github.com/ForJadeForest/LIVE-Learnable-In-Context-Vector.",
    "bib_name": "peng2024livelearnableincontextvector",
    "md_text": "# LIVE: Learnable In-Context Vector for Visual Question Answering\nYingzhe Peng1,2, Chenduo Hao1,2, Xinting Hu3, Jiawei Peng1, 2, Xin Geng1,2, Xu Yang1,2\u2217  \n# Yingzhe Peng1,2, Chenduo Hao1,2, Xinting Hu3, Jiawei Peng1, 2, Xin Geng1,2, Xu Yang1,2\u2217  \n Southeast University 2 Key Laboratory of New Generation Artificial Intelligence Technology and Its Interdisciplinary Applications (Southeast University), Ministry of Education, China {yingzhe.peng, 213201447, pengjiawei, xgeng, xuyang_palm}@seu.edu.cn 3 Nanyang Technological University xinting001@e.ntu.edu.sg\n# Abstract\nAs language models continue to scale, Large Language Models (LLMs) have exhibited emerging capabilities in In-Context Learning (ICL), enabling them to solve language tasks by prefixing a few in-context demonstrations (ICDs) as context. Inspired by these advancements, researchers have extended these techniques to develop Large Multimodal Models (LMMs) with ICL capabilities. However, applying ICL usually faces two major challenges: 1) using more ICDs will largely increase the inference time and 2) the performance is sensitive to the selection of ICDs. These challenges are further exacerbated in LMMs due to the integration of multiple data types and the combinational complexity of multimodal ICDs. Recently, to address these challenges, some NLP studies introduce non-learnable In-Context Vectors (ICVs) which extract useful task information from ICDs into a single vector and then insert it into the LLM to help solve the corresponding task. However, although useful in simple NLP tasks, these non-learnable methods fail to handle complex multimodal tasks like Visual Question Answering (VQA). In this study, we propose Learnable In-Context Vector (LIVE) to distill essential task information from demonstrations, improving ICL performance in LMMs. Experiments show that LIVE can significantly reduce computational costs while enhancing accuracy in VQA tasks compared to traditional ICL and other non-learnable ICV methods. The code is available at https: //github.com/ForJadeForest/LIVE-Learnable-In-Context-Vector.\n# 1 Introduction\nAs language models continue to scale up, Large Language Models (LLMs) [1\u20133] have demonstrated emerging capabilities in In-Context Learning (ICL) [4]: these models can solve language tasks when provided with a few similar examples, termed in-context demonstrations (ICDs), as context. Unlike traditional task-specific fine-tuning, ICL, a efficient method to adapt LLM to downstream task [5, 6], achieves comparable performance without necessitating updates to millions or trillions of model parameters [7]. By prefixing just a handful of data samples to the query input, ICL configures a model\u2019s behavior to produce the corresponding output, thus facilitating rapid adaptation across a wide range of downstream tasks. Inspired by these advancements in the language domain, researchers have extended these techniques to develop Large Multimodal Models (LMMs) with ICL capabilities [8\u201310].\n1Corresponding author.\n38th Conference on Neural Information Processing Systems (NeurIPS 2024)\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/a2b9/a2b945da-8387-4a5e-a9d2-b0e6d8c5ca35.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\"></div>\n<div style=\"text-align: center;\">Figure 1: (a) Conventional ICL is more sensitive to the ICD selection and requires more inference time. (b) LIVE is more robust and reduces inference time by inputting a shift vector.</div>\nEmploying ICL in LLMs meets two challenges: Firstly, although increasing the number of ICDs typically enhances performance [7], this practice conflicts with computational efficiency constraints. As ICDs are prefixed to the query, the increase in input tokens severely impacts the Transformer\u2019s inference speed, causing a marked slowdown in computational performance. Secondly, the effectiveness of ICL is vulnerable to the selection of demonstrations [4, 11\u201313], particularly when only a limited number are used. It makes the process of choosing demonstrations critical for optimal performance. However, developing selection strategies and measuring the effectiveness of ICDs remain open questions [14\u201317]. For LMMs, the challenges above are further exacerbated: 1) The computational complexity is significantly increased due to the integration of multiple data types as ICDs (as shown in Figure 1(a)). 2) The task of selecting effective multi-modal ICDs becomes more complex and nuanced, as each modality contributes uniquely to understanding the context [18, 19], further complicating the assessment of their combined effect in demonstration selection. To alleviate these two challenges, recent research on LLMs has introduced In-Context Vector (ICV) to extract the most useful task information from ICDs, and then use it to directly influence the processing in LLMs [20\u201322]. For example, [20] proposes that by using multiple demonstrations and a dummy query as inputs, the representation of the last token from a middle layer of the model can be extracted as the vector. This vector is then used to replace the representation of the corresponding token in the same layer during inference, which can achieve performance comparable to ICL. Such in-context vector alleviates the requirement of multiple ICDs during inference, as well as effectively bypasses the complexity of the individual selection of demonstrations by representing the most effective components across many demonstrations. However, these studies apply non-learnable strategies to extract ICVs, although useful in some simple NLP tasks, lose the efficacy in complex multi-modal tasks like Visual Question Answering (VQA). Our preliminary experiments have demonstrated that directly applying these non-learnable ICVs yields unsatisfactory results. The principal reason is the intrinsic complexity of VQA compared to the language tasks addressed by these non-learnable ICVs. For example, the previous methods focus on simple NLP task, such as Antonym [23] and Country-Capital [21], whose distribution patterns can be easily identified by LLMs. In contrast, as a unified vision-language task, VQA encompasses a diverse array of question types, where each one corresponds to a different vision-understanding task. For instance, questions like \u201cWhat is this?\u201d or \u201cHow many are there?\u201d require classification and counting abilities, respectively. These varied requirements imply that the task information, which non-learnable methods attempt to abstract, cannot be effectively captured by a single ICV. In this study, to make ICVs abstract more useful VQA task information, we try to distill the task information implied in demonstrations into a single Learnable In-Context Vector (LIVE). Our method is motivated by the observation [20] that ICL can be treated as a process of \u201cshifting\" the direction of the latent states of query towards the target, i.e., adding this latent state with a shift vector. Then we hope to learn suitable ICVs to replace the ICDs during inference to shift the direction. To achieve this, we train LIVE by minimizing the output distributions of a LMM got by only using LIVE and by inputting a few demonstrations. During training, we use different 32-shot randomly sampled demonstrations for different queries to distill task knowledge. Then LIVE is encouraged to capture the most essential task information from these different combinations by removing the individual characteristics of demonstrations. Moreover, [24] finds that during ICL, different layers of LLM\nhave diverse roles in addressing demonstrations. Then in our method, each layer is assigned with a unique ICV to capture more fine-grained task information. Our LIVE inherits the efficiency of previous non-learnable ICVs, i.e., during inference, under the same performance conditions, LIVE only needs 1/24.97 FLOPs number of 32-shot ICL. Additionally, in VQAV2/OKVQA, LIVE improves accuracy by 2.36/1.6 compared to 32-shot ICL. We also compare LIVE to LoRA [25] that when comparable trainable parameters are used, LIVE requires much fewer training samples than LoRA (500 vs. 8000) to achieve satisfactory performance. Besides, we design lots of analytical experiments to validate whether LIVE can better shift the hidden states of queries to the target direction and analyze why previous non-learnable methods fail to solve VQA.\n# 2 Related Work\nIn-Context Vector: Recently, more and more researchers in NLP have begun to focus on using an In-Context Vector (ICV) to modify the activation values during the forward propagation of LLM to simulate the effect of ICDs in ICL. [20] propose the \u201cTask Vector\u201d, which extracts the representation of the middle layer from the LLM during ICL inference as the ICV, and replaces the representation of the same layer during zero-shot inference. Meanwhile, [21] introduced the \u201cFunction Vector\u201d, which uses attention weight analysis to take the mean of the activation values of the attention heads that most significantly affect the final result in ICL inference as the final ICV. This vector is then directly added to the representation of the middle layer during zero-shot inference to form a new representation. On the other hand, [22] propose \u201cPCA In-Context Vector\u201d. They believe that the ICV should be closer to the LLM\u2019s representation of the task output and farther from the task input representation. Thus, they extract the input and output representations of several demonstrations and using PCA to find the overall principal direction as the ICV. These efforts mainly focus on using non-learnable methods to find the specific ICV for NLP tasks, achieving effects similar to ICL in various tasks. However, these methods only are tested on some simple tasks in NLP. When LMMs face with more complex tasks, the performance of these methods remains uncertain. ICL in LLM: Prompt engineering allows LLMs to tackle specific tasks without requiring finetuning [26\u201333]. A specific form of this approach, ICL, further improves these capabilities by creating prompts that include several demonstrations. ICL has already demonstrated superior performance and good generalization on many tasks [34, 7, 35, 36], and can be easily adapted to downstream tasks. However, the use of ICL faces several issues: first, ICL is very sensitive to the selection and arrangement order of demonstrations [4, 11\u201313, 37\u201339]; poor demonstrations can severely impact ICL performance. Second, too many demonstrations can significantly slow down the inference speed of LLMs [40]. While ICVs can effectively address these two issues, as it can use only queries as input to the model while preserving ICL performance, without the need for demonstrations as input. ICL in LMM: As the performance of LLMs continues to improve, an increasing number of researchers begin to adapt LLMs to the multimodal domain [41\u201346]. Relying on the powerful inference capabilities of LLMs, some LMMs have started to exhibit ICL capabilities, such as Flamingo [8] and IDEFICS [9]. Moreover, these models have significantly enhanced their ICL capabilities by concatenating multiple samples as contextual information during the training process. Currently, researchers mainly focus on how to configure demonstrations to address the sensitivity of ICL performance in LMMs. [18, 19] have respectively adopted heuristic retrieval methods for selecting demonstrations in Image Captioning and VQA. However, no researchers have yet extracted ICV from LMMs and evalutaed it. Therefore, the effectiveness of ICV in LMMs still needs further exploration. Considering that the IDEFICS model shares the same model structure as Flamingo and possesses stronger ICL capabilities, we primarily focus on valid our method on the IDEFICS model.\n# 3 LIVE: Learnable In-Context Vector\nHere we show how to derive the formulation of the shift vector from Self-Attention (SA) mechanism and then introduce how to design LIVE based on this formulation. Generally, to implement In-Context Learning (ICL) using a language or multimodal model (LLM/LMM) M, the input has the following form: X = {XD, \u02c6x}, where XD = {x1, ..., xk} represents the concatenation of k In-Context Demonstrations (ICDs), and \u02c6x denotes the query input, as shown in Figure 2. Given X as Key and\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/4794/47947564-6b71-4186-8a0a-7e200422e4f8.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\"></div>\nFigure 2: The LIVE training pipeline: (a) The distribution P(\u02c6x|V , \u03b1; M) of LMMs output when using LIVE. (b) Adding LIVE into the representations of the query to simulate the shift effect brought by demonstrations. (c) The distribution P(\u02c6x|XD; M) of LMMs output when using demonstrations.\n\ufffd \ufffd \ufffd \ufffd \ufffd \ufffd \ufffd \ufffd where vector \ufffd \u02c6xiX\u22a4 D \u02c6xi \u02c6x\u22a4\ufffd \u2208R1\u00d7l and l denotes the sequence length of the entire input [XD, Expanding the softmax function, we obtain: \uf8ee\nwhere lc and lq represent the lengths of the XD and \u02c6x, respectively. Z1 and Z2 are the sum of exponential scores between the query token \u02c6xi with each token in XD and \u02c6x: Z1 = \ufffd lc exp(\u02c6xiX\u22a4 D) and Z2 = \ufffd lq exp(\u02c6xi \u02c6x\u22a4). This leads to the following formulation of SA:\n= \u00b5 SA(\u02c6xi, XD, XD) + (1 \u2212\u00b5) SA(\u02c6xi, \u02c6x, \u02c6x), where \u00b5 = Z1/(Z1 + Z2). Let h(z) = SA(\u02c6xi, z, z). The output of SA(\u02c6xi) can then be expressed as SA(\u02c6xi, X, X) = \u00b5h(XD) + (1 \u2212\u00b5)h(\u02c6x) (4)\n \u2212 where \u00b5 = Z1/(Z1 + Z2). Let h(z) = SA(\u02c6xi, z, z). The output of SA(\u02c6xi) can then be expressed SA(\u02c6xi, X, X) = \u00b5h(XD) + (1 \u2212\u00b5)h(\u02c6x)\n \u2212 As noted in Equation 4, we observe that h(\u02c6x) is the representation obtained with self-attention over the query \u02c6x without appending any ICD; h(XD) functions similarly to a \u201cshift\" vector, altering the attention representation h(\u02c6x) by incorporating contextual information from the ICDs XD. The coefficient \u00b5 quantifies the degree of influence XD has over the original query representation. For a visual demonstration of how ICDs shift the representation space, see Figure 2 (b). Consequently, once learning a general shift direction to replace the effect of h(XD), we can employ this shift direction to simulate the ICL process of LMMs without actual demonstrations. We propose a novel method that involves a Learnable In-Context Vector (LIVE) to simulate the ICL process without actual demonstrations. This approach aims to abstract general task information from demonstrations, enabling it to shift the model\u2019s representation toward the direction influenced by the ICDs. Figure 2 shows the training pipeline of LIVE. The LIVE training dataset, denoted as D = {d1, . . . , dN}, is a subset of the VQA dataset training split, created by randomly selecting N question-answer pairs from it. We use each training sample di to simulate the query sample \u02c6x in ICL, and randomly select k demonstrations from D \\ {di} for it. Additionally, [24] shows that during\n<div style=\"text-align: center;\"></div>\n(1)\n(2)  of\n(3)\n(4)\nICL, each layer of an LLM performs a distinct role. Motivated by this, we assume that for LMM, each layer also requires a specific shift direction. We assign a learnable vector vl and a weight factor \u03b1l for each layer l to learn the unique shift effect. Our final LIVE comprises of the vector set V and the corresponding weight factor set \u03b1 as:\n {}  \u2208 where L is the number of layers. To train V and \u03b1, we align the distribution of the model\u2019s outputs for the query when shifted by demonstrations, P(\u02c6x|XD; M), with that shifted by our LIVE, P(\u02c6x|V , \u03b1; M). This alignment is achieved by minimizing the Kullback-Leibler (KL) divergence: Ld = KL(P(\u02c6x|XD; M) || P(\u02c6x|V , \u03b1; M)) (6) To obtain the distribution P(\u02c6x|XD; M), for each query \u02c6x, we randomly select k demonstrations to form XD. These are concatenated with the query to form the inputs for the model. The model\u2019s output for the query is then considered as the shifted distribution P(\u02c6x|XD; M). To obtain the output of \u02c6x by using LIVE, we follow [20, 22], we use the vector vl to shift the each layer\u2019s output representation Ml(\u02c6xi) and get: Ml(\u02c6xi)\u2032 = Ml(\u02c6xi) + \u03b1lvl, which is shown in Figure 2(a). After applying LIVE to shift the representations at each layer, we obtain the output distribution P(\u02c6x|V , \u03b1; M). Notably, during training, XD for each query \u02c6x includes randomly sampled 32-shot demonstrations. This strategy encourages our LIVE to extract the most useful common information from various demonstration combinations and prevents it from being influenced by the individual characteristics of certain demonstrations. In addition, to facilitate the LIVE in acquiring more task-specific information, we also optimize the P(\u02c6x|V , \u03b1; M) with the ground truth by Lgt . Thus, the overall loss L is defined as:\n {}  \u2208 where L is the number of layers. To train V and \u03b1, we align the distribution of the model\u2019s utputs for the query when shifted by demonstrations, P(\u02c6x|XD; M), with that shifted by our LIVE, P(\u02c6x|V , \u03b1; M). This alignment is achieved by minimizing the Kullback-Leibler (KL) divergence:\n\ufffd where \u03bb is the hyper-parameter to control the importance of ground truth loss.\n# 4 Experiments\n# 4.1 Setting and implementation details\nModel and Dataset: We evaluate our approach using the IDEFICS-9B model [9] across two datasets: VQAv2 [47] and OKVQA [48]. VQAv2 emphasizes open-ended VQA tasks, encompassing 4, 437, 570 question-answer pairs in its training split, supplemented by an additional 2, 143, 540 pairs in the validation split. OKVQA is a large-scale dataset designed for models that require external knowledge to answer questions. It consists of 14, 055 question-answer pairs, with 9, 009 allocated for training and 5, 046 for validation. For both VQAv2 and OKVQA datasets, We train our LIVE on 8, 000 pairs from each training set. Due to computational resource limitations, we randomly sample 10, 000 question-answer pairs from the VQAv2 validation split for evaluation [18]. For OKVQA, we utilize the entire validation split. LIVE Setting: During training, we assign 32-shot demonstrations for each query, enabling LIVE to acquire better directions of shifting vectors for VQA tasks. The vi is initialized using a normal distribution with a mean of 0 and a standard deviation of 0.01, and all \u03b1i are initialized to 0.1. More detailed training parameters can be found in Appendix.\n# 4.2 Results\n# 4.2.1 Compared Methods\nWe primarily compare the following methods: Zero-Shot: The model uses only the query as input. k-Shot ICL:The model uses k demonstrations, randomly selected from the VQA dataset training split, along with the query as input.\n(5)\n(7)\n<div style=\"text-align: center;\">Table 1: Accuracy (%) with Different ICVs Methods and Finetuning Methods, where numbers in arentheses indicate multiples of LIVE trainable parameters.</div>\nZero-Shot\n32-shot ICL\nTV\nFV\nPCA-ICV\nLoRA\nLIVE (Ours)\nVQAv2\n29.25\n56.18\n43.68\n30.21\n34.75\n49.02\n58.54\nOKVQA\n30.54\n48.48\n32.68\n31.02\n30.59\n34.21\n50.08\nTotal Trainable Parameters\n-\n-\n-\n-\n-\n1, 155, 136(\u00d78.8)\n131, 104(\u00d71.0)\nNon-Learnable ICV Methods: We extend three established non-learnable ICV methods from language models to our multimodal settings: (1) Task Vector (TV) [20] uses k demonstrations and a dummy query to extract the representation of the last token from a middle layer of the model as the ICV. During inference, this vector replaces the representation of the last token in the same layer. We conduct evaluations on TV by implementing it across various layers and select the layer where it achieves the highest performance improvement. (2) Function Vector (FV) [21] employs a small subset of the validation data to derive the mean output from critical attention heads, forming the ICV. During inference, this vector is added to the representations of the last token within a specific layer. We conduct evaluations on FV by implementing it across various layers and select the layer where it achieves the highest performance improvement. (3) PCA In-Context Vector (PCA-ICV) [22] computes the ICV by applying PCA to the difference between the question and question-answer representations from k demonstrations. During inference, these vectors are added to the representations of all tokens at each layer, LoRA [25]: This method finetunes the LMMs with the same number of samples of training LIVE. We add the LoRA module in the token classification head of the last layer. In this way, the number of trainable parameters is comparable to that of LIVE.\n# 4.2.2 Performance and Inference Efficiency on VQA.\nWe present performance comparisons with various methods in Table 1. Certain existing methods show only marginal improvements over Zero-Shot baselines, e.g., FV improves by 0.96/0.48 on VQAv2/OKVQA and PCA-ICV improves by 0.04 on OKVQA. Besides, we observe that all the previous non-learnable ICV methods do not reach the performance of the standard 32-shot ICL, e.g., the best non-learnable method, TV, is still 12.5/15.8 lower than 32-shot ICL on VQAv2/OKVQA. In contrast, our LIVE achieves an accuracy improvement of 2.36 on VQAv2 and 1.6 on OKVQA over 32-shot ICL. These results highlight the inefficacy of non-learnable methods in capturing essential task-specific information for VQA, whereas LIVE, by leveraging diverse 32-shot ICL demonstrations for each query during training, manages to abstract useful task information effectively. We further show that our LIVE outperforms LoRA with less trainable parameters, suggesting LIVE can abstract task information more efficiently. Figure 3 displays the efficiency of LIVE during inference compared to other methods. We average the FLOPs and actual inference time consumption per forward pass over 1000 randomly sampled queries.1 We observe that LIVE only needs 1/24.97 FLOPs and 1/8.25 inference time of 32-shot ICL per forward pass. Additionally, LIVE maintains almost the same inference speed as Zero-Shot. These comparisons validate the efficiency of LIVE during inference.\n# 4.3 Ablation Studies\nWe use ablation studies to explore the effects of diverse settings, including different training losses, the shot number of demonstrations k used during training, and the number of training data N. Training Loss: Table 2 compares the results of using different losses: only Lgt in Eq. (7) or Ld in Eq. (7). We find that only using Lgt (same as standard fine-tuning) significantly damages the performance, e.g., Lgt achieves 16.9/6.12 lower accuracy on VQAv2/OKVQA compared to using the combined loss L; yet using only Ld results in a smaller performance drop \u2013 3.78/3.14 lower VQAv2/OKVQA than when using L. This suggests that with a limited number of trainable parameters, LIVE trained with Ld is more robust and capable of capturing essential\n1For detailed hardware information, refer to Appendix.\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/6ee6/6ee6f6ac-de20-446d-8d34-a41ce3067f29.png\" style=\"width: 50%;\"></div>\nFigure 3: The total number of FLOPs and real inference time consumption of ICL, Zero-Shot, LIVE for 1000 query samples.\ntask information than Lgt. It underscores that the LIVE cannot solely rely on fine-tuning with LMMs on specific datasets, but should effectively leverage abstracted insights from demonstrations.\nNumber of Demonstrations k: We compare the performance of LIVE trained with k demonstrations per query and the corresponding k-shot ICL in Table 3. The result shows that an increase in the number of demonstrations enhances the performance of ICL and LIVE, indicating that more demonstrations can provide each query with a richer context to help train LIVE. Additionally, LIVE consistently surpasses the performance\nof k-shot ICL across different training sizes, showcasing the robustness of our LIVE in utilizing demonstrations. Notably, when the number of demonstrations is limited, the performance gap between LIVE and ICL becomes more pronounced. This is because ICL is highly sensitive to the choice of demonstrations; with insufficient demonstrations, the model may shift the query representations in an incorrect direction. In contrast, LIVE continuously by learning the main shift direction of the query representations from the demonstrations, reduces the negative impact of poor demonstrations on the query during training and is more robust that can extract essential task information.\nSize of Training Set: Figure 4 illustrates how varying the number of training samples impacts the performance of LIVE and LoRA. On the VQAv2 dataset, both methods show improved performance with increasing data sizes. Notably, LIVE performs exceptionally well across both low and high training sizes. It achieves performance close to that of 1-shot ICL with just 700 training samples and surpasses 32-shot ICL with 4,000 training samples. In contrast, LoRA does not exceed the performance of 1-shot ICL, even when expanded to 8,000 samples. For OKVQA,\n<div style=\"text-align: center;\">Table 3: Accuracy (%) of Different Number of Demonstrations on VQA.</div>\nDemonstrations on VQA.\nTask\nMethod\nNumber of Demonstrations\n1\n4\n8\n16\n32\nVQAv2\nLIVE\n56.84\n57.60\n58.25\n58.27\n58.54\nICL\n51.39\n53.72\n54.24\n55.70\n56.18\nOKVQA\nLIVE\n47.51\n47.68\n49.40\n49.71\n50.08\nICL\n40.75\n46.11\n46.79\n47.70\n48.48\nthe performance of LoRA with small data sizes is even worse than Zero-Shot. This is because OKVQA requires external knowledge to answer questions, while learning external knowledge from a small amount of data can disrupt the inherent knowledge of the pre-trained model, leading to a significant drop in performance. Conversely, LIVE excels by focusing on learning shift direction, thus preserving the model\u2019s inherent reasoning abilities. With just 500 samples, LIVE outperforms 1-shot ICL, and with 4,000 samples, it nearly matches the performance of 32-shot ICL. These observations underscore LIVE\u2019s superior efficiency over LoRA in capturing and utilizing complex reasoning capabilities with much fewer training samples.\n<div style=\"text-align: center;\">Table 2: Accuracy (%) of LIVE with Different Training Loss on VQA.</div>\nDifferent Training Loss on VQA.\nLd\nLgt\nL\nVQAv2\n54.76\n41.64\n58.54\nOKVQA\n46.94\n43.96\n50.08\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/592f/592f61e7-02e1-4cd8-8ece-92883506feaa.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Figure 4: Accuracy (%) of LIVE and LoRA with different size of training set.</div>\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/ed5f/ed5f94bf-c025-45a3-8049-e5e78b9d6fa4.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Figure 5: T-SNE visualization of first answer token representations over 200 queries.</div>\n# 4.4 Analysis\n# 4.4.1 The Shifting Effect in Latent Space\nTo better demonstrate the shifting effect of LIVE on query samples, we randomly select 200 query samples and conduct different methods of inference in LMMs. We extract the representation vector of the first answer token for T-SNE dimensionality reduction, shown in Figure 5. Additionally, to quantitatively evaluate the effect of shift directions of different ICV methods, we calculate the following metrics. Given a query \u02c6x, we use ricl, rzs, r\u2217to denote the representation of the first answer token obtained by 32-shot ICL, Zero-Shot, specific ICV methods, respectively. Then we calculate the standard shift direction as sgt = ricl \u2212rzs and the shift direction of specific ICV as s\u2217= r\u2217\u2212rzs. Finally, we define the shift direction similarity as the cosine similarity between s\u2217and sgt, indicating how closely the shift direction of the ICV method aligns with the standard shift direction. The results are presented in Table 4. From Figure 5, we can find that 32-shot ICL\nFrom Figure 5, we can find that 32-shot ICL exhibits a significant shift compared to ZeroShot, visualizing the shift effects given in Eq. 4. Considering both Table 4 and 1, we find that the shift direction similarity has positive correlation to the accuracy: if a method has large direction similarity, it also has better performance. For example, among non-learnable methods, TV has higher shift direction similarity than other ones,\n<div style=\"text-align: center;\">Table 4: The shift direction similarities of different ICV methods.</div>\nICV methods.\nTV\nFV\nPCA-ICV\nLIVE\nVQAv2\n0.486\n-0.106\n0.027\n0.742\nOKVQA\n0.326\n0.218\n-0.190\n0.829\nthen it has better accuracy in Table 1. Furthermore, for LIVE which has the best accuracy in Table 1, its shift direction similarity is also the highest, which is 0.742/0.829 on VQAv2/OKVQA, validating that LIVE can produce shifts in query samples similar to 32-shot ICL, as visualized in Figure 5.\n<div style=\"text-align: center;\">Table 5: Direct decoding of the different ICV methods.</div>\nMethods\nDecoding Top-10 Tokens of different methods in order of decreasing probability\nTV\n\u2018No\u2019, \u2019Yes\u2019, \u2019no\u2019, \u2019It\u2019, \u2019I\u2019, \u2019No\u2019, \u2019The\u2019, \u2019A\u2019, \u2019yes\u2019, \u2019Not\u2019\nFV\n\u2019.\u2019, \u2019in\u2019, \u2019,\u2019, \u2019(\u2019, \u2019for\u2019, \u2019and\u2019, \u2019...\u2019, \u2019to\u2019, \u2019on\u2019, \u2019I\u2019\nPCA-ICV\n\u2019none\u2019, \u2019there\u2019, \u2019no\u2019, \u2019the\u2019, \u2019not\u2019, \u2019None\u2019, \u2019dep\u2019, \u2019_yes\u2019, \u2019unknown\u2019, \u2019yes\u2019\nLIVE\n\u2019Question\u2019, \u2019_Short\u2019, \u2019?\u2019, \u2019no\u2019, \u2019QUEST\u2019, \u2019questions\u2019, \u2019$?\u2019, \u2019answer\u2019, \u2019Short\u2019, \u2019_questions\u2019\nTable 6: The frequency of yes/no hallucinations and meaningless responses.\nZero-Shot\nTV\nFV\nPCA-ICV\nLIVE\nyes/no Hallucination\n5\n111\n7\n4\n3\nMeaningless Answer in yes/no\n0\n0\n0\n2\n0\nMeaningless Answer in number\n2\n0\n2\n522\n0\nMeaningless Answer in other\n257\n0\n247\n2072\n2\nMethods\nDecoding Top-10 Tokens of different methods in order of decreasing probability\nTV\n\u2018No\u2019, \u2019Yes\u2019, \u2019no\u2019, \u2019It\u2019, \u2019I\u2019, \u2019No\u2019, \u2019The\u2019, \u2019A\u2019, \u2019yes\u2019, \u2019Not\u2019\nFV\n\u2019.\u2019, \u2019in\u2019, \u2019,\u2019, \u2019(\u2019, \u2019for\u2019, \u2019and\u2019, \u2019...\u2019, \u2019to\u2019, \u2019on\u2019, \u2019I\u2019\nPCA-ICV\n\u2019none\u2019, \u2019there\u2019, \u2019no\u2019, \u2019the\u2019, \u2019not\u2019, \u2019None\u2019, \u2019dep\u2019, \u2019_yes\u2019, \u2019unknown\u2019, \u2019yes\u2019\nLIVE\n\u2019Question\u2019, \u2019_Short\u2019, \u2019?\u2019, \u2019no\u2019, \u2019QUEST\u2019, \u2019questions\u2019, \u2019$?\u2019, \u2019answer\u2019, \u2019Short\u2019, \u2019_questions\u2019\nZero-Shot\nTV\nFV\nPCA-ICV\nLIVE\nyes/no Hallucination\n5\n111\n7\n4\n3\nMeaningless Answer in yes/no\n0\n0\n0\n2\n0\nMeaningless Answer in number\n2\n0\n2\n522\n0\nMeaningless Answer in other\n257\n0\n247\n2072\n2\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/cb32/cb3212c2-305e-44d7-8200-92ab44cf8ee0.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Figure 6: Visualizations of the cases where non-learnable methods appear yes/no hallucinations and meaningless responses.</div>\nSuch positive correlation validates the effectiveness of our motivation that a single LIVE can indeed simulate the ICL capability of LMMs by shifting the direction of the query representation.\n# 4.4.2 Why Non-Learnable Methods are Poor on VQA?\nDecoding ICV To Tokens: We follow previous studies [49\u201351] to analyze the parameters of Transformers by directly decoding them into vocabulary tokens. Specifically, given a vector v \u2208R1\u00d7d, it can be projected using the unembedding matrix E \u2208Rd\u00d7N of LMMs to obtain the corresponding token probability distribution p , where N is the vocabulary size:\n\ufffd  \u00b7 We calculate the p of the vectors got from different methods in VQAv2 and select the top-10 tokens with the highest probabilities in p shown in Table 5. We can see that the tokens got from FV are not highly relevant to the VQA task, which proves that FV does not capture the task information of VQAv2. On the other hand, the frequency of \"yes\" and \"no\" tokens is relatively high in the decoding results of PCA-ICV and TV, suggesting that they prefer to capture the simple patterns from demonstrations, e.g.yes/no, but struggle to grasp the overall task information of complex VQA. In contrast, the tokens of LIVE decoding are not biased to specific answers like yes/no, suggesting it abstracts more summary task knowledge of VQA.\n# Hallucinations and Invalid Responses.\nVQA contains various answer types and for convenience, VQAv2 divides them into three categories: \u201cyes/no\u201d, \u201cnumber\u201d, and \u201cother\u201d. After delving deeper into the answer details, interestingly, we find that TV frequently answers \u201cyes or no\u201d to number/other questions as shown in Figure 6 (1)(2)(3). We term this phenomenon the yes/no hallucination and count the frequency of the yes/no hallucination over all test data samples for different methods in Table 6. We can find that TV appears 111 times of yes/no hallucination, being consistent with the observations in Table 5, suggesting TV is biased to yes/no type question. We also observe that non-learnable methods tend to respond meaningless text (e.g.\u201c\\n\u201d) when responding to \u201cnumber/other\u201d questions as shown in Figure 6 (1)(2)(4). Table 6 shows the number of meaningless answers. We find that PCA-ICV and TV have more chance to return\n(8)\nmeaningless answers for \u201cother\u201d questions, suggesting these methods do not capture the overall task information of VQA and are not able to answer some less frequently appeared questions. However, for LIVE, it has less yes/no hallucination and meaningless responses, validating that LIVE captures more robust task information of VQA.\n# 5 Conclusion\nTo address the two major drawbacks of ICL in LMM\u2014long computation time and sensitivity to demonstration selection\u2014we try to apply non-learnable ICV methods from NLP to solve VQA. However, due to the complexity of VQA and the significant biases often inherent in non-learnable methods, the performance is unsatisfactory. Then we propose the Learnable ICV (LIVE) to overcome this drawback. By learning the general shift direction from a large amount of ICL data, LIVE successfully replaces the role of demonstrations in ICL. Experiments validate that LIVE outperforms traditional ICL methods and other non-learnable ICV methods on two VQA datasets. Experiments also show that LIVE, compared to LoRA, maintains excellent performance with minimal data, suggesting LIVE is a new research direction for LMMs to solve multimodal tasks. In the future, we will explore the application of LIVE on more multimodal tasks by various LMMs.\n# Acknowledgement\nThis work is supported by National Science Foundation of China (62206048), Natural Science Foundation of Jiangsu Province (BK20220819), Young Elite Scientists Sponsorship Program of Jiangsu Association for Science and Technology Tj-2022-027, Fundamental Research Funds for the Central Universities(2242024k30035) and Big Data Computing Center of Southeast University\n[1] Josh Achiam, Steven Adler, Sandhini Agarwal, Lama Ahmad, Ilge Akkaya, Florencia Leoni Aleman, Diogo Almeida, Janko Altenschmidt, Sam Altman, Shyamal Anadkat, et al. Gpt-4 technical report. ArXiv preprint, abs/2303.08774, 2023. [2] Hugo Touvron, Thibaut Lavril, Gautier Izacard, Xavier Martinet, Marie-Anne Lachaux, Timoth\u00e9e Lacroix, Baptiste Rozi\u00e8re, Naman Goyal, Eric Hambro, Faisal Azhar, et al. Llama: Open and efficient foundation language models. ArXiv preprint, abs/2302.13971, 2023. [3] Hugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajjwal Bhargava, Shruti Bhosale, et al. Llama 2: Open foundation and fine-tuned chat models. ArXiv preprint, abs/2307.09288, 2023. [4] Jiachang Liu, Dinghan Shen, Yizhe Zhang, Bill Dolan, Lawrence Carin, and Weizhu Chen. What makes good in-context examples for GPT-3? In Proceedings of Deep Learning Inside Out (DeeLIO 2022): The 3rd Workshop on Knowledge Extraction and Integration for Deep Learning Architectures, pages 100\u2013114, Dublin, Ireland and Online, 2022. Association for Computational Linguistics. [5] Shuxia Lin, Miaosen Zhang, Ruiming Chen, Xu Yang, Qiufeng Wang, and Xin Geng. Linearly decomposing and recomposing vision transformers for diverse-scale models. In The Thirtyeighth Annual Conference on Neural Information Processing Systems, 2024. [6] Qiufeng Wang, Xu Yang, Fu Feng, Jing Wang, and Xin Geng. Cluster-learngene: Inheriting adaptive clusters for vision transformers. In The Thirty-eighth Annual Conference on Neural Information Processing Systems, 2024. [7] Qingxiu Dong, Lei Li, Damai Dai, Ce Zheng, Zhiyong Wu, Baobao Chang, Xu Sun, Jingjing Xu, and Zhifang Sui. A survey on in-context learning. ArXiv preprint, abs/2301.00234, 2023. [8] Jean-Baptiste Alayrac, Jeff Donahue, Pauline Luc, Antoine Miech, Iain Barr, Yana Hasson, Karel Lenc, Arthur Mensch, Katherine Millican, Malcolm Reynolds, et al. Flamingo: a visual language model for few-shot learning. Advances in neural information processing systems, 35:23716\u201323736, 2022. [9] Hugo Lauren\u00e7on, Lucile Saulnier, L\u00e9o Tronchon, Stas Bekman, Amanpreet Singh, Anton Lozhkov, Thomas Wang, Siddharth Karamcheti, Alexander M. Rush, Douwe Kiela, Matthieu Cord, and Victor Sanh. Obelics: An open web-scale filtered dataset of interleaved image-text documents, 2023. 10] Maria Tsimpoukelli, Jacob Menick, Serkan Cabi, S. M. Ali Eslami, Oriol Vinyals, and Felix Hill. Multimodal few-shot learning with frozen language models. In Marc\u2019Aurelio Ranzato, Alina Beygelzimer, Yann N. Dauphin, Percy Liang, and Jennifer Wortman Vaughan, editors, Advances in Neural Information Processing Systems 34: Annual Conference on Neural Information Processing Systems 2021, NeurIPS 2021, December 6-14, 2021, virtual, pages 200\u2013212, 2021. 11] Feng Nie, Meixi Chen, Zhirui Zhang, and Xu Cheng. Improving few-shot performance of language models via nearest neighbor calibration. ArXiv preprint, abs/2212.02216, 2022. 12] Yao Lu, Max Bartolo, Alastair Moore, Sebastian Riedel, and Pontus Stenetorp. Fantastically ordered prompts and where to find them: Overcoming few-shot prompt order sensitivity. In Proceedings of the 60th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 8086\u20138098, Dublin, Ireland, 2022. Association for Computational Linguistics. 13] Tianyu Gao, Adam Fisch, and Danqi Chen. Making pre-trained language models better few-shot learners. In Proceedings of the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing (Volume 1: Long Papers), pages 3816\u20133830, Online, 2021. Association for Computational Linguistics.\n[14] Zhiyong Wu, Yaoxiang Wang, Jiacheng Ye, and Lingpeng Kong. Self-adaptive in-context learning: An information compression perspective for in-context example selection and ordering. ArXiv preprint, abs/2212.10375, 2022. [15] Tai Nguyen and Eric Wong. In-context example selection with influences. ArXiv preprint, abs/2302.11042, 2023. [16] Xiaonan Li and Xipeng Qiu. Finding supporting examples for in-context learning. arXiv e-prints, pages arXiv\u20132302, 2023. [17] Yiming Zhang, Shi Feng, and Chenhao Tan. Active example selection for in-context learning. In Proceedings of the 2022 Conference on Empirical Methods in Natural Language Processing, pages 9134\u20139148, Abu Dhabi, United Arab Emirates, 2022. Association for Computational Linguistics. [18] Li Li, Jiawei Peng, Huiyi Chen, Chongyang Gao, and Xu Yang. How to configure good in-context sequence for visual question answering. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 26710\u201326720, 2024. [19] Xu Yang, Yongliang Wu, Mingzhuo Yang, Haokun Chen, and Xin Geng. Exploring diverse in-context configurations for image captioning. Advances in Neural Information Processing Systems, 36, 2024. [20] Roee Hendel, Mor Geva, and Amir Globerson. In-context learning creates task vectors. ArXiv preprint, abs/2310.15916, 2023. [21] Eric Todd, Millicent L Li, Arnab Sen Sharma, Aaron Mueller, Byron C Wallace, and David Bau. Function vectors in large language models. ArXiv preprint, abs/2310.15213, 2023. [22] Sheng Liu, Lei Xing, and James Zou. In-context vectors: Making in context learning more effective and controllable through latent space steering. ArXiv preprint, abs/2311.06668, 2023. [23] Kim Anh Nguyen, Sabine Schulte im Walde, and Ngoc Thang Vu. Distinguishing antonyms and synonyms in a pattern-based neural network. In Proceedings of the 15th Conference of the European Chapter of the Association for Computational Linguistics: Volume 1, Long Papers, pages 76\u201385, Valencia, Spain, 2017. Association for Computational Linguistics. [24] Lean Wang, Lei Li, Damai Dai, Deli Chen, Hao Zhou, Fandong Meng, Jie Zhou, and Xu Sun. Label words are anchors: An information flow perspective for understanding in-context learning. ArXiv preprint, abs/2305.14160, 2023. [25] Edward J. Hu, Yelong Shen, Phillip Wallis, Zeyuan Allen-Zhu, Yuanzhi Li, Shean Wang, Lu Wang, and Weizhu Chen. Lora: Low-rank adaptation of large language models. In The Tenth International Conference on Learning Representations, ICLR 2022, Virtual Event, April 25-29, 2022. OpenReview.net, 2022. [26] Tom B. Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, Sandhini Agarwal, Ariel Herbert-Voss, Gretchen Krueger, Tom Henighan, Rewon Child, Aditya Ramesh, Daniel M. Ziegler, Jeffrey Wu, Clemens Winter, Christopher Hesse, Mark Chen, Eric Sigler, Mateusz Litwin, Scott Gray, Benjamin Chess, Jack Clark, Christopher Berner, Sam McCandlish, Alec Radford, Ilya Sutskever, and Dario Amodei. Language models are few-shot learners. In Hugo Larochelle, Marc\u2019Aurelio Ranzato, Raia Hadsell, Maria-Florina Balcan, and Hsuan-Tien Lin, editors, Advances in Neural Information Processing Systems 33: Annual Conference on Neural Information Processing Systems 2020, NeurIPS 2020, December 6-12, 2020, virtual, 2020. [27] Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei, Ilya Sutskever, et al. Language models are unsupervised multitask learners. OpenAI blog, 1(8):9, 2019. [28] Yu Sun, Shuohuan Wang, Shikun Feng, Siyu Ding, Chao Pang, Junyuan Shang, Jiaxiang Liu, Xuyi Chen, Yanbin Zhao, Yuxiang Lu, et al. Ernie 3.0: Large-scale knowledge enhanced pre-training for language understanding and generation. ArXiv preprint, abs/2107.02137, 2021.\n[29] Jincen Jiang, Qianyu Zhou, Yuhang Li, Xuequan Lu, Meili Wang, Lizhuang Ma, Jian Chang, and Jian Jun Zhang. Dg-pic: Domain generalized point-in-context learning for point cloud understanding. In European Conference on Computer Vision (ECCV). Springer, 2024. [30] Tingbing Yan, Wenzheng Zeng, Yang Xiao, Xingyu Tong, Bo Tan, Zhiwen Fang, Zhiguo Cao, and Joey Tianyi Zhou. Crossglg: Llm guides one-shot skeleton-based 3d action recognition in a cross-level manner. arXiv preprint arXiv:2403.10082, 2024. [31] Congzhi Zhang, Linhai Zhang, and Deyu Zhou. Causal walk: Debiasing multi-hop fact verification with front-door adjustment. In Proceedings of the AAAI Conference on Artificial Intelligence, volume 38, pages 19533\u201319541, 2024. [32] Congzhi Zhang, Linhai Zhang, Jialong Wu, Deyu Zhou, and Yulan He. Causal prompting: Debiasing large language model prompting based on front-door adjustment, 2024. [33] Hanshi Sun, Zhuoming Chen, Xinyu Yang, Yuandong Tian, and Beidi Chen. Triforce: Lossless acceleration of long sequence generation with hierarchical speculative decoding. ArXiv preprint, abs/2404.11912, 2024. [34] Marius Mosbach, Tiago Pimentel, Shauli Ravfogel, Dietrich Klakow, and Yanai Elazar. Few-shot fine-tuning vs. in-context learning: A fair comparison and evaluation. In Anna Rogers, Jordan Boyd-Graber, and Naoaki Okazaki, editors, Findings of the Association for Computational Linguistics: ACL 2023, pages 12284\u201312314, Toronto, Canada, July 2023. Association for Computational Linguistics. [35] Yaru Hao, Yutao Sun, Li Dong, Zhixiong Han, Yuxian Gu, and Furu Wei. Structured prompting: Scaling in-context learning to 1,000 examples. arXiv preprint arXiv:2212.06713, 2022. [36] Yixiao Yuan, Yawen Huang, and Yi Zhou. Rethinking a unified generative adversarial model for mri modality completion. In Anirban Mukhopadhyay, Ilkay Oksuz, Sandy Engelhardt, Dajiang Zhu, and Yixuan Yuan, editors, Deep Generative Models, pages 143\u2013153, Cham, 2024. Springer Nature Switzerland. [37] Xinyi Wang, Wanrong Zhu, Michael Saxon, Mark Steyvers, and William Yang Wang. Large language models are latent variable models: Explaining and finding good demonstrations for in-context learning. Advances in Neural Information Processing Systems, 36, 2024. [38] Chengwei Qin, Aston Zhang, Anirudh Dagar, and Wenming Ye. In-context learning with iterative demonstration selection. arXiv preprint arXiv:2310.09881, 2023. [39] Chengwei Qin, Wenhan Xia, Fangkai Jiao, and Shafiq Joty. Improving in-context learning via bidirectional alignment. arXiv preprint arXiv:2312.17055, 2023. [40] Guangxuan Xiao, Yuandong Tian, Beidi Chen, Song Han, and Mike Lewis. Efficient streaming language models with attention sinks. arXiv preprint arXiv:2309.17453, 2023. [41] Yichen Zhu, Minjie Zhu, Ning Liu, Zhicai Ou, Xiaofeng Mou, and Jian Tang. Llava-\\\u03d5: Efficient multi-modal assistant with small language model. ArXiv preprint, abs/2401.02330, 2024. [42] Haotian Liu, Chunyuan Li, Yuheng Li, and Yong Jae Lee. Improved baselines with visual instruction tuning. ArXiv preprint, abs/2310.03744, 2023. [43] Anas Awadalla, Irena Gao, Josh Gardner, Jack Hessel, Yusuf Hanafy, Wanrong Zhu, Kalyani Marathe, Yonatan Bitton, Samir Gadre, Shiori Sagawa, et al. Openflamingo: An opensource framework for training large autoregressive vision-language models. ArXiv preprint, abs/2308.01390, 2023. [44] Deyao Zhu, Jun Chen, Xiaoqian Shen, Xiang Li, and Mohamed Elhoseiny. Minigpt-4: Enhancing vision-language understanding with advanced large language models. ArXiv preprint, abs/2304.10592, 2023. [45] Bo Li, Yuanhan Zhang, Liangyu Chen, Jinghao Wang, Fanyi Pu, Jingkang Yang, Chunyuan Li, and Ziwei Liu. Mimic-it: Multi-modal in-context instruction tuning. ArXiv preprint, abs/2306.05425, 2023.\n[46] Shukang Yin, Chaoyou Fu, Sirui Zhao, Ke Li, Xing Sun, Tong Xu, and Enhong Chen. A survey on multimodal large language models. ArXiv preprint, abs/2306.13549, 2023. [47] Yash Goyal, Tejas Khot, Douglas Summers-Stay, Dhruv Batra, and Devi Parikh. Making the V in VQA matter: Elevating the role of image understanding in visual question answering. In 2017 IEEE Conference on Computer Vision and Pattern Recognition, CVPR 2017, Honolulu, HI, USA, July 21-26, 2017, pages 6325\u20136334. IEEE Computer Society, 2017. [48] Kenneth Marino, Mohammad Rastegari, Ali Farhadi, and Roozbeh Mottaghi. OK-VQA: A visual question answering benchmark requiring external knowledge. In IEEE Conference on Computer Vision and Pattern Recognition, CVPR 2019, Long Beach, CA, USA, June 16-20, 2019, pages 3195\u20133204. Computer Vision Foundation / IEEE, 2019. [49] Mor Geva, Roei Schuster, Jonathan Berant, and Omer Levy. Transformer feed-forward layers are key-value memories. arXiv preprint arXiv:2012.14913, 2020. [50] Nora Belrose, Zach Furman, Logan Smith, Danny Halawi, Igor Ostrovsky, Lev McKinney, Stella Biderman, and Jacob Steinhardt. Eliciting latent predictions from transformers with the tuned lens. arXiv preprint arXiv:2303.08112, 2023. [51] Guy Dar, Mor Geva, Ankit Gupta, and Jonathan Berant. Analyzing transformers in embedding space. arXiv preprint arXiv:2209.02535, 2022. [52] Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In Yoshua Bengio and Yann LeCun, editors, 3rd International Conference on Learning Representations, ICLR 2015, San Diego, CA, USA, May 7-9, 2015, Conference Track Proceedings, 2015. [53] Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. Dropout: a simple way to prevent neural networks from overfitting. The journal of machine learning research, 15(1):1929\u20131958, 2014. [54] Xinlei Chen, Hao Fang, Tsung-Yi Lin, Ramakrishna Vedantam, Saurabh Gupta, Piotr Doll\u00e1r, and C Lawrence Zitnick. Microsoft coco captions: Data collection and evaluation server. ArXiv preprint, abs/1504.00325, 2015. [55] Anand Mishra, Shashank Shekhar, Ajeet Kumar Singh, and Anirban Chakraborty. Ocr-vqa: Visual question answering by reading text in images. In 2019 international conference on document analysis and recognition (ICDAR), pages 947\u2013952. IEEE, 2019. [56] Yongshuo Zong, Ondrej Bohdal, and Timothy Hospedales. Vl-icl bench: The devil in the details of benchmarking multimodal in-context learning. arXiv preprint arXiv:2403.13164, 2024. [57] Hugo Lauren\u00e7on, L\u00e9o Tronchon, Matthieu Cord, and Victor Sanh. What matters when building vision-language models? ArXiv preprint, abs/2405.02246, 2024. [58] Shuo Chen, Zhen Han, Bailan He, Mark Buckley, Philip Torr, Volker Tresp, and Jindong Gu. Understanding and improving in-context learning on vision-language models. ArXiv preprint, abs/2311.18021, 2023.\n# A Implementation Details.\n# A.1 LIVE Hyperparameters\nTable 7 presents the hyper-parameters utilized for training the LIVE. The optimizer denotes the optimization algorithm employed during model training. For V and \u03b1, we use different learning rate to optimize. The \u03bb represents the weight assigned to Lgt in Eq 7 during training. Precision refers to the float precision type used for model weights and gradient descent throughout the ICV training process. Weight Decay signifies the rate of weight decay applied during training, the warm up value is set to 0.01. while accumulate batches denotes the batch size for gradient accumulation during the training phase.\n<div style=\"text-align: center;\">Table 7: VQAv2 and OKVQA LIVE Training Parameters</div>\nHyperparameter\nVQAv2\nOKVQA\noptimizer\nAdamW [52]\nAdamW\nlearning rate of \u03b1\n1e-2\n1e-2\nlearning rate of V\n1e-3\n5e-3\n\u03bb\n0.5\n0.5\nweight decay\n1e-3\n1e-3\nprecision\nFP16\nFP16\nbatch size\n2\n2\nwarm up\n0.1\n0.1\naccumulate batches\n8\n8\nnumber of epochs\n10\n10\n# A.2 LoRA Hyperparameters\nTable 8 details the hyper-parameters for the LoRA model trained during our experiment. Both the OKVQA and VQAv2 datasets use the same hyper-parameters.\n<div style=\"text-align: center;\">Table 8: LoRA Training Parameters</div>\nHyperparameter\nValue\noptimizer\nAdamW\nlearning rate\n1e-3\nLoRA matrix rank\n32\nLoRA dropout rate[53]\n0.05\nbatch size\n2\nwarm up\n0.1\nnumber of epochs\n10\n# A.3 Inference and hardware details\nIn our ICV inference process, we employ the following hyperparameters: For ICV model inference, the maximum number of new tokens is set to 5, the number of beam searches is set to 3, the length penalty is set to 0, and the minimum number of generated tokens is set to 0. During the inference process, we utilize two Xeon Silver 3414 CPUs, one RTX 3090 GPU, and 384 GB of memory.\n# B Detailed Results\n# B.1 The Detailed Inference Speed Experiments\nThis subsection provides a detailed presentation of some experimental data, primarily including forward propagation FLOPs and runtime cost, as well as a comparison of specific data between LIVE and LoRA. Table 9 presents the detailed results of the runtime and the FLOPs shown in Figure 3.\nFor a forward operation LIVE compared to k-shot ICL. The average token length during the forward inference is 38 tokens for Zero-Shot and LIVE, 107 tokens for 4-shot ICL, 187 tokens for 8-shot ICL, 330 tokens for 16-shot ICL, and 633 tokens for 32-shot ICL.\n<div style=\"text-align: center;\">Table 9: Comparison of FLOPs and Runtime for LIVE and k-shot ICL</div>\nMertic\nZero-Shot\nLIVE\n4-shot ICL\n8-shot ICL\n16-shot ICL\n32-shot ICL\nFLOPs (TFLOPs)\n0.935\n0.936\n3.568\n6.375\n12.341\n23.364\nRuntime (ms)\n56.69\n56.81\n92.44\n158.21\n266.13\n468.55\n# B.2 The Detailed Accuracy of Different Training Dataset\nTable 10 presents a comparative analysis of the results between LoRA and LIVE results on different training dataset size in Section 4.3.\n# B.3 Non-Learnable Methods Results\nFunction Vector: This section examines the test results of the function vector employed in the experiment across different layers of the IDEFICS-9B model. Table 11 presents the test results for VQAv2, and Table 12 shows the test results for OKVQA. The Best result of VQAv2 is 10th layer\u2019s result, which reaches 30.21, and the best result of OKVQA is 31.02 from the first layer.\n<div style=\"text-align: center;\">Table 10: Accuracy (%) of LoRA and LIVE on different training set sizes</div>\nDataset\nMethod\nTraining set size\n100\n300\n500\n700\n900\n1000\n2000\n4000\n6000\n8000\nVQAv2\nLIVE\n29.43\n49.66\n49.93\n51.03\n53.42\n53.71\n56.64\n57.76\n58.33\n58.54\nLoRA\n29.52\n39.02\n40.01\n40.99\n41.99\n42.81\n45.26\n47.71\n48.51\n49.02\nOKVQA\nLIVE\n30.64\n38.41\n41.87\n45.82\n46.09\n46.05\n47.22\n48.39\n49.68\n50.08\nLORA\n30.37\n13.38\n20.01\n23.42\n25.01\n25.66\n29.52\n33.08\n34.17\n34.21\n<div style=\"text-align: center;\">able 11: The Function Vector Accuracy (%) acorss differnt layers on VQA</div>\nVQAv2\nlayer:1\nlayer:2\nlayer:3\nlayer:4\nlayer:5\nlayer:6\nlayer:7\n29.28\n29.0\n28.5\n27.43\n27.94\n28.7\n29.17\nlayer:9\nlayer:10\nlayer:11\nlayer:12\nlayer:13\nlayer:14\nlayer:15\n29.34\n30.21\n29.94\n29.48\n29.52\n29.38\n29.62\nlayer:17\nlayer:18\nlayer:19\nlayer:20\nlayer:21\nlayer:22\nlayer:23\n29.51\n29.59\n29.5\n29.28\n29.24\n29.29\n29.11\nlayer:25\nlayer:26\nlayer:27\nlayer:28\nlayer:29\nlayer:30\nlayer:31\n29.34\n29.19\n29.26\n29.18\n29.19\n29.45\n29.32\nTask Vector: This section examines the test results of the task vector utilized in the experiment across various layers of the IDEFICS model. Table 13 displays the test results for VQAv2, while Table 14 shows the test results for OKVQA. The task vector is derived using 32 question-answer pairs. The best result of the task vector on VQAv2 is at the 10th layer, reaching 43.68, while the best result on OKVQA is at the 12th layer, reaching 32.68. PCA-ICV: PCA-ICV employs a weighting factor \u03b1 to regulate the degree of interference ICV has on the model. We test various values of \u03b1 to assess performance. Table 15 shows the results of PCA-ICV on VQAv2 and OKVQA datasets with different \u03b1 value and extract samples. It is evident\n<div style=\"text-align: center;\">ble 12: The Function Vector Accuracy (%) acorss differnt layers on OKV</div>\nOKVQA\nlayer:1\nlayer:2\nlayer:3\nlayer:4\nlayer:5\nlayer:6\nlayer:7\nlayer:8\n31.02\n30.57\n30.23\n30.27\n30.04\n30.36\n30.61\n30.23\nlayer:9\nlayer:10\nlayer:11\nlayer:12\nlayer:13\nlayer:14\nlayer:15\nlayer:16\n30.56\n30.62\n30.6\n30.27\n30.22\n30.19\n30.2\n30.3\nlayer:17\nlayer:18\nlayer:19\nlayer:20\nlayer:21\nlayer:22\nlayer:23\nlayer:24\n30.44\n30.25\n30.27\n30.17\n30.22\n30.16\n30.31\n30.23\nlayer:25\nlayer:26\nlayer:27\nlayer:28\nlayer:29\nlayer:30\nlayer:31\nlayer:32\n30.42\n30.32\n30.34\n30.25\n30.3\n30.34\n30.4\n30.28\nVQAv2\nlayer:1\nlayer:2\nlayer:3\nlayer:4\nlayer:5\nlayer:6\nlayer:7\n28.18\n28.82\n30.47\n30.53\n36.41\n35.35\n36.17\nlayer:9\nlayer:10\nlayer:11\nlayer:12\nlayer:13\nlayer:14\nlayer:15\n41.72\n43.68\n40.33\n34.32\n16.91\n15.42\n14.53\nlayer:17\nlayer:18\nlayer:19\nlayer:20\nlayer:21\nlayer:22\nlayer:23\n12.94\n12.44\n12.28\n11.89\n11.98\n11.78\n11.44\nlayer:25\nlayer:26\nlayer:27\nlayer:28\nlayer:29\nlayer:30\nlayer:31\n12.8\n12.95\n12.97\n12.86\n12.87\n13.29\n14.7\n<div style=\"text-align: center;\">Table 14: The Task Vector Accuracy (%) acorss differnt layers on OKVQ</div>\nOKVQA\nlayer:0\nlayer:1\nlayer:2\nlayer:3\nlayer:4\nlayer:5\nlayer:6\nlayer:7\n13.58\n14.4\n15.3\n15.0\n15.79\n18.06\n19.18\n22.37\nlayer:8\nlayer:9\nlayer:10\nlayer:11\nlayer:12\nlayer:13\nlayer:14\nlayer:15\n21.71\n22.93\n32.5\n31.99\n32.68\n29.38\n21.4\n17.27\nlayer:16\nlayer:17\nlayer:18\nlayer:19\nlayer:20\nlayer:21\nlayer:22\nlayer:23\n6.49\n0.94\n0.5\n0.53\n0.46\n0.32\n0.34\n0.29\nlayer:24\nlayer:25\nlayer:26\nlayer:27\nlayer:28\nlayer:29\nlayer:30\nlayer:31\n0.28\n0.3\n0.3\n0.29\n0.33\n0.33\n0.33\n1.11\nthat the optimal alpha for the VQAv2 dataset significantly differs from that for OKVQA. The optimal result of PCA-ICV on VQAv2 is 34.75 when alpha is set to 1e-2, while the best result for PCA-ICV is 30.59 when alpha is set to 1e-5.\n<div style=\"text-align: center;\">Table 15: The PCA-ICV Accuracy (%) acorss differnt alpha</div>\nDataset\nSamples\nAlpha\n1e-2\n1e-3\n1e-4\n1e-5\nVQAv2\n32\n34.75\n30.95\n30.06\n30.0\nOKVQA\n32\n22.46\n30.06\n30.23\n30.59\nLIVE is essentially a shift vector, allowing us to control the shift directions of query representations, which means we can control the shift direction of LMMs by adding or subtracting different shift vectors. Therefore, we can use several LIVE trained on different VQA dataset to get the General LIVE. Specifically, given the diverse VQA task set T = {t1, . . . , tn}, where ti is a VQA task and n is the number of tasks, we train the task-specific LIVE V i = {vi 1, . . . , vi L} and the weight factor \u03b1i = {\u03b1i 1, . . . , \u03b1i L} on each VQA dataset. Then, we have the LIVE set Vset = {V 1, . . . , V n} and its weight factors set \u03b1set = {\u03b11, . . . , \u03b1n}. The General LIVE has the same shape of task-specific LIVE. For the l-th layer, it is defined as vl = \ufffd i \u03b1i lvi l. During inference, we use the vector vl to shift the original representation, resulting in Ml(\u02c6xi)\u2032 = Ml(\u02c6xi) + vl. We average the LIVE trained in OKVQA and VQAv2 to get the general ICV and evaluate the performance of the general ICV Vg = {v1, . . . , vL} on OKVQA and VQAv2, with the results presented on Table 16.\n<div style=\"text-align: center;\">Table 16: Accuracy (%) for 32-shot ICL, task-specific LIVE, General LIV</div>\nMethods\n32-shot ICL\nLIVE\nGeneral LIVE\nVQAv2\n56.18\n58.54\n56.17\nOKVQA\n48.48\n50.08\n49.52\nThe results indicate that while the performance of the general ICV is somewhat reduced compared to task-specific LIVE; it decreased by 2.37 on VQAv2 and by 0.56 on OKVQA. However, its performance is very close to that of 32-shot ICL. Most importantly, it offers significant advantages in real-world scenarios where the distribution of test data is unknown. This makes the general ICV more suitable for practical applications, providing a robust solution that can be effectively utilized across varying environments. Furthermore, the findings highlight the scalability of LIVE: whenever a new VQA dataset is used to train LIVE, we only need to simply recalculate the mean shift vectors of all previously trained task-specific LIVEs and the new LIVE to generate a new general ICV, thus creating a more general VQA LIVE. This approach not only simplifies the adaptation process for diverse tasks but also ensures that the model maintains a high level of performance across different applications. The results, therefore, underscore the potential of general ICVs to enhance the flexibility and applicability of VQA systems in real-world settings.\n# D More exploratory experiments.\n# D.1 Generalization Ability\nWe conducted supplementary experiments on other vision-language tasks and LMMs to demonstrate the general applicability of our LIVE method.\n# D.1.1 Task Generalization\nIn Table 17, we utilized IDEFICSv1-9B as the baseline model to evaluate the performance of LIVE against ICL and LoRA on the COCO caption dataset[54], OcrVQA dataset[55], and VL-ICL dataset[56]. Experimental results demonstrate that our method consistently maintains advantages over both ICL and LoRA across various tasks.\n<div style=\"text-align: center;\">Table 17: Accuracy (%) for 32-shot ICL, LoRA, and LIVE in various dataset.</div>\nTask (Metric)\n32-shot ICL\nLoRA\nLIVE\nCOCO (CIDEr)\n106.31\n109.18\n117.38\nVL-ICL Textocr (ACC)\n21.5\n22.5\n24.0\nVL-ICL Clevr (ACC)\n33.5\n35.5\n37.0\nOcrVQA (ACC)\n16.3\n15.9\n17.5\nTo test the generalizability of our method across different architectural models, we extended LIVE to IDEFICSv2 model[57]. It is noteworthy that IDEFICSv2 (8B-base) differs from IDEFICSv1 in its handling of image-text interactions; while IDEFICSv1 uses a cross-attention mechanism for the fusion of image and text tokens, IDEFICSv2 utilizes an additional projection layer to map image information into the text space for LMM processing. These two architectures represent the primary approaches within LMM. Conducting experiments with this model can validate the generalizability of LIVE. Due to the longer input sequence of IDEFICSv2 compared to IDEFICSv1, we reached the limits of our GPU memory during 8-shot ICL inference. Therefore, we compared the LIVE trained on 8-shot data with 1-8 shot ICL. As shown in Table 18, LIVE improves upon 8-shot ICL by 6.1% and 0.84% on VQAv2 and OKVQA, respectively. In terms of inference speed, it surpasses 8-shot ICL by a factor of 8.95. These results demonstrate that the LIVE method is both generalizable and effective within LMM, excelling in both inference accuracy and speed compared to ICL.\n<div style=\"text-align: center;\">ble 18: The performance comparison between LIVE and ICL on IDEFIC</div>\nMethod\nVQAv2 ACC\nOKVQA ACC\nInference Time\nFLOPs (TFLOPs)\nZero-shot\n55.39\n43.08\n0.087 (\u00d7 0.97)\n3.110 (\u00d7 0.99)\n1-shot ICL\n60.33\n45.65\n0.168 (\u00d7 1.90)\n6.497 (\u00d7 2.07)\n2-shot ICL\n63.49\n50.40\n0.237 (\u00d7 2.68)\n9.610 (\u00d7 3.06)\n4-shot ICL\n64.88\n53.18\n0.395 (\u00d7 4.46)\n17.139 (\u00d7 5.46)\n8-shot ICL\n66.20\n57.68\n0.792 (\u00d7 8.95)\n32.130 (\u00d7 10.23)\n8-shot LIVE\n70.30\n58.52\n0.089 (\u00d7 1)\n3.141 (\u00d7 1)\n# D.2 Performance with more shot\nTo investigate the impact of a higher number of shots on LIVE, we conducted a comparison with ICL at 48 and 64 shots. Detail results are shown in Table 19 .The results indicate that while increasing the number of shots improves the performance of both methods, they have reached a performance plateau. Notably, the gains achieved by LIVE remain superior to those of ICL. For example, with 64 shots LIVE achieves a 2.99%/1.85% improvement over ICL on VQAv2/OKVQ. Thus, although using more ICDs improves ICL performance, LIVE has a large improvement\nBenchmark\nMethod\nShot 16\nShot 32\nShot 48\nShot 64\nVQAv2\nICL\n55.7\n56.18\n56.67\n56.71\nLIVE\n58.27 (+2.57)\n58.54 (+2.36)\n59.07 (+2.4)\n59.70 (+2.99)\nOKVQA\nICL\n47.7\n48.48\n48.68\n48.60\nLIVE\n49.71 (+2.01)\n50.08 (+1.6)\n50.55 (+1.87)\n50.45 (+1.85)\n# D.3 Shared layer LIVE\nWe conducted experiments to investigate the impact of using a shared bias vector across all layers (as shown in Table 20), and we observed a significant performance drop compared to LIVE: 20.6% on VQAv2 and 9.01% on OKVQA. This performance drop aligns with the findings in [24] that different Transformer layers play diverse roles in ICL. Also, Eq 5 show that LIVE vectors are layer-specific Then using a single shared vector fails to capture the distinct information processed at each layer, leading to the observed decline in accuracy.\n# D.4 Detail comparisopn of LoRA\nTo provide a more detailed comparison with LoRA, we made the following modifications to LoRA. First, based on the loss function formula in Eq. 7 we applied the same loss function to LoRA. As shown in Table 21, even after modifying the loss function, LoRA\u2019s performance remains significantly lower\nMethod\nVQAv2\nOKVQA\n32-shot ICL\n56.18\n48.48\n32-shot LIVE\n58.54\n50.08\n32-shot Share LIVE\n37.94 (-20.6)\n41.07 (-9.01)\nthan LIVE on both VQAv2 (49.48% vs. 58.54%) and OKVQA (37.02% vs. 50.08%). Additionally, we fine-tuned LoRA with more parameters, but similarly, increasing the parameter count did not close the performance gap between LoRA and our LIVE, further demonstrating the effectiveness of LIVE\u2019s unique design.\nthan LIVE on both VQAv2 (49.48% vs. 58.54%) and OKVQA (37.02% vs. 50.08%). Additionally, we fine-tuned LoRA with more parameters, but similarly, increasing the parameter count did not close the performance gap between LoRA and our LIVE, further demonstrating the effectiveness of LIVE\u2019s unique design. Table 21: The performance comparison of the different implementations of LoRA with LIVE. \u201cLoRA\u201d integrates LoRA into the token classification head of the last layer to minimize the trainable parameters, \u201cLoRA with KL\u201d uses 32-shot ICDs and applies the same KL loss as our LIVE, and \u201cLoRA O_proj all layers\u201d integrates LoRA into the O_proj of all layers.\nTable 21: The performance comparison of the different implementations of LoRA with LIVE \u201cLoRA\u201d integrates LoRA into the token classification head of the last layer to minimize the trainabl parameters, \u201cLoRA with KL\u201d uses 32-shot ICDs and applies the same KL loss as our LIVE, an \u201cLoRA O_proj all layers\u201d integrates LoRA into the O_proj of all layers.\nMethod\nVQAv2\nOKVQA\nParameters Number\nLoRA\n49.02\n34.21\n1.15M (x 8 times)\nLoRA with KL\n49.48\n37.02\n1.15M (x 8 times)\nLoRA O_proj all layers\n57.57\n45.03\n10.5M (x 80 times)\nLIVE\n58.54\n50.08\n0.13M (x 1 time)\n# D.5 Comparison between untrained LIVE\nWe evaluated the impact of untrained LIVE by initializing them randomly with a normal distribution and tested on VQAv2 (Table 22), revealing that untrained LIVE has similar results as zero-shot, which are largely worse than the trained LIVE. We also visualized the embeddings using t-SNE to see the shift effect in Fig 7 (A), showing that the shift effect of untrained LIVE is similar to zero-shot ICL, while learned LIVEs align more closely with 32-shot ICL, proving that the training process is important.\n<div style=\"text-align: center;\">Table 22: The performance comparison of untrained LIVE, trained LIVE, ICL, and Zero-shot</div>\nTask\nZero Shot\nUntrained LIVE\n32-shot ICL\nTrained LIVE (Paper)\nVQAv2\n29.25\n30.3\n56.18\n58.54\nOKVQA\n30.54\n30.2\n48.48\n50.08\n<div style=\"text-align: center;\">Table 23: The performance comparison between LIVE and diverse ICL methods.</div>\nTask\nMethod\nShot 1\nShot 4\nShot 8\nShot 16\nShot 32\nAverage\nVQAv2\nLIVE\n56.84\n57.60\n58.25\n58.27\n58.54\n57.90\nICL\n51.39\n53.72\n54.24\n55.70\n56.18\n54.25\nRICE\n47.83\n53.54\n55.04\n56.89\n58.07\n54.27\nMMICES\n48.22\n54.99\n56.16\n57.02\n57.98\n54.87\nOKVQA\nLIVE\n47.51\n47.68\n49.4\n49.71\n50.08\n48.88\nICL\n40.75\n46.11\n46.79\n47.70\n48.48\n45.97\nRICE\n40.67\n47.07\n48.92\n50.73\n51.11\n47.70\nMMICES\n40.39\n47.13\n50.19\n50.46\n50.61\n47.76\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/8aed/8aedaba0-a39e-49fe-a886-7523aacb203d.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Figure 7: T-SNE visualization of first answer token over 200 queries. Left/right corresponds to VQAv2/OKVQA, respectively.</div>\n# D.6 Comparison between LIVE and diverse ICL methods.\nIn previous works[8, 19, 18], the importance of selecting ICDs for ICL in VQA and other visionlanguage tasks has been demonstrated. To reasonably compare the performance differences between LIVE and ICL, we adopted two methods for selecting ICL samples: RICE[43], which retrieves samples based on image similarity to the query, and MMICES[58], which combines both language and image similarity for ICD retrieval. The results comparing LIVE and ICL with different ICD selection strategies are presented in the Table 23, showing that even with optimized ICD selection, ICL still lags behind LIVE in terms of accuracy. We also tried to use RICE samples to learn LIVE. However, the results were unsatisfactory, with only 57.68% accuracy on VQAv2, while using random samples to train LIVE got 58.54% accuracy. This may be because using RICE samples will make each training input sequence contain abundant individual characteristics, increasing the difficulty for LIVE to learn common task knowledge, and even causing LIVE to learn spurious correlations between the similar ICDs and the query.\n",
    "paper_type": "method",
    "attri": {
        "background": "This paper addresses the issue of improving In-Context Learning (ICL) performance in Large Multimodal Models (LMMs) by proposing a new method called Learnable In-Context Vector (LIVE). Previous methods, such as non-learnable In-Context Vectors (ICVs), have shown limitations in handling complex multimodal tasks like Visual Question Answering (VQA). The need for a breakthrough arises from the challenges of increased inference time and sensitivity to the selection of in-context demonstrations (ICDs).",
        "problem": {
            "definition": "The problem addressed in this paper is the inefficiency of existing ICL methods in LMMs, particularly their inability to effectively manage the computational complexity and the selection of effective demonstrations for multimodal tasks like VQA.",
            "key obstacle": "The main difficulty lies in the increased computational load when using more ICDs, which slows down inference speed, and the sensitivity of performance to the selection of these demonstrations."
        },
        "idea": {
            "intuition": "The idea of LIVE is inspired by the observation that ICL can be viewed as a process of shifting the latent states of queries towards the target by adding a shift vector, allowing for better representation of task information.",
            "opinion": "LIVE is designed to distill essential task information from demonstrations into a single learnable vector, which can replace the need for multiple demonstrations during inference.",
            "innovation": "The primary innovation of LIVE is its learnable nature, allowing it to adaptively capture and utilize the most relevant task information from various demonstrations, unlike existing non-learnable methods."
        },
        "method": {
            "method name": "Learnable In-Context Vector",
            "method abbreviation": "LIVE",
            "method definition": "LIVE is a method that learns to capture and abstract essential task information from in-context demonstrations to enhance the performance of LMMs in VQA tasks.",
            "method description": "LIVE operates by training a set of learnable vectors that can effectively shift the representation of queries during inference, thus simulating the impact of multiple demonstrations.",
            "method steps": [
                "Initialize the learnable vectors and weight factors for each layer of the model.",
                "During training, use randomly sampled demonstrations to distill task knowledge.",
                "Minimize the Kullback-Leibler divergence between the output distributions using LIVE and the traditional method with demonstrations."
            ],
            "principle": "The effectiveness of LIVE lies in its ability to learn a general shift direction that accurately represents the task information from various demonstrations, allowing it to simulate the ICL process without requiring actual demonstrations."
        },
        "experiments": {
            "evaluation setting": "The experiments were conducted using the IDEFICS-9B model on two datasets: VQAv2 and OKVQA. The training involved 8,000 pairs from each dataset, with evaluations performed on randomly sampled validation sets.",
            "evaluation method": "Performance was assessed by comparing accuracy and computational efficiency (FLOPs and inference time) of LIVE against traditional ICL methods and other non-learnable ICV methods."
        },
        "conclusion": "The results demonstrate that LIVE significantly outperforms traditional ICL methods and other non-learnable ICV approaches in VQA tasks, effectively addressing the challenges of computational efficiency and demonstration selection sensitivity.",
        "discussion": {
            "advantage": "LIVE provides a robust solution for VQA by reducing computational costs and enhancing accuracy, while requiring fewer training samples compared to alternative methods like LoRA.",
            "limitation": "One limitation of LIVE is that it may still be influenced by the quality of the demonstrations used during training, although it is more resilient to poor selections than traditional ICL methods.",
            "future work": "Future research will explore the application of LIVE to other multimodal tasks and investigate further optimizations to enhance its performance."
        },
        "other info": {
            "code repository": "https://github.com/ForJadeForest/LIVE-Learnable-In-Context-Vector",
            "acknowledgement": "Supported by National Science Foundation of China (62206048), Natural Science Foundation of Jiangsu Province (BK20220819), Young Elite Scientists Sponsorship Program of Jiangsu Association for Science and Technology Tj-2022-027, and Fundamental Research Funds for the Central Universities."
        }
    },
    "mount_outline": [
        {
            "section number": "1.1",
            "key information": "In-Context Learning (ICL) is viewed as a process of shifting the latent states of queries towards the target by adding a shift vector, allowing for better representation of task information."
        },
        {
            "section number": "1.3",
            "key information": "The paper proposes a new method called Learnable In-Context Vector (LIVE) aimed at improving ICL performance in Large Multimodal Models (LMMs)."
        },
        {
            "section number": "3.1",
            "key information": "LIVE learns to capture and abstract essential task information from in-context demonstrations to enhance the performance of LMMs in Visual Question Answering (VQA) tasks."
        },
        {
            "section number": "3.2",
            "key information": "The primary innovation of LIVE is its learnable nature, allowing it to adaptively capture and utilize the most relevant task information from various demonstrations."
        },
        {
            "section number": "4.1",
            "key information": "LIVE operates by training a set of learnable vectors that can effectively shift the representation of queries during inference, simulating the impact of multiple demonstrations."
        },
        {
            "section number": "6.1",
            "key information": "One limitation of LIVE is its potential influence by the quality of the demonstrations used during training, although it is more resilient to poor selections than traditional ICL methods."
        },
        {
            "section number": "6.2",
            "key information": "LIVE addresses challenges of increased computational load and sensitivity to the selection of in-context demonstrations (ICDs) in multimodal tasks."
        }
    ],
    "similarity_score": 0.6948833585279962,
    "image": null,
    "path": "/home/dany/codes/autosurvey/outputs/2025-01-07-2330_in-co/papers/LIVE_ Learnable In-Context Vector for Visual Question Answering.json"
}