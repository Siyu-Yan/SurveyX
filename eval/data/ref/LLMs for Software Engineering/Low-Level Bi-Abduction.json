{
    "from": "arxiv",
    "scholar_id": null,
    "detail_id": "arXiv:2205.02590",
    "title": "Low-Level Bi-Abduction",
    "abstract": "The paper proposes a new static analysis designed to handle open programs, i.e., fragments of programs, with dynamic pointer-linked data structures - in particular, various kinds of lists - that employ advanced low-level pointer operations. The goal is to allow such programs be analysed without a need of writing analysis harnesses that would first initialise the structures being handled. The approach builds on a special flavour of separation logic and the approach of bi-abduction. The code of interest is analyzed along the call tree, starting from its leaves, with each function analysed just once without any call context, leading to a set of contracts summarizing the behaviour of the analysed functions. In order to handle the considered programs, methods of abduction existing in the literature are significantly modified and extended in the paper. The proposed approach has been implemented in a tool prototype and successfully evaluated on not large but complex programs.",
    "bib_name": "holk2022lowlevelbiabduction",
    "md_text": "# Low-Level Bi-Abduction\nThe paper proposes a new static analysis designed to handle open programs, i.e., fragments of programs, with dynamic pointer-linked data structures\u2014in particular, various kinds of lists\u2014that employ advanced low-level pointer operations. The goal is to allow such programs be analysed without a need of writing analysis harnesses that would first initialise the structures being handled. The approach builds on a special flavour of separation logic and the approach of bi-abduction. The code of interest is analyzed along the call tree, starting from its leaves, with each function analysed just once without any call context, leading to a set of contracts summarizing the behaviour of the analysed functions. In order to handle the considered programs, methods of abduction existing in the literature are significantly modified and extended in the paper. The proposed approach has been implemented in a tool prototype and successfully evaluated on not large but complex programs. 2012 ACM Subject Classification Theory of computation \u00d1 Separation logic; Theory of computation \u00d1 Logic and verification; Software and its engineering \u00d1 Formal software verification Keywords and phrases programs with dynamic linked data structures, programs with pointers, low-level pointer operations, static analysis, shape analysis, separation logic, bi-abduction Funding The Czech authors were supported by the project 20-07487S of the Czech Science Foundation, the FIT BUT internal project FIT-S-20-6427, and L. Hol\u00edk by the ERC.CZ project LL1908.\n# Introduction\nPrograms with complex dynamic data structures and pointer operations are notoriously difficult to write and understand. This holds twice when a need to achieve the best possible performance drives programmers, especially those working in the C language on which we concentrate, to start using advanced low-level pointer operations such as pointer arithmetic, bit-masking information on pointers, address alignment, block operations with blocks that are split to differently sized fields (of size not known in advance), which can then be merged again, and reinterpreted differently, and so on. It may then easily happen that the resulting programs contain nasty errors, such as null-pointer dereferences, out-of-bound references, double free operations, or memory leaks, which can manifest only under some rare circumstances, may escape traditional testing, and be difficult to discover once the program is in production. To help discover such problems (or show their absence), suitable static analyses with formal roots may help. However, the problem of analysing programs with dynamic pointer-linked data structures, sometimes referred to as shape analysis, belongs among the most difficult analysis problems, which is related to a need of efficiently encoding and handling potentially infinite sets of graph structures of in-advance unknown shape and unbounded size, corresponding to the possible memory configurations. Moreover, the problem becomes even harder when one needs to analyse not entire programs, equipped with some analysis harness generating instances of the data structures to be handled, but just fragments of code, which simply start handling some dynamic data structures through pointers without the structures being initialised first. At the same time, in practice, the possibility of analysing code fragments is highly preferred since programmers do not like writing specialised analysis harnesses for\ninitialising data structures of the code to be analysed (not speaking about that writing such harnesses is error-prone too). Moreover, the possibility of analysing code fragments can also help scalability of the analysis since it can then be performed in a modular way.\nis error-prone too). Moreover, the possibility of analysing code fragments can also help scalability of the analysis since it can then be performed in a modular way. In this paper, we propose a new analysis designed to analyse programs and even fragments of programs with dynamic pointer-linked data structures that can use advanced low-level pointermanipulating operations of the form mentioned above. In particular, we concentrate on sequential C programs without recursion and without function pointers manipulating various forms of lists\u2014 singly-linked, doubly-linked, circular, nested, and/or intrusive, which are perhaps the most common kind of dynamic linked data structures in practice. Our approach uses a special flavor of separation logic (SL) [32, 23] with inductive list predicates [2] to characterize sets of program configurations. To be able to handle code fragments, we adopt the principle of bi-abductive analysis proposed over SL for analysing programs without low-level pointer operations in [6, 7]. Our work can thus be viewed as an extension of the approach of [6, 7] to programs with truly low-level operations (i.e., pointer arithmetic, bit-masking on pointers, block operations with blocks of variable size, their splitting to fields of in-advance-not-fixed size, merging such fields back, and reinterpreting them differently, etc.). As will become clear, handling such programs requires rather non-trivial changes to the abduction procedure used in [6, 7]\u2014intuitively, one needs new analysis rules for block splitting and merging, new support for operations such as pointer plus, pointer minus, or block operations (like memcpy), and also modified support for operations like memory allocation or deallocation (to avoid deallocation of parts of blocks). Moreover, to support splitting of memory blocks to parts, gradually learning their bounds and fields, and to allow for embedding data structures into other data structures not known in advance (as commonly done, e.g., in the so-called intrusive lists), we even switch from using the traditional per-object separating conjunction in our SL to a per-field separating conjunction (as used, e.g., in [14] in the context of analysing so-called overlaid data structures), requiring separation not on the level of allocated memory blocks but their fields. As an additional benefit, our usage of per-field separating conjunction then allows us to represent more compactly even some operations on traditional data structures (without low-level pointer manipulation). As common in bi-abductive analyses, we analyse programs, or their fragments, along their call tree, starting from the leaves of the call tree (for the time being, we assume working with nonrecursive programs only). Each function is analysed just once, without any knowledge about its possible call contexts. For each function, the analysis derives a set of so-called contracts, which can then be used when this function is called from some other function higher up in the call hierarchy. A contract for a function f is a pair pP, Qq where P is a precondition under which f can be safely executed (without a risk of running into some memory error such as a null-dereference), and Q is a postcondition that is guaranteed to be satisfied upon exit from f provided it was called under the given precondition. Both P and Q are described using our flavor of SL. In fact, as also done in [6, 7], our analysis runs in two phases: the first phase derives the preconditions, while the second phase computes the postconditions. Like in [6, 7], the computed set of contracts may under-approximate the set of all possible safe preconditions of f (e.g., some extreme but still safe preconditions need not be discovered). However, for each computed contract pP, Qq, the post-condition Q is guaranteed to over-approximate all configurations that result from calling the function under the pre-condition P. We have implemented our approach in a prototype tool called Broom. We have applied the tool to a selection of code fragments dealing with various kinds of lists, including very advanced implementations taken from the Linux kernel as well as the intrusive list library (for a reference, see our experimental section). Although the code is not large in the number of lines of code, it contains very advanced pointer operations, and, to the best of our knowledge, Broom is currently the only analyser that is capable of analysing many of the involved functions.\n# Related work\nIn the past (at least) 25 years there have appeared numerous approaches to automated shape analysis or, more generally, analysis of programs with unbounded dynamically-linked data structures. These approaches differ in the formalisms used for encoding sets of configurations of programs with such data structures, in their level of automation, classes of supported data structures, and/or properties of programs that are targeted by the analysis: see, e.g., [24, 33, 2, 36, 9, 38, 37, 20, 10, 3, 16, 21, 30]. Not many of the existing approaches offer a reasonably general support of low-level pointer operations (such as pointer arithmetic, address alignment, masking information on pointers, block operations, etc.). Some support of low-level pointer operations appears in multiple of these approaches, but it is often not much documented. In fact, such a support often appears in some ad hoc extension of the tool implementing the given approach only, without any description whatsoever. According to the best of our knowledge, the approach of [16], based on so-called symbolic memory graphs (SMGs), currently provides probably the most systematic and generic solution for the case of programs with low-level pointer operations and various kinds of linked lists (including advanced list implementations such as those used in the Linux kernel). Specialised approaches to certain classes of low-level programs, namely, memory allocators, then appear, e.g., in [5, 19]. In this work, we get inspired by some of the analysis capabilities of [16], but we aim at removing one of its main limitations\u2014namely, the fact that it cannot be applied to a fragment of code. Indeed, [16] expects the analysed program to be closed, i.e., the analysed functions must be complemented by a harness that initializes all the involved data structures, which severely limits applicability of the approach in practice (since programmers are often reluctant to write specialised analysis harnesses). Approaches allowing one to analyse open code, i.e., code fragments, with dynamic linked data structures are not frequent in the literature. Perhaps the best known of these works is the approach of bi-abduction based on separation logic with (possibly nested) list predicates proposed in [6, 7] and currently available in the Infer analyser [4].1 This approach is another of the approaches that inspired our work, and we will be referring to various technical details of that paper later on. However, despite Infer contains some support of pointer arithmetic, it is not very complete (as our experiments will show), and the approach presented in [6, 7] does not at all study low-level pointer operations of the form that we aim at in this paper. Moreover, it turns out that adding a support of such operations (e.g., dealing with blocks of memory of possibly variable size, splitting them to fields of variable size, merging such fields back and reinterpreting their contents differently, having pointers with variable offsets, supporting rich pointer arithmetic, etc.) requires rather non-trivial changes and extensions to the bi-abduction mechanisms used in [6, 7]. An approach of second-order bi-abduction based also on separation logic was proposed in [27] and several follow-up papers such as [11]. The authors consider recursive programs with pointers and propose a calculus for automatic derivation of sets of equations describing the behaviour of particular functions. A solution of such a set of equations leads to a set of contracts for the considered functions. The technique is in some sense quite general\u2014unlike [6, 7] and unlike our approach, it can even automatically learn recursive predicates describing the involved data structures, including trees, skip lists, etc. Moreover, the derivation of the equations is a cheap procedure, and no widening is needed, again unlike in [6, 7] and unlike in our approach. On the other hand, finding a solution of the generated equations is a hard problem, and the authors provide a simple heuristic designed for a specific shape of the equations only, which fails in various other cases. Finally, we mention the Gillian project, a language-independent framework based on separation logic for the development of compositional symbolic analysis tools, including tools for whole-program\n1 The approach [6, 7] mentions a generalisation to other classes of data structures, but\u2014to the best of our knowledge\u2014 this extension has not been implemented and evaluated, and so it is not clear how well it would work in practice.\nsymbolic execution, verification of annotated code, as well as bi-abduction [35, 34, 29, 28]. The works on Gillian concentrate on the generic framework it develops, and the published description of the supported bi-abductive analysis, perhaps most discussed in [34], is unfortunately not very detailed. In particular, it is not clear whether and how much the approach supports the low-level features of pointer manipulation that we are aiming at here (e.g., pointer arithmetic, bit-masking on addresses, etc.). According to the source code that we were able to find in the Gillian repository, the examples mentioned in the part of [34] devoted to bi-abduction do not use low-level pointer manipulation features such as pointer arithmetic. It is also mentioned in [34] that Gillian supports bi-abduction up to a predefined bound only, whereas we do not require such a bound. Further, in contrast to the present work, [34] assumes that the size of memory chunks being dynamically allocated is known, and the complex reasoning needed to resolve this issue is left for the future. We also note that there is a vast body of work on automated decision procedures for various fragments of separation logic and problems such as satisfiability and entailment\u2014see, e.g., [18, 22, 25, 26, 17]. However, it is not immediate how to apply these logics inside a program analysis tool. For example, the results on the cited separation logics cannot be directly applied to the (bi-)abduction problem, which is the central operation needed for a compositional program analysis. This is because the best (i.e., logically weakest) solution to the abduction problem \u03d5 \u02da r?s |\u00f9 \u03c8, which is a central problem for compositional program analyses, with \u02da being the separating conjunction, is given by the formula \u03d5\u00b4\u02da\u03c8, which makes use of the magic wand operator \u00b4\u02da, and the cited logics do not provide support for the magic wand. This is for principle reasons: it has been observed in the literature that magic wand operators are \u201cdifficult to eliminate\u201d [1]; further, it has been shown that adding only the singly-linked list-segment predicate to a propositional separation logic that includes the magic wand already leads to undecidability of the satisfiability problem [13]. A notable exception is the recent work [31] on a new semantics for separation logic, which enables decidability of a propositional separation logic that includes the magic wand and the singly-linked list-segment predicate (and also discusses applications to the abduction problem); however, the fragment considered in [31] is not expressive enough to cover the low-level features considered in this work such as, pointer arithmetic, memory blocks, etc., and, at present, it is unclear whether the decidability result can be extended to a richer logic. For the above reasons, we will in this paper not target a complete procedure for the (bi-)abduction problem, but rather, following [6, 7], develop approximate procedures and evaluate their usefulness in our case studies.\n# Main contributions of the paper\nThe paper proposes a new approach for automated bi-abductive analysis of programs and fragments of programs with pointers, different kinds of linked lists, and low-level memory operations. The approach is formalised, implemented in a prototype tool, and experimentally evaluated. In summary, we make the following contributions:\nA prototype implementation that supports bit-precise reasoning based on a reduction of (un-)satisfiability of separation logic to (un-)satisfiability of SMT over the bit-vectors. An experimental evaluation of the approach on a number of challenging programs.\n# An Illustration of the Approach on an Example\nBefore we start with a systematic description of our approach, we present its core ideas on an example. We will consider the code manipulating cyclic doubly-linked lists shown in Fig. 1.2 The example is inspired by the principle of intrusive lists (as used, e.g., in Linux kernel lists) where all list operations are defined on some simple list-linking structure that is then nested into user-defined structures. It is these user-defined structures that carry the data actually stored in the lists. The list manipulating functions, however, know nothing about these larger structures. However, the fact that contracts (summaries) derived for functions dealing with the small linking structures are later to be applied on the larger, user-defined structures is already problematic for some existing analyses. When providing an introduction to the approach, we will try to informally explain the involved notions, yet, due to the complexity of the issues, some prior knowledge of separation logic with inductive list predicates, e.g., [2], and ideally also bi-abduction analysis [6, 7] is helpful. In the code of our illustrative example, the function init_dll creates an initial cyclic doublylinked list consisting of a single node. The function insert_after can then insert a new element into the list after its item pointed by l. Let us note that while the code of the example in Fig. 1 may seem to not use pointer arithmetic, the code in fact uses pointer arithmetic on the level of the intermediate code we analyse. Indeed, each expression x->field is translated to *(x+offsetof(field)). It is of course true that once all the types and fields are known and fixed, one can avoid dealing with pointer arithmetic in this case. On the other hand, the fact that we systematically handle it through pointer arithmetic allows us to smoothly handle even the cases when the types and offsets stop being known and/or constant (upon which approaches based on dealing with field names fail). As indicated already in the introduction, we analyse the given code fragment according to its call tree, starting from the leaves (assuming there is no recursion). Each function is analysed just once, without any call context. If successful, the analysis derives a set of contracts for the given function where each contract is a pair pP, Qq consisting of a (conjunctive) pre-condition and (a possibly disjunctive) post-condition. In our introductory example, we will restrict ourselves to the simplest case, namely, having a single, purely conjunctive contract. In the contracts, both the pre- and post-condition are expressed as SL formulae. The analysis is compositional in that contracts derived for some functions are then used when analysing functions higher up in the call hierarchy (moreover, we will view even particular pointer manipulating statements as special atomic functions and describe them by pre-defined contracts). As indicated already in the introduction, we analyse the given code fragment according to its call tree, starting from the leaves (assuming there is no recursion). Each function is analysed just once, without any call context. If successful, the analysis derives a set of contracts for the given function where each contract is a pair pP, Qq consisting of a (conjunctive) pre-condition and (a possibly disjunctive) post-condition. In our introductory example, we will restrict ourselves to the simplest case, namely, having a single, purely conjunctive contract. In the contracts, both the pre- and\n# Low-Level Bi-Abduction\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/ede2/ede2ff00-765d-47cf-95f7-a46932542d76.png\" style=\"width: 50%;\"></div>\npost-condition are expressed as SL formulae. The analysis is compositional in that contracts derived for some functions are then used when analysing functions higher up in the call hierarchy (moreover, we will view even particular pointer manipulating statements as special atomic functions and describe them by pre-defined contracts). We begin the illustration of our analysis by analysing the init_dll function. We start the analysis by annotating the first line by the pair px \u201c X, x \u201c Xq. In this pair, the first component is the so-far derived pre-condition of the function, and the second component is the current symbolic state of the function under analysis. Here, the variable X records the value of the program variable x at the beginning of the function. While x will be changing in the function, X will never change, and we will be able to gradually generate constraints on its value to express what must hold for x at the entry of the function. After symbolically executing the statement x->next = x, we derive that the address X must correspond to some allocated memory, containing some unknown value L1. This gives us the precondition X \u00de\u00d1 L1 that is an SL formula stating exactly the fact that X is allocated and stores the value L1. The symbolic state is then advanced to say that X is allocated and stores the value X, i.e., it points to itself, which is encoded as X \u00de\u00d1 X in SL. After the subsequent statement x->prev = x, assuming that we work with 64 bit (i.e., 8 bytes) wide addresses, we add to the precondition the fact that the memory address X ` 8 is allocated as well. Moreover, the formula bpXq \u201c bpX ` 8q says that X and X ` 8 belong to the same memory block, i.e., they were, e.g., allocated using one malloc statement (in fact, we use bpXq to denote the\u2014so-far unknown\u2014base address of the block). The symbolic state is updated by the fact that the value at the address X ` 8 is also equal to X, i.e., X ` 8 \u00de\u00d1 X. Since there are no further statements in the function, there is no branching, no loops, and all the statements are deterministic, the final contract for the function is unique and consists of the final pre-condition P \u201d X \u00de\u00d1 L1 \u02da X ` 8 \u00de\u00d1 L2 \u02da bpXq \u201c bpX ` 8q \u02da x \u201c X and the post-condition Q \u201d X \u00de\u00d1 X \u02da X ` 8 \u00de\u00d1 X \u02da bpXq \u201c bpX ` 8q \u02da x \u201c X obtained from the final symbolic state. Here, we use \u201c\u02da\u201d to denote a per-field separating conjunction, which, intuitively, means that while the addresses X and X ` 8, which are allocated by the formulae X \u00de\u00d1 L1 and X ` 8 \u00de\u00d1 L2, may\u2014though need not\u2014belong to a single memory block, the values stored at these addresses within the block do not overlap.3 The same principles are then used for the computation of the contracts for the insert_after and main functions. Here, let us just highlight a situation that happens, e.g., upon the j->next = n statement of insert_after. Notice that, in its case, the so-far computed precondition P must be extended by the new requirement J \u00de\u00d1 B1, stating that J must be allocated, and Q is then extended by the fact J \u00de\u00d1 N, which is the effect of executing the given statement. At the same time, however, the rest of the previously computed symbolic state of the program Q stays untouched (in general, only some part may be preserved). Given the current symbolic state Q and a statement, the problem of deriving which precondition is missing and which part of the state will remain untouched is denoted as the bi-abduction problem, and a procedure looking for its solution is a bi-abduction procedure. The computed missing part of the pre-condition is called the anti-frame, and the computed part of the current symbolic state not modified by the statement being executed is called the frame. When analysing the main function, one does already need not re-analyse the init_dll and insert_after functions\u2014instead, one simply uses their contracts. For simplicity, we assume here that malloc always succeeds, and hence even main is deterministic. After the execution of malloc, we use the special predicate x \u00de\u00d1 Jr24s to express that a sequence of 24 bytes of undefined\ncontents was allocated. We allow such blocks (as well as all other kinds of blocks that arise during the analysis) be split to smaller parts whenever this is needed for applying a contract of some function (or statement). That happens, e.g., on lines b and d of the main function where the block X \u00de\u00d1 Jr24s created by malloc is split to 3 fields as described by X \u00de\u00d1 Jr8s \u02da X ` 8 \u00de\u00d1 Jr8s \u02da X ` 16 \u00de\u00d1 Jr8s. The last two of the fields then match the precondition of init_dll, and the first one becomes a frame (untouched by the function). Without now going into further details, we note that analysing more complex functions requires one to solve multiple more problems. For example, if there appears some non-determinism, one needs to start working with contracts with disjunctive post-conditions and even with sets of such contracts. If the code contains loops, one needs to prevent the analysis from diverging while generating more and more points-to predicates. For that, one can use widening in the form of a list abstraction. The resulting over-approximation may then, however, render some generated pre-/post-condition pairs unsound, leading to a need to run another phase of the analysis that will start from the computed pre-conditions and check, without using abduction any more, what post-condition the code can really guarantee. We will discuss all these issues in detail in the following. However, before proceeding, let us stress how significantly the above-mentioned use of the per-field separation distinguishes our approach from its predecessor bi-abduction analysis [6, 7]. That analysis would use whole-block predicates of the form X \u00de\u00d1 dllpnext : A, prev : Bq to describe instances of struct dll, while we use the formula X \u00de\u00d1 A \u02da X ` 8 \u00de\u00d1 B \u02da bpXq \u201c bpX ` 8q. The per-field separating conjunction allows us to (1) express partial information about a block and (2) infer a precondition where two (or more) fields can be in the same block as well as in different blocks. Point 1 helps us to generate contracts of functions where we do not know the exact sizes of the allocated block\u2014e.g., init_dll does not require the pointer x to point to an instance of struct dll, it can be, e.g., used on larger structures, such as, e.g., struct emb_dll, that embed the original structure. Point 2 is used in the contract of insert_after where the formula L \u00de\u00d1 N \u02da N ` 8 \u00de\u00d1 B3 describes a memory where it may be that L \u201c N as well as L \u2030 N. The contract for insert_after can then be applied on a circular doubly-linked list consisting of a single item (L \u201c N) as well on lists consisting of more items (L \u2030 N)\u2014see Fig. 2 for an illustration.\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/4d6b/4d6b1e1c-5dc4-4f4e-b420-0a31e4ec0749.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/820d/820d444f-06dc-4dfd-8328-53a0da1344c5.png\" style=\"width: 50%;\"></div>\nNote that when one uses the whole-block predicate, the precondition of insert_after in the form L \u00de\u00d1 dllpnext : N, prev : _q\u02daN \u00de\u00d1 dllpnext : _, prev : B3q\u02daJ \u00de\u00d1 dllpnext : B1, prev : B2q requires L \u2030 N, and hence it is not covering the two above mentioned cases. One can of course sacrifice performance of the analysis and generate multiple contracts by modifying the abduction rules\u2014e.g., one can non-deterministically introduce an alias L \u201c N before inferring the anti-frame on line v of main to get the pre-condition L \u00de\u00d1 dllpnext : L, prev : _q \u02da L \u201c N. Introducing such non-determinism is, however, costly. That is why, as we will see in our experiments, it is not done in tools such as Infer, which can then cause that such tools will miss some function contracts (or generate incomplete contracts that will not be applicable in some common cases: such as insertion into a list of length 1). An additional Example is provided in Appendix B, where pointer arithmetic and bit-masking are directly visible in the C-code.\n# Memory Model\nIn the following, we introduce the memory model that we use in this paper. Values are sequences of bytes, i.e., Val \u201c Byte`, where bytes are 8-bit words. Sequences of bytes can be interpreted as numbers\u2014either signed or unsigned, which we leave as a part of the operations to be applied on the sequences (including conversion operations). We designate a subset of the values Loc \u201c ByteN \u010e Val as locations where N \u011b 1 is the byte-width of words of a given architecture and where byte sequences to be interpreted as locations are always understood as unsigned. The null pointer is represented by 0 P Loc in our memory model. We will use so-called stack-block-memory triplets (SBM triplets for short) as configurations of our memory model in order to define the operational semantics of programs (and also to define the semantics of our separation logic later on): Stack. We assume some set of variables Var where each variable x P Var has some fixed positive size, denoted as sizepxq. Then, Stack is the set of total functions Var \u00d1 Val such that each variable is mapped to a byte sequence whose length is according to the size of the variable, i.e., for each stack S P Stack and variable x P Var, we have Spxq P Bytesizepxq. Memory. Mem is the set of partial functions Loc \u00e1 Byte that define the contents of allocated memory locations. Blocks. We use Interval \u201c t rl, uq | l \u0103 u where l, u P Locu to denote intervals of subsequent memory locations where we include the lower bound and exclude the upper bound. Intuitively, an interval rl, uq P Interval will denote which locations were allocated at the same time (and must thus also be deallocated together, can be subtracted using pointer subtraction, etc.). Block \u201c t rl, uq P Interval | l \u2030 0u are intervals whose lower bound is not 0 (recall that null is represented by 0 P Loc in our memory model). Blocks \u010e p2finqBlock is the set of all finite sets of non-overlapping blocks, i.e., for all B P Blocks and for all rl1, u1q, rl2, u2q P B such that either l1 \u2030 l2 or u1 \u2030 u2, we have that either u1 \u010f l2 or u2 \u010f l1. Configurations. Config consists of all triplets pS, B, Mq P Stack \u02c6 Blocks \u02c6 Mem such that the set of allocated blocks and the locations whose contents is defined are linked as follows:\nWe introduce functions bB, eB : Loc \u00d1 Loc, parameterized by some set of blocks B P Blocks, which return the base or end address, respectively, of the block to which a given location belongs, i.e., given some \u2113P Loc, we set bBp\u2113q \u201c l in case there is some rl, uq P B with \u2113P rl, uq, and bBp\u2113q \u201c 0, otherwise. Likewise for eBp\u2113q. Axioms. For later use, we note that, building on the above notation, we can express the requirements for locations to be within their associated block and for blocks to be non-overlapping in the form of the following two axioms:\n@\u2113, \u21131. p0 \u0103 bBp\u2113q \u0103 eBp\u21131q \u010f eBp\u2113q _ 0 \u0103 bBp\u21131q \u0103 eBp\u2113q \u010f eBp\u21131qq \u00d1\n@\u2113, \u21131. p0 \u0103 bBp\u2113q \u0103 eBp\u21131q \u010f eBp\u2113q _ 0 \u0103 bBp\u21131q \u0103 eBp\u2113q \u010f eBp\u21131qq \u00d1 bBp\u2113q \u201c bBp\u21131q ^\npq \u010fpqq \u00d1 bBp\u2113q \u201c bBp\u21131q ^ eBp\u2113q \u201c eBp\u21131q\nNotation. Given a (partial) function f, fra \u00e3\u00d1 bs denotes the (partial) function identical to f u to fra \u00e3\u00d1 bspaq \u201c b. Moreover, fra \u00e3\u00d1 Ks denotes the (partial) function identical to f up to bein undefined for a.\n# 4 A Low-level Language and Its Operational Semantics\nWe now state a simple low-level language together with its operational semantics. The language is close to common intermediate languages into which programs in C are compiled by compilers such as gcc or clang. We assume that a type checker ensures that variables of the right sizes are used, guaranteeing, in particular, that the left-hand side (LHS) and right-hand side (RHS) of an assignment are of the same size or that the dereference operator is only applied to locations. We do not include the operators of item access (. and ->) nor indexing ([]) into our language as their usage can be compiled to using pointers, pointer arithmetic, and the dereference operator (*) as indeed commonly done by compilers. Likewise, we do not include the address-of operator (&) whose usage can be replaced by storing all objects whose address should be derived via & into dynamically allocated memory, followed by using pointers to such memory, as also done automatically by some compilers. Further, we assume the sizeof and offsetof operators be resolved and transformed to constants. We now present the statements of our low-level language together with their operational semantics. The semantics is defined over configurations, which we introduced in the previous section. The semantics maintains the following invariant:\nWe start with rules describing various assignment statements possibly combined with pointe dereferences either on the LHS or RHS. In the rules (and further on), we use Mr\u2113, \u21131q to denote th byte sequence Mp\u2113qMp\u2113` 1q \u00a8 \u00a8 \u00a8 Mp\u21131 \u00b4 1q:\npS, B, Mq x:\u201ck \u00dd\u00dd\u00dd\u00d1 pSrx \u00e3\u00d1 ks, B, Mq for some value k P Val pS, B, Mq x:\u201cy \u00dd\u00dd\u00dd\u00d1 pSrx \u00e3\u00d1 Spyqs, B, Mq pS, B, Mq x:\u201c\u02day \u00dd\u00dd\u00dd\u00dd\u00d1 if bBpSpyqq \u201c 0 or Spyq ` sizepxq \u0105 eBpSpyqq,\nNote that, in the case of x :\u201c \u02day, one needs to read sizepxq bytes from the adress Spyq. This i impossible if the condition Spyq ` sizepxq \u0105 eBpSpyqq holds.\npS, B, Mq \u02dax:\u201cy \u00dd\u00dd\u00dd\u00dd\u00d1 if bBpSpxqq \u201c 0 or Spxq ` sizepyq \u0105 eBpSpxqq, then error else pS, B, MrrSpxq, Spxq ` sizepyqq \u00e3\u00d1 Spyqsq\nWe continue by memory allocation. We treat 0-sized allocations as an error.5 For non-zero-sized allocations, the allocation can always fail and return null, otherwise the successfully allocated memory block is initialized with some arbitrary value6:\npS, B, Mq x\u201cmallocpzq \u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00d1 if Spzq \u201c 0 then error else either pSrx \u00e3\u00d1 nulls, B, Mq or pSrx \u00e3\u00d1 \u2113s, B Y tr\u2113, \u2113` Spzqqu, Mrr\u2113, \u2113` Spzqq \u00e3\u00d1 ksq for some k P ByteSpzq and \u2113\u0105 0 such that \u2113` Spzq \u010f 28N and r\u2113, \u2113` Spzqq does not overlap with any rl, uq P B\nThe calloc function, which nullifies the allocated block, can be defined analogically to malloc, by just changing Mrr\u2113, \u2113`Spzqq \u00e3\u00d1 ks to Mrr\u2113, \u2113`Spzqq \u00e3\u00d1 0Spzqs. The realloc function, which shrinks or enlarges a block, possibly moving it to a different memory location, can be reduced to a sequence of other statements, and so we do not introduce it explicitly for brevity. The deallocation of memory is modelled by the following rule:7\nq \u00dd\u00dd\u00dd\u00dd\u00dd\u00d1pq \u2030ppqq else pS, BztrSpxq, eBpSpxqqqu, MrrSpxq, eBpSpxqqq \u00e3\u00d1 Ksq\nWe now state rules for (unary and binary) operations excluding the operation of adding an offset to a pointer and pointer subtraction, which will be handled separately. We assume that typing will ensure the right sizes of the operands and the variables to which the results are assigned. For instance, for arithmetic operations, we expect all operands and result variables to have the same type. Unary operators can be used to model type-casting that lifts variables to the required size. Finally, note also that we do not exclude division by zero in order not to complicate the rules in aspects that are not specific for our work.\npS, B, Mq x\u201cy bop z \u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00d1 pSrx \u00e3\u00d1 Spyq bop Spzqs, B, Mq pS, B, Mq x\u201cuop y \u00dd\u00dd\u00dd\u00dd\u00dd\u00d1 pSrx \u00e3\u00d1 uop Spyqs, B, Mq\nThe rule for adding a (possibly negative) offset to a pointer requires its pointer argument to be defined and, in accordance with the C standard, the result be within the appropriate memory block plus one byte (i.e., it may point just behind the end of the block).8\npS, B, Mq x\u201cy ptrplus z \u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00d1 if Spyq \u201c 0 or Spyq ` Spzq \u0103 bBpSpyqq or Spyq ` Spzq \u0105 eBpSpyqq, then error else pSrx \u00e3\u00d1 Spyq ` Spzqs, B, Mq\nThe rule for the pointer subtraction is special in that it requires its pointer operands to be defined to have the same base, and to point inside an allocated block or just behind its end (note the usage o the interval closed at both ends in the rule).\npS, B, Mq x\u201cy ptrsub z \u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00d1 if Spyq \u201c 0 or Spzq R rbBpSpyqq, eBpSpyqqs, then error else pSrx \u00e3\u00d1 Spyq \u00b4 Spzqs, B, Mq\nFurther, we state the semantics of the memcpy statement that copies z bytes from an address y to an address x and that assumes dealing with non-overlapping source/target blocks. The effect of the memmove statement, which can handle even overlapping blocks, can be simulated by copying the source block to a fresh block and then back, and so we skip it for brevity. For brevity, we also skip the (easy to add) memset statement, which sets each byte of some block to a given value.\npS, B, Mq memcpypx,y,zq \u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00d1 if bBpSpxqq \u201c 0 or bBpSpyqq \u201c 0 or Spxq ` Spzq \u0105 eBpSpxqq or Spyq ` Spzq \u0105 eBpSpyqq, or Spxq ` Spzq \u0105 Spyq or Spyq ` Spzq \u0105 Spxq, then error else pS, B, MrrSpxq, Spxq ` Spzqq \u00e3\u00d1 MrSpyq, Spyq ` Spzqq\npS, B, Mq memcpypx,y,zq \u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00d1 if bBpSpxqq \u201c 0 or bBpSpyqq \u201c 0 or Spxq ` Spzq \u0105 eBpSpxqq or Spyq ` Spzq \u0105 eBpSpyqq, or Spxq ` Spzq \u0105 Spyq or Spyq ` Spzq \u0105 Spxq, then error else pS, B, MrrSpxq, Spxq ` Spzqq \u00e3\u00d1\nWe also introduce the assert statement that is similar to the assume statement, but it checks at runtime whether the specified condition holds, and it fails if this is not the case:\npS, B, Mq assertpx\u2019yq \u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00d1 if Spxq \u2019 Spyq then pS, B, Mq else error We structure our programs into functions. We assume a control flow graph pV, E, entry, exitq for each function fpx1, . . . , xnq, where V is a set of nodes, there are dedicated nodes entry, exit P V , and E \u010e V \u02c6 V is a set of edges where each edge is labelled by a basic statement or a function call. We model branching and looping as usual, i.e., by having multiple outgoing control flow edges labelled by an assume statement with appropriate conditions. For simplicity, we consider functions without a return value, not referring to global variables, having parameters passed by reference only, with the names of the parameters unique to each function, and not having local variables.9 We consider non-recursive functions only.10 Finally, when a function is called, no variable can be used as an argument twice. In particular, let fpx1, . . . , xnq, n \u0105 0, be a function whose body Bf uses the variables x1, . . . , xn only. Let fpa1, . . . , anq be a call of f where the arguments ai are pairwise different variables. We will now define the semantics of this function call with regard to some configuration pS, B, Mq. The definition will, however, be only partial due to the possible non-termination of fpa1, . . . , anq. Let Sf be the stack defined by Sfpxiq \u201c Spaiq for all 1 \u010f i \u010f n. Then, we consider the execution of Bf wrt the initial configuration determined by Sf as well as the blocks B and the memory M at the call of f: Let us assume that pSf, B, Mq Bf \u00dd\u00dd\u00d1 pS1 f, B1, M 1q where Bf \u00dd\u00dd\u00d1 denotes an execution from the entry to the exit of f (again this definition is only partial as the execution of Bf does not need to terminate). If Bf terminates wrt configuration pSf, B, Mq, we set pS, B, Mq fpa1,...,anq \u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00dd\u00d1 pS1, B1, M 1q where S1 is defined by S1paiq \u201c S1 fpxiq for all 1 \u010f i \u010f n, and S1pyq \u201c Spyq for all y P Varzta1, . . . , anu.\n# 5 Separation Logic\nWe now introduce a separation logic that supports reasoning about low-level memory models as introduced earlier. Our separation logic (SL) has the following syntax:\n# We now introduce a separation logic that supports reasoning about low-level memory models as introduced earlier. Our separation logic (SL) has the following syntax:\n\u03d5 ::\u201c \u03b51 \u00de\u00d1 \u03b52 | \u03b51 \u00de\u00d1 kr\u03b52s | \u03b51 \u00de\u00d1 Jr\u03b52s | \u03d51 \u02da \u03d52 | \u03d51 _ \u03d52 | ls\u039bpx,yqp\u03b51, \u03b52q | dls\u039bpx,y,zqp\u03b51, \u03b52, \u03b51 1, \u03b51 2q | emp | true | \u03b51 \u2019 \u03b52 | Dx.\u03d5 \u2019 ::\u201c \u201c|\u2030|\u010f|\u0103|\u011b|\u0105 \u03b5 ::\u201c k | x | bp\u03b5q | ep\u03b5q | uop \u03b5 | \u03b51 bop \u03b52\nVariables and Values. Our SL formulae are stated over the same set of variables Var and values Val that we introduced in the definition of our memory model. In particular, the variables x, y, z and the values k of our SL formulae are drawn from Var and Val, respectively. Size. Variables, values, operators, and expressions in our logic are typed by their size. We will only work with formulae where the variables and values respect the sizes expected by the involved operations and predicates. For every expression \u03b5, we denote by sizep\u03b5q the size of the value to which this expression may evaluate. We remark on the choice of working with fixed sizes: We intentionally do not permit variables of variable size because (1) such variables are typically not supported by low-level languages and (2) variables of variable size allow one to model strings, which would make our language vastly more powerful (allowing one to model all kinds of string operations)11. Points-To Predicates. The points-to predicate \u03b51 \u00de\u00d1 \u03b52 denotes that the byte sequence \u03b52 is stored at the memory location \u03b51. Due to we are working with expressions of fixed size, every model of \u03b51 \u00de\u00d1 \u03b52 must allocate exactly sizep\u03b52q bytes. In addition, we introduce two restricted cases of points-to predicates where the RHS is of parametric size: namely, \u03b51 \u00de\u00d1 kr\u03b52s and \u03b51 \u00de\u00d1 Jr\u03b52s that allow us to say that \u03b51 points to an array of \u03b52 bytes that either all have the same constant value k or have any value, respectively. These predicates allow us to, e.g., express that some block of memory is nullified, which is often crucial to know when analysing advanced implementations of dynamic data structures [16]. We lift the notion of size to the RHS of these points-to predicates as follows: sizepkrysq \u201c sizepJrysq \u201c y. In \u03b51 \u00de\u00d1 kr\u03b52s, we require k to be a single byte, i.e., sizepkq \u201c 1. Notation. Given a formula \u03d5, we write varp\u03d5q to denote the free variables of \u03d5 (as usual a variable is free if it does appear within an existential quantification). Further, given an expression \u03b5, we write varp\u03b5q for all variables appearing in \u03b5. Terminology. We call formulae that do not contain the disjunction operator (_) symbolic heaps. We will mostly work with symbolic heaps in this paper. Disjunctions of symbolic heaps will be only used on the RHS of (some) contracts. We call formulae that do not contain existential quantification (D) quantifier-free. Our SL contains the relational predicates \u03b51 \u2019 \u03b52, which include equality and disequality; these predicates are traditionally called pure in the separation logic literature. We follow this terminology and call any separating conjunction of such predicates a pure formula. List-Segment Predicates. List segments in our SL are parameterized by a segment predicate \u039bpx, yq or \u039bpx, y, zq for singly-linked or doubly-linked lists, respectively; see Fig. 3 for an illustration of the semantics of ls\u039bpx,yqp\u03b51, \u03b52q and dls\u039bpx,y,zqp\u03b51, \u03b52, \u03b51 1, \u03b51 2q for \u039bpx, yq \u201d x \u00de\u00d1 y and dls\u039bpx,y,zq \u201d x \u00de\u00d1 z \u02da x ` 8 \u00de\u00d1 y. We note that our list-segment predicates only have two or three free variables, respectively, which prevents the logic from, e.g., describing non-global heap objects shared by list elements. However, more parameters could be introduced in a similar fashion to other works [2]. We have not done so here since it would complicate the notation, and we take this issue as orthogonal to the techniques we propose. Binary and Unary Operators. uop and bop denote some arbitrary set of binary and unary operators, respectively. We assume this set to include at least the usual operators (`, \u00b4, \u02da, &, |, .. . ) available in low-level languages as well as a special substring operator \u00a8r\u00a8, \u00a8q on byte sequences where kri, jq for some k \u201c b0 \u00a8 \u00a8 \u00a8 bl\u00b41 P Bytel and 0 \u010f i \u010f j \u010f l denotes the byte sequence bi \u00a8 \u00a8 \u00a8 bj\u00b41. Since we work with variables of fixed size, we basically assume a version of each uop and bop for every possible operand size. We further remark that unary operators uop can be used for modelling the casting to different sizes.\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/fc7e/fc7e78f6-0b0e-4443-ad5d-ac6757ba96f9.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Figure 3 An illustration of the meaning of the ls\u039bpx,yqp\u03b51, \u03b52q and dls\u039bpx,y,zqp\u03b51, \u03b52, \u03b51 1, \u03b51 2q formulae.</div>\nSemantics. We now define the semantics of our SL over SBM triplets pS, B, Mq P Config: pS, B, Mq |\u00f9 \u03b51 \u00de\u00d1 \u03b52 iff dompMq \u201c r\ufffd\u03b51\ufffdS,B, \ufffd\u03b51\ufffdS,B ` sizep\u03b52qq and Mr\ufffd\u03b51\ufffdS,B, \ufffd\u03b51\ufffdS,B ` sizep\u03b52qq \u201c \ufffd\u03b52\ufffdS,B where \ufffdk\ufffdS,B \u201c k, \ufffdx\ufffdS,B \u201c Spxq, \ufffdbp\u03b5q\ufffdS,B \u201c bBp\ufffd\u03b5\ufffdS,Bq, \ufffdep\u03b5q\ufffdS,B \u201c eBp\ufffd\u03b5\ufffdS,Bq, \ufffduop \u03b5\ufffdS,B \u201c uopp\ufffd\u03b5\ufffdS,Bq, and \ufffd\u03b51 bop \u03b52\ufffdS,B \u201c \ufffd\u03b51\ufffdS,B bop \ufffd\u03b52\ufffdS,B\npS, B, Mq |\u00f9 \u03b51 \u00de\u00d1 kr\u03b52s iff dompMq \u201c r\ufffd\u03b51\ufffdS,B, \ufffd\u03b51\ufffdS,B ` \ufffd\u03b52\ufffdS,Bq and Mr\ufffd\u03b51\ufffdS,B ` is \u201c k for all 0 \u010f i \u0103 \ufffd\u03b52\ufffdS,B\n\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd We remark on the difference between the three points-to predicates: the predicate \u03b51 \u00de\u00d1 \u03b52 fixes the exact sequence of bytes \u03b52 that is stored from location \u03b51 onwards, and the number of bytes is known (the size of \u03b52); the predicate \u03b51 \u00de\u00d1 kr\u03b52s states that there are \u03b52 number of bytes stored from location \u03b51 onwards (note that the number of bytes \u03b52 is symbolic), and each of these bytes equals k; and the predicate \u03b51 \u00de\u00d1 Jr\u03b52s works in the same way except that the bytes stored are not fixed. pS, B, Mq |\u00f9 \u03d51 \u02da \u03d52 iff there are some M1, M2 with M \u201c M1 Z M2, pS, B, Miq |\u00f9 \u03d5i pS, B, Mq |\u00f9 \u03d51 _ \u03d52 iff pS, B, Mq |\u00f9 \u03d51 or pS, B, Mq |\u00f9 \u03d52 pS, B, Mq |\u00f9 emp iff dompMq \u201c H pS, B, Mq |\u00f9 true always holds pS, B, Mq |\u00f9 \u03b51 \u2019 \u03b52 iff dompMq \u201c H and \ufffd\u03b51\ufffdS,B \u2019 \ufffd\u03b52\ufffdS,B\n \ufffd\ufffd \ufffd\ufffd We point out that pure formulae constrain the heap to be empty. This is typically not required by separation logics that support classical (non-separating) conjunction at least on pure sub-formulae However, we exclude the classical conjunction in order to simplify the presentation and hence need to constrain the heap of pure formulae to be empty.\npS, B, Mq |\u00f9 ls\u039bpx,yqp\u03b51, \u03b52q iff pS, B, Mq |\u00f9 \u03b51 \u201c \u03b52 or pS, B, Mq |\u00f9 \u03b51 \u2030 \u03b52 \u02da true and there is some \u2113P Loc and a fresh variable u P Var s.t. pSru \u00e3\u00d1 \u2113s, B, Mq |\u00f9 \u039bp\u03b51, uq \u02da ls\u039bpx,yqpu, \u03b52q\npS, B, Mq |\u00f9 dls\u039bpx,y,zqp\u03b51, \u03b52, \u03b51 1, \u03b51 2q iff pS, B, Mq |\u00f9 \u03b51 \u201c \u03b51 2 \u02da \u03b52 \u201c \u03b51 1 or pS, B, Mq |\u00f9 \u03b51 \u2030 \u03b51 2 \u02da \u03b52 \u2030 \u03b51 1 \u02da true and there is some \u2113P Loc and a fresh variable u P Var such that pSru \u00e3\u00d1 \u2113s, B, Mq |\u00f9 \u039bp\u03b51, u, \u03b52q \u02da dls\u039bpx,y,zqpu, \u03b51, \u03b51 1, \u03b51 2\nSatisfiability and Entailment. We say that an SL formula \u03d5 is satisfiable iff there is a model pS, B, Mq such that pS, B, Mq |\u00f9 \u03d5. We say that an SL formula \u03d51 entails an SL formula \u03d52, denoted \u03d51 |\u00f9 \u03d52, iff we have that pS, B, Mq |\u00f9 \u03d52 for every model pS, B, Mq such that pS, B, Mq |\u00f9 \u03d51. Restrictions on the Segment Predicates. From now on, we put further restrictions on the segment predicates \u039bpx, yq and \u039bpx, y, zq: (1) \u039b needs to be of the shape Dx1, . . . , xk.\u03d5 for some quantifier-free symbolic heap \u03d5. Intuitively, this condition is required since quantifier-free symbolic heaps are the formulae on which the symbolic execution described in Section 6 is based on and the existential quantification allows to hide some nested data. (2) \u039b needs to be block-closed in the sense defined below. Block-closedness. A formula \u03d5 is block-closed iff, for all pS, B, Mq |\u00f9 \u03d5 and \u2113P dompMq, we have that rbp\u2113q, ep\u2113qq \u010e dompMq. Intuitively, block-closedness ensures that all points-to assertions in a formula add up to whole blocks. We require block-closedness in order to ensure that list-segments correspond to our intuition and connect different memory blocks (i.e., we exclude models where multiple or all nodes of list-segments belong to the same block). Technically, the requirement of block-closedness makes it easier to formulate rules for materialisation of list-segment nodes in the abduction procedure and for entailment checking. We leave lifting the restriction of block-closedness for future work. A sufficient condition for block-closedness, which is easy to check, is that all points-to assertions in \u03d5 can be organized in groups \u03b5i \u00de\u00d1 \u03a5i, for 1 \u010f i \u010f n, where \u03a5 represents either y, krys, or Jrys, such that \u03b5i \u201c \u03b5i\u00b41 ` sizep\u03a5iq for all 1 \u0103 i \u010f n, and \u03d5 implies that ep\u03b51q \u00b4 bp\u03b51q \u201c \u0159 i\u201c1..n sizep\u03a5iq.\n#   Contracts of Functions and Their Generation\nOur analysis is based on generating contracts of functions along the call tree, starting from its leaves. The contracts summarize the semantics of the functions under analysis. (We may also compute multiple contracts for the same function where each contract provides a valid summary of the function; the contracts might, however, differ in the preconditions under which they apply.) We introduce our notion of contracts in Subsection 6.1. We note that basic statements of our core language can be viewed as special built-in functions. Hence, we then introduce contracts for the basic statements in Subsection 6.2. These serve as the starting point of our analysis: Using the contracts of the built-in functions, we derive contracts for any function built of them as described in Subsection 6.3.\n# 6.1 Contracts of Functions\nWe assume a set of variables Var \u201c PVar Z LVar that is partitioned into two disjoint infinite set of program variables PVar and logical variables LVar (also called ghost variables). For functions fpx1, . . . , xnq with parameters xi, we always require x1, . . . , xn P PVar (also recall that we assume that x1, . . . , xn are the only variables occurring in the body of f). To summarize the semantics of a function fpx1, . . . , xnq, we use (sets of) contracts of the form tPufpx1, . . . , xnqtQu where\nfor some expressions \u03b5i with varp\u03b5iq \u010e LVar, and UQ \u201c pvarpQfree \u02da Qeqq X LVarqzvarpPq. Note that every disjunct of the post-condition Q describes the heap by a formula over the logical variables (the formula Qfree) and fixes the values of the program variables in terms of expressions over the logical variables (the formula Qeq) where all logical variables that do not appear in the pre-condition P are existentially quantified (on the other hand, those logical variables that appear in the pre-condition may be implicitly considered as universally quantified). We call a contract conjunctive if the post-condition Q \u201d Q1 _ \u00a8 \u00a8 \u00a8 _ Ql consists of a single disjunct (i.e., l \u201c 1), and disjunctive otherwise.\n# Soundness of contracts\nWe will now state what it means for a contract to be sound. As usual we stipulate that configurations satisfying the pre-condition lead to configurations satisfying the post-condition. In addition, we also require that we can always add a frame to the pre-/post-condition, i.e., a formula describing a part of the heap untouched by the function12. Here, a frame F is any symbolic heap with varpFq \u010e LVar. A contract tPufpx1, . . . , xnqtQu is called sound iff, for all frames F, all triples pS, B, Mq such that pS, B, Mq |\u00f9 F \u02da P, and all executions of fpx1, . . . , xnq that start from pS, B, Mq and end in some configuration pS1, B1, M 1q13, it holds that pS1, B1, M 1q |\u00f9 F \u02da Q.\n# 6.2 Contracts for Basic Statements\nWe give below contracts for the basic statements of our programming language stated as functio (basic statements may be viewed as special built-in functions). For simplicity (and w.l.o.g.), we assum that it never happens that the same variable appears both at the LHS and RHS of an assignment Recall that emp is implicit in all otherwise pure constraints (and so we do not need to repeat it): Function assignpx, yq with the body x :\u201c y: ty \u201c Y u assignpx, yq tx \u201c Y \u02da y \u201c Y u. Function constkpxq with the body x :\u201c k: tempu constkpxq tx \u201c ku. Function loadpx, yq with the body x :\u201c \u02day: ty \u201c Y \u02da Y \u00de\u00d1 zu loadpx, yq tx \u201c z \u02da y \u201c Y \u02da Y \u00de\u00d1 zu with Qfree \u201d Y \u00de\u00d1 z and Qeq \u201d x \u201c z \u02da y \u201c Y . Function storepx, yq with the body \u02dax :\u201c y: tx \u201c X \u02da y \u201c Y \u02da X \u00de\u00d1 zu storepx, yq tx \u201c X \u02da y \u201c Y \u02da X \u00de\u00d1 Y u with Qfree \u201d X \u00de\u00d1 Y and Qeq \u201d x \u201c X \u02da y \u201c Y . Function mallocpx, yq that either succeeds or fails to allocate memory through x :\u201c mallocp ty \u201c Y u mallocpx, yq tx \u201c null \u02da y \u201c Y _ Du. x \u201c u \u02da \u03bdpu, Y q \u02da y \u201c Y u\nwith Qfree \u201d X \u00de\u00d1 Y and Qeq \u201d x \u201c X \u02da y \u201c Y . Function mallocpx, yq that either succeeds or fails to allocate memory through x :\u201c mallocpyq: ty \u201c Y u mallocpx, yq tx \u201c null \u02da y \u201c Y _ Du. x \u201c u \u02da \u03bdpu, Y q \u02da y \u201c Y u\nwhere \u03bdpu, Y q \u201c u \u00de\u00d1 JrY s \u02da bpuq \u201c u \u02da epuq \u201c u ` Y . Note that either Qfree \u201d \u03bdpu, Y q and Qeq \u201d x \u201c u \u02da y \u201c Y or Qfree \u201d emp and Qeq \u201d x \u201c null \u02da y \u201c Y . A very similar contract can be used for calloc, just with u \u00de\u00d1 JrY s changed to u \u00de\u00d1 0rY s. We remark that the contracts for malloc and calloc are the only disjunctive contracts among the contracts for the basic statements of our programming language. Function freepxq called with the null argument:\n\u03d5X,Y,Z \u201d x \u201c X \u02da y \u201c Y \u02da z \u201c Z, \u03d5X,Z \u201d X \u00de\u00d1 JrZs, \u03d5Y,Z \u201d Y1 \u201c Y \u02da \u2039i\u010fn i\u201c1pYi \u00de\u00d1 Bi \u02da Yi`1 \u201c Yi ` sizepBiqq \u02da Yn`1 \u201c Y ` Z, \u03d51 X,Z \u201d X1 \u201c X \u02da \u2039i\u010fn i\u201c1pXi \u00de\u00d1 Bi \u02da Xi`1 \u201c Xi ` sizepBiqq \u02da Xn`1 \u201c X ` Z.\n \u201d \u00de\u00d1 Jrs \u03d5Y,Z \u201d Y1 \u201c Y \u02da \u2039i\u010fn i\u201c1pYi \u00de\u00d1 Bi \u02da Yi`1 \u201c Yi ` sizepBiqq \u02da Yn`1 \u201c Y ` Z, \u03d51 X,Z \u201d X1 \u201c X \u02da \u2039i\u010fn i\u201c1pXi \u00de\u00d1 Bi \u02da Xi`1 \u201c Xi ` sizepBiqq \u02da Xn`1 \u201c X ` Z.\nOf course, in practice, a particular instance of the contract schema will be chosen on-the-fly according to the current state of the computation. One starts with \u03d5Y,Z \u201d Y \u00de\u00d1 B and \u03d51 X,Z \u201d X \u00de\u00d1 B and uses the splitting bi-abduction rules on \u03d5Y,Z according to how the block pointed by Y is partitioned. This splitting is synchronized with splitting \u03d51 X,Z in the same way. Thus, the Z bytes stored at Y will be transferred to X preserving their interpretation.\nFunction assume\u2019py, zq with the body assumepy \u2019 zq: ty \u201c Y \u02da z \u201c Zu assumepy \u2019 zq ty \u201c Y \u02da z \u201c Z \u02da y \u2019 zu Function assert\u2019py, zq with the body assertpy \u2019 zq: ty \u201c Y \u02da z \u201c Z \u02da y \u2019 zu assertpy \u2019 zq ty \u201c Y \u02da z \u201c Z \u02da\n\u00a7 Lemma 1. Let stmt be a basic statement and let tPu fpx1, . . . , xnq tQu be a contract for stmt as stated above. Then, the contract is sound, i.e., for all frames F, all configurations pS, B, Mq such that pS, B, Mq |\u00f9 F \u02da P, and all executions of fpx1, . . . , xnq that start from pS, B, Mq and end in some configuration pS1, B1, M 1q, it holds that pS1, B1, M 1q |\u00f9 F \u02da Q.\n# 6.3 Contract Generation\nWe now discuss the generation of contracts for arbitrary user-defined functions. Our analysis proceeds along the call tree, starting from its leaves. Hence, we can assume to already have computed contracts for nested function calls. (Recall that, in this paper, we limit ourselves to non-recursive functions.) We first discuss a special case where we assume that the function to be analyzed consists of a sequence of calls of other functions (i.e., no branching and looping), and we assume the contracts of the nested function calls to be conjunctive. After that we state the general set-up of our analysis.\n# Sequences of Function Calls with Conjunctive C\nWe now consider functions whose body consists of a sequence of function calls s1; . . . ; sl for some l \u0105 0, whose contracts are conjunctive (this includes for example all built-in functions apart from malloc). We formulate a symbolic execution that, given such a function fpx1, . . . , xnq, derives a sound contract for f. The symbolic execution starts at the beginning of f and maintains a pair of formulae P and Q, representing the so-far computed part of the pre-condition of the function f and the current symbolic state. The symbolic execution will guarantee that configurations that satisfy P lead to configurations satisfying Q after executing the so-far analysed statements. P and Q will change throughout the symbolic execution because we keep restricting the precondition P and advancing the symbolic state Q. The symbolic execution is set up such that the program variables x1, . . . , xn may be updated, while all other variables will never be modified (but, of course, fresh variables may be introduced and assigned at any time). The symbolic execution is initialised by introducing fresh logical variables X1, . . . , Xn and setting P \u201d Q \u201d x1 \u201c X1 \u02da \u00a8 \u00a8 \u00a8 \u02da xn \u201c Xn. The symbolic execution then proceeds iteratively, considering the sequences s1; . . . ; si, starting with i \u201c 0. For every 0 \u010f i \u010f l, the formulae P and Q are updated such that they form a contract for the sequence s1; . . . ; si. We argue in the proof of Theorem 3 below that the symbolic execution maintains the contract tPu s1; . . . ; si tQu. Note that our initialization of the formulae P and Q ensures the correctness condition for i \u201c 0 and we derive a sound contract for f once we reach i \u201c l. We now describe how to apply a contract for a function call si. We consider some function tCugpy1, . . . , ymqtDu with D \u201d DUD. Dfree \u02da Deq. Let si \u201d gpa1, . . . , amq be the function call with arguments ta1, . . . , amu \u010e tx1, . . . , xnu, where we have by assumption that the ai are pairwise different. Let P and Q \u201d DUQ. Qfree \u02da Qeq be the current pre-condition and symbolic state, respectively. We can assume w.l.o.g. that varpCq X varpQfree \u02da Qeqq \u010e PVar because we can always rename the logical variables of a contract (here, tCu gpy1, . . . , ymq tDu) in order to avoid\nname clashes. Then, we consider the bi-abduction problem Qfree \u02da r?s |\u00f9 C1 \u02da r?s pBAPq\nC1 \u201d pCrai{yisqr\u03b5j{xjs\nis the formula C from the precondition of gpy1, . . . , ymq with the parameters yi substituted b the arguments ai, and the variables xj substituted by the expressions \u03b5j according to the formul Qeq \u201d x1 \u201c \u03b51 \u02da \u00a8 \u00a8 \u00a8 \u02da xn \u201c \u03b5n. (Note that no formula in the bi-abduction problem contains any o the program variables x1, . . . , xn, y1, . . . , ym.) A solution to the bi-abduction problem (BAP) consist of formulae M and F, denoted as an antiframe and a frame, respectively, such that\nWe require M to be a quantifier-free symbolic heap with varpMq \u010e LVarzUQ (note that all existentially quantified variables in UQ are introduced during the symbolic execution, hence we cannot restrict them at the beginning of the function where they are not known yet). We also require F to be a quantifier-free symbolic heap with varpFq \u010e LVar. Note that any such M and F ensure that the function call si \u201d gpa1, . . . , amq can be safely executed: The soundness of the contract tCu gpy1, . . . , ymq tDu guarantees that gpy1, . . . , ymq can be executed for any valuation of the universally quantified variables; hence, it is sufficient to find some valuation (as required by the existential quantification in DU. C1 \u02da F). Given a solution M and F to the bi-abduction problem (BAP), we can then update the current state of the symbolic execution (we denote the new pre- and post-condition by Pafter and Qafter, respectively):\nPafter :\u201c M \u02da P. Q1 free :\u201c F \u02da Dfree. Q1 eq is the (separating) conjunction of xi \u201c \u03b51 j for each xi passed by reference as the argument aj to g where aj \u201c \u03b51 j is the final value according to the post-condition Deq; and xi \u201c \u03b5i for each variable not passed to g where xi \u201c \u03b5i is according to Qeq before the call of g. Qafter :\u201c DUQafter. Q1 free \u02da Q1 eq where UQafter \u201c pvarpQ1 free \u02da Q1 eqq X LVarqzvarpPafterq.\nFor later use, we write pPafter, Qafterq :\u201c biabductpP, Q, gpa1, . . . , amq, C, Dq for the result of advancing the symbolic execution by one step wrt the bi-abduction solution. Formula Simplification by Quantifier Elimination. We will always try to simplify formulas with existentially quantified formulas. For this, we assume the existence of a quantifier elimination procedure eliminatepU, \u03d5q, which attempts to eliminate as many variables u P U as possible from a quantifier-free symbolic heap \u03d5. We require that DU 1.\u03c8 is equivalent to DU.\u03d5, where \u03c8 \u201c eliminatepU, \u03d5q is the formula returned by the quantifier elimination procedure and U 1 is the set U minus the eliminated variables. We use the following simple quantifier elimination procedure eliminatepU, \u03d5q in our implementation: For every equality in u \u201c \u03b5 in \u03d5 with u P U, we replace u everywhere in \u03d5 by \u03b5 and then delete the equality u \u201c \u03b5. It is easy to verify that this procedure satisfies the above requirement.\n\u00a7 Example 2. We consider the call gpxq of a function with contract tCu gpyq tDu during th analysis of some function fpxq, where the so-far derived precondition P, the current symbolic stat Q as well as the pre- and post-conditions C and D look as follows:\nP \u201d X \u00de\u00d1 a \u02da X ` 8 \u00de\u00d1 b \u02da x \u201c X; Q \u201d DUQ. Qfree \u02da Qeq where Qfree \u201d X \u00de\u00d1 a \u02da X ` 8 \u00de\u00d1 z, Qeq \u201d x \u201c X and UQ \u201c tzu;\nX \u00de\u00d1 a \u02da X ` 8 \u00de\u00d1 z \u02da r?s |\u00f9 Y \u00de\u00d1 u \u02da Y ` 8 \u00de\u00d1 w \u02da u \u00de\u00d1 v \u02da X \u201c Y \u02da r?s. Then, our bi-abduction procedure returns M \u201d a \u00de\u00d1 v and F \u201d X \u201c Y \u02da a \u201c u \u02da z \u201c w, i.e., we have Qfree \u02da M |\u00f9 DU. C1 \u02da F where U \u201c varpC1 \u02da FqzvarpQfree \u02da Qeq \u02da Mq \u201c tY, u, wu. (For how M and F were generated, see the description of the bi-abduction procedure below.) The new missing precondition Pafter of the function fpxq and the new current symbolic state Qafter of fpxq after the call of gpxq is then as follows: Pafter \u201d P \u02da M \u201d X \u00de\u00d1 a \u02da X ` 8 \u00de\u00d1 b \u02da x \u201c X \u02da a \u00de\u00d1 v, Q1 free \u201d F \u02da Dfree \u201d X \u201c Y \u02da a \u201c u \u02da z \u201c w \u02da Y \u00de\u00d1 u \u02da Y ` 8 \u00de\u00d1 w \u02da u \u00de\u00d1 v \u02da v \u00de\u00d1 c, Q1 eq \u201d x \u201c v, Qafter \u201d Dc, u, w, Y, z. X \u201c Y \u02daa \u201c u\u02daz \u201c w \u02daY \u00de\u00d1 u\u02daY `8 \u00de\u00d1 w \u02dau \u00de\u00d1 v \u02dav \u00de\u00d1 c\u02dax \u201c v, we then intend to simplify Qafter and compute eliminateptc, u, w, Y, zu, Q1 free \u02da Q1 eqq \u201d X \u00de\u00d1 a \u02da X ` 8 \u00de\u00d1 w \u02da a \u00de\u00d1 v \u02da v \u00de\u00d1 c \u02da x \u201c v, i.e., we obtain Qsimp after \u201d Dc, w. X \u00de\u00d1 a \u02da X ` 8 \u00de\u00d1 w \u02da a \u00de\u00d1 v \u02da v \u00de\u00d1 c \u02da x \u201c v.\ni.e., we have\nWe now state the soundness of our approach:\n\u00a7 Theorem 3. Let fpx1, . . . , xnq be some function and let tPu fpx1, . . . , xnq tQu by the contract inferred by the bi-abductive inference as stated above. Then, the contract is sound, i.e., for all frames F, all configurations pS, B, Mq with pS, B, Mq |\u00f9 F \u02da P, and all executions of fpx1, . . . , xnq that start with pS, B, Mq and end with some configuration pS1, B1, M 1q we have pS1, B1, M 1q |\u00f9 F \u02da Q.\nProof. We prove that tPu s1; . . . ; si tQu for all 0 \u010f i \u010f l (*), where P and Q are the formulae after step i of the symbolic execution. We prove (*) by induction on i. Note that (*) holds for i \u201c 0 due to the initialization of P and Q. We now consider some i \u0105 0 and the sequence s1; . . . ; si. By induction assumption we have that tPu s1; . . . ; si tQu. Let si`1 \u201d gpa1, . . . , amq be some function call for which we assume the contract tCu gpy1, . . . , ymq tDu with D \u201d DUD. Dfree \u02da Deq, whose soundness has already been established. Let M and F be a solution to the biabuction problem, i.e., let M and F be formulae with Qfree \u02da M |\u00f9 DU. C1 \u02da F for U \u201c varpC1 \u02da FqzvarpQfree \u02da Qeq \u02da Mq (#) where C1 is the formula C after parameter instantiation as described above. We will now argue that tPafteru s1; . . . ; si; si`1 tQafteru where Pafter and Qafter are the pre- and post-condition after step i ` 1. Let G be some frame. We now instantiate the frame in the induction assumption with G \u02da M, i.e., we have that tG \u02da M \u02da Pu s1; . . . ; si tG \u02da M \u02da Qu. Let pS, B, Mq be some configuration with\npS, B, Mq |\u00f9 G \u02da M \u02da P and let pS1, B1, M 1q be the result of executing s1; . . . ; si starting from configuration pS, B, Mq. From the instantiation of the induction assumption, we get that pS1, B1, M 1q |\u00f9 G\u02daM \u02daQ. By (#), we have that pS1, B1, M 1q |\u00f9 G\u02daDUQ. pQeq \u02daDU. pC1 \u02daFqq. Hence, there is some stack S2 with dompS2q \u201c dompS1q Y UQ Y U Y ty1, . . . , ymu such that pS2, B1, M 1q |\u00f9 G \u02da F \u02da C and S2pyjq \u201c S2pxiq according to xi \u201c aj in the function call gpa1, . . . , amq. Let pS3, B2, M 2q be the configuration that results from executing gpy1, . . . , ymq starting from pS2, B1, M 1q. By the correctness of tCu gpy1, . . . , ymq tDu, we get that pS3, B2, M 2q |\u00f9 G \u02da F \u02da D. We now consider the stack S\u02dd defined by S\u02ddpxiq \u201c S3pyjq for all 1 \u010f i \u010f m with xi \u201c aj in the function call gpa1, . . . , amq, and S\u02ddpxiq \u201c Spxiq for all xi P Varzta1, . . . , anu. Note that pS\u02dd, B2, M 2q is the resulting configuration after returning from the function call gpa1, . . . , amq. By the above, we then have pS\u02dd, B2, M 2q |\u00f9 G \u02da DpU Y UQ Y UDq. pF \u02da Dfree \u02da Q1 eqq. Because of pU Y UQ Y UDq X varpPafterq \u201c H, we then get pS\u02dd, B2, M 2q |\u00f9 G \u02da DUQafter. pQ1 free \u02da Q1 eqq. This establishes the claim. \u0111\n# 3.2 Branching, Looping and Disjunctive Contract\nSo far we have described the generation of contracts for functions tPu fpx1, . . . , xnq tQu whose body consists of a sequence of function calls with conjunctive contracts and without branching and looping. In this section, we lift all these restrictions. We follow [7] and present a two-round analysis for the general case (we present a short summary of these two analysis phases here to make the paper self-contained, but we refer the reader to [7] for a more detailed exposition and for a formal statement on the soundness of the analysis): The first round (called PreGen in [7]) infers a set of pre-/post-condition pairs pP, Qq, but in contrast to Theorem 3 there is no guarantee about the soundness of the inferred pP, Qq. For each pre-/post-condition pair pP, Qq computed in the first round, the second round (called PostGen in [7]) discards the post-condition Q and re-starts the symbolic execution from the pre-condition P not allowing the strengthening of the pre-condition throughout the symbolic execution, which either fails or results in a set of pre-/post-condition pairs pP, Q1q, . . . , pP, Qlq. In the latter case, we return pP, Q1 _ \u00a8 \u00a8 \u00a8 _ Qlq, which is guaranteed to be a sound contract. We now describe the general set-up that is used by the first as well as the second analysis round. Recall that we assume a control flow graph pV, E, entry, exitq for each function fpx1, . . . , xnq where V is a set of nodes, there are dedicated nodes entry, exit P V , and E \u010e V \u02c6 V is a set of edges where each edge is labelled by a function call (recall that we also model basic statements as functions). By Vcut \u010e V , we denote a set of cut-points, where each loop must contain at least one cut-point (usually the header location of a loop). A function without loops has Vcut \u201c H. The symbolic execution maintains a mapping symb : V \u00d1 p2finqContract where each location v P V is mapped to a finite set of pre-/post-condition pairs pP, Qq P Contract. Initially, symbpentryq \u201c tpPinit, Qinitqu where Pinit and Qinit are specified as stated below for the first and second analysis round, and symbpvq \u201c H for all v \u2030 entry. The symbolic execution then proceeds as a work-list algorithm. In each computational step, the symbolic execution picks a pre-/post-condition pair pP, Qq P symbpvq, for some v P V , that has not been processed yet. Then, the symbolic execution performs the following for each outgoing edge pv, v1q P E: Let gpa1, . . . , akq be the function call labelling the edge pv, v1q. For each contract tCu gpy1, . . . , ykq tD1 _ \u00a8 \u00a8 \u00a8 _ Dlu and each disjunct Di of such a contract, we invoke bi-abduction procedure from Section 6.3, i.e., let pPafter, Qafterq \u201c biabductpP, Q, gpa1, . . . , amq, C, Diq; then,\n1. for v1 R Vcut, we add pPafter, Qafterq into symbpv1q, and 2. for v1 P Vcut,\nwe check whether there is a pP 1, Q1q P symbpv1q that covers pPafter, Qafterq, i.e., we have DLVarpPafterq. Pafter |\u00f9 DLVarpP 1q. P 1 and DLVarpQafterq. Qafter |\u00f9 DLVarpQ1q. Q1, where LVarp\u03d5q \u201c varp\u03d5q X LVar denotes the free logical variables appearing in the formula; we note that a covering guarantees that the all configurations that satisfy the pre- resp. post condition of the pair pPafter, Qafterq already satisfy the corresponding condition of pP 1, Q1q (for some suitable instantiation of the logical variables); hence, such pPafter, Qafterq do not need to be added to symbpv1q, which supports the termination of the fixed point termination; if there is no pP 1, Q1q P symbpv1q that covers pPafter, Qafterq, we add p\u03b1pPafterq, \u03b1pQafterqq into symbpv1q, where \u03b1 is a widening procedure in the form of a list abstraction that is quite common in the area\u2014cf., e.g., [2]. In its simplest form, the abstraction \u03b1 searches for patterns of the form \u039bpx, yq \u02da \u039bpy, zq (resp. \u039bpx, v, yq \u02da \u039bpy, x, zq) and replaces them by ls\u039bpa,bqpx, zq (resp. dls\u039bpa,b,cqpx, y, v, zq) provided that there is no pointer nor other list segment incoming to y (i.e., the current symbolic state cannot, e.g., imply u \u00de\u00d1 y \u02da u \u2030 x). The actual abstraction is, of course, more complex\u2014e.g., apart from applying to sequences of the \u039b predicates as above, which of course can be longer than just two appearances of \u039b, it also applies to sequences consisting of the \u039b predicates and of compatible singly-/doubly-linked list segments (e.g., \u039bpx, yq \u02da ls\u039bpa,bqpy, zq may abstract to ls\u039bpa,bqpx, zq). Since, however, the abstraction is rather standard in the area, we do not develop it further here and refer the interested reader to [2]. The worklist algorithm continues until a fixed point is reached, i.e., until no more pre-/post-condition pairs are added to symb and all pairs have been processed. Next, we add some more specific details about the two rounds of the analysis: 1. Round: We set Pinit \u201d Qinit \u201d x1 \u201c X1 \u02da \u00a8 \u00a8 \u00a8 \u02da xn \u201c Xn (recall that we assume x1, . . . , xn to be all the program variables that appear in the body of fpx1, . . . , xnq). Once the worklist algorithm has reached a fixed point, we return all pre-/post-condition pairs pP, Qq P symbpexitq as the result of the first analysis round. 2. Round: For each pP, Qq computed by the first analysis round, there is a second analysis round where we set Pinit \u201d Qinit \u201d P and where we disallow the strengthening of the precondition throughout the symbolic execution (i.e., we require M \u201c emp for each bi-abduction call performed during symbolic execution; if this is not the case, we fail). Once the worklist algorithm has reached a fixed point, we consider the computed pre-/post-condition pairs symbpexitq \u201c tpP, Q1q, . . . , pP, Qlqu (note that all these pairs must have the same pre-condition P) and return the contract pP, Q1 _ \u00a8 \u00a8 \u00a8 _ Qlq. We point out to the reader that the second round in general creates multiple contracts\u2014one contract for each possible pre-condition.\n# Assume and Assert Statements\nAs we have already said above, we model branching and looping as usual, i.e., by having multiple outgoing control flow edges labelled by an assume statement with appropriate conditions. However, following [7], we also observe that it is sometimes beneficial to replace assume statements by assert statements because this adds context sensitivity to the analysis. For example, when we encounter an if-statement with the condition x \u201c y (where x and y are paremeters of the function under analysis), replacing assume by assert statements leads to (at least) two distinct contracts with preconditions x \u201c y \u02da \u00a8 \u00a8 \u00a8 and x \u2030 y \u02da \u00a8 \u00a8 \u00a8 . Hence, we try to treat all assume as assert statements. However, we revert back to assume statements in case using assert leads to an analysis failure\u2014in particular, this happens when the variables used in the conditions are not parameters of the function under analysis and hence not controllable through the contracts. We refer an interested reader to Appendix A where we provide several examples illustrating the\nWe refer an interested reader to Appendix A where we provide several examples illustrating the analysis of conditions and loops, using abstraction and the second analysis round.\n# Bi-Abduction Procedure\nAssume that Q \u201d DUQ. Qfree \u02da Qeq is the current symbolic state. We now explain how to compute a solution to the bi-abduction problem Qfree\u02dar?s |\u00f9 C1\u02dar?s pBAPq. That is, we show how to compute an anti-frame M and a frame F such that Qfree \u02daM |\u00f9 DU. C1 \u02daF where U \u201c varpC1 \u02daFqzvarpQfree \u02da Qeq \u02da Mq and where M does not contain any quantified variable from UQ. Following [7], we proceed in three steps:\nn three steps: 1. We solve the abduction problem Qfree \u02da r?s |\u00f9 C1 \u02da true and compute a quantifier-free symbolic heap M 1 such that Qfree \u02da M 1 |\u00f9 C1 \u02da true. (Note that, in this first step, the solution M 1 is allowed to contain variables from UQ.) We state our rules for finding a solution to the abduction problem Qfree \u02da r?s |\u00f9 C1 \u02da true in Section 7.1. Example 2 (continued). For C1 \u201d pCry{xsqrX{xs \u201d Y \u00de\u00d1 u \u02da Y ` 8 \u00de\u00d1 w \u02da u \u00de\u00d1 v \u02da X \u201c Y and Qfree \u201d X \u00de\u00d1 a\u02daX `8 \u00de\u00d1 z, we obtain the solution M 1 \u201d X \u201c Y \u02daa \u201c u\u02daz \u201c w \u02dau \u00de\u00d1 v to the abduction problem Qfree \u02da r?s |\u00f9 C1 \u02da true. 2. We solve the frame problem Qfree \u02da M 1 |\u00f9 C1 \u02da r?s and compute a quantifier-free symbolic heap F such that Qfree \u02da M 1 |\u00f9 C1 \u02da F. F is computed as a by-product of our rules for finding the abduction solution M 1, and no special frame inference procedure is needed\u2014see Section 7.2. Example 2 (continued). We obtain the solution F \u201d X \u201c Y \u02da a \u201c u \u02da z \u201c w to the frame problem Qfree \u02da M 1 |\u00f9 C1 \u02da r?s. 3. We finally compute a formula M such that Qfree \u02da M is equivalent to Qfree \u02da DK. M 1 where K \u201c varpM 1qzvarpQfree \u02da Qeq \u02da Mq. The objective is to minimize the missing anti-frame M as much as possible and to eliminate all occurrences of variables UQ in M 1 (which, however, is not always possible). Ideally, we obtain M \u201d emp because this means that no strengthening of the precondition is needed (which is required in the second round of the general procedure as described in Section 6.3.2). In case M does not contain any occurrences of variables UQ, we then return M and F as solutions to the bi-abduction problem (BAP); otherwise, we fail. The minimization of M 1 proceeds in two simple steps: a. We compute M 2 \u201c eliminatepU, M 1q for U \u201c varpM 1qzvarpQfree \u02da Qeqq, eliminating as many variables as possible from M 1. b. If M 2 contains some pure subformula \u03b5 \u2019 \u03b6 with Qfree |\u00f9 \u03b5 \u2019 \u03b6 \u02datrue, we delete this formula from M 2. If we cannot delete any further pure subformula, we return the resulting formula M 2 as the result M.\nWe now state the soundness of the bi-abduction procedure:\n\u00a7 Lemma 4. Assume that Q \u201d DUQ. Qfree \u02da Qeq is the symbolic state. Let M and F be some formulae returned by the bi-abduction procedure. Then, Qfree \u02da M |\u00f9 DU. C1 \u02da F for U \u201c varpC1 \u02da FqzvarpQfree \u02da Qeq \u02da Mq.\nProof. By Steps 1 and 2 of the bi-abduction procedure, we have Qfree \u02da M 1 |\u00f9 C1 \u02da F (*). By Step 3 of the bi-abduction procedure, we have Qfree \u02da M |\u00f9 Qfree \u02da DK. M 1 (#) where K \u201c varpM 1qzvarpQfree \u02da Qeq \u02da Mq. As it is sound to move the quantifiers to the front (note that K X Qfree \u201c H), we obtain from (#) that Qfree \u02da M |\u00f9 DK. Qfree \u02da M 1. With (*), we get that Qfree \u02da M |\u00f9 DK. C1 \u02da F. We then note that we can drop any variable K1 \u201c KzvarpC1 \u02da Fq from the existential quantification, i.e., we get Qfree \u02da M |\u00f9 DK1. C1 \u02da F. We observe that K1 \u010e U \u201c varpC1 \u02da FqzvarpQfree \u02da Qeq \u02da Mq. We finally observe that we can existentially quantify over every variable UzK1 as this only weakens the formulae on the right-hand side. Hence, we obtain Qfree \u02da M |\u00f9 DU. C1 \u02da F. \u0111\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/0a65/0a658870-0167-4871-b02f-edab03b92f2d.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Figure 4 An illustration of the split-pt-pt-right rule where z \u201c l1 \u00b4 k \u00b4 l.</div>\n# 7.1 Abduction Rules\nWe now state our rules for computing a solution to the abduction problem. In the below rules, we wil use the notation \u03d5 \u02da rMs \u0179 \u03c8 to denote that we are deriving the solution M to the abduction problem \u03d5 \u02da r?s |\u00f9 \u03c8. The rules are to be applied in the stated order.15 We start with a rule allowing us to learn missing pure constraints.\nThe match rule presented below allows one to match points-to predicates from the LHS and RHS that have the same source location (\u03b5 \u201c \u03b51) and points-to fields \u03b6, \u03b61 of the same size. Then we learn that the target fields are the same too. We note here that this rule",
    "paper_type": "method",
    "attri": {
        "background": "This paper addresses the issue of analyzing programs with dynamic pointer-linked data structures, particularly in the context of C programming. Previous methods often require specialized analysis harnesses to initialize data structures, which can be error-prone and inefficient. This paper proposes a new static analysis method that allows for the analysis of code fragments without the need for such harnesses, thus addressing scalability and usability issues.",
        "problem": {
            "definition": "The problem is the difficulty of analyzing programs that utilize dynamic pointer-linked data structures, especially when these programs contain advanced low-level pointer operations. Traditional shape analysis struggles with efficiently encoding and handling potentially infinite sets of graph structures corresponding to unknown memory configurations.",
            "key obstacle": "The main challenge is the requirement to analyze fragments of code that start manipulating dynamic data structures without any initialization, which existing methods do not support adequately."
        },
        "idea": {
            "intuition": "The idea stems from the need for a more flexible analysis that can handle code fragments directly, inspired by the limitations of existing static analysis methods that require complete programs.",
            "opinion": "The proposed method, termed Low-Level Bi-Abduction, extends existing bi-abductive analysis techniques to accommodate low-level pointer operations and dynamic data structures, allowing for the analysis of incomplete code.",
            "innovation": "This method innovates by introducing a per-field separating conjunction in separation logic, allowing for more granular representation of memory configurations and enabling the analysis of complex pointer manipulations."
        },
        "method": {
            "method name": "Low-Level Bi-Abduction",
            "method abbreviation": "LLBA",
            "method definition": "LLBA is a static analysis method that analyzes code fragments involving dynamic pointer-linked data structures using a modified bi-abductive approach based on separation logic.",
            "method description": "The method analyzes functions along the call tree, generating contracts that summarize their behavior without requiring call context.",
            "method steps": [
                "Analyze each function starting from the leaves of the call tree.",
                "Derive preconditions and postconditions for each function based on the analysis.",
                "Use contracts derived from lower-level functions when analyzing higher-level functions."
            ],
            "principle": "The effectiveness of LLBA lies in its ability to derive contracts that over-approximate safe preconditions and ensure postconditions are satisfied, thus providing sound guarantees for program execution."
        },
        "experiments": {
            "evaluation setting": "The method was implemented in a prototype tool called Broom and evaluated on complex programs involving advanced pointer operations, including code from the Linux kernel.",
            "evaluation method": "Performance was assessed by comparing the analysis results against known properties of the analyzed code fragments, focusing on the accuracy of derived contracts."
        },
        "conclusion": "The experiments demonstrated that the Low-Level Bi-Abduction method is capable of effectively analyzing complex programs with dynamic data structures and low-level pointer operations, providing sound and useful contracts for program behavior.",
        "discussion": {
            "advantage": "The primary advantage of LLBA is its ability to analyze code fragments directly without requiring initialization harnesses, thus improving usability and scalability of static analysis.",
            "limitation": "A limitation of the method is that it may under-approximate the set of all possible safe preconditions, potentially missing some extreme but safe preconditions.",
            "future work": "Future research directions include enhancing the method to handle more complex scenarios, such as recursive functions and disjunctive postconditions, and improving the efficiency of the analysis."
        },
        "other info": {
            "Funding": "The Czech authors were supported by the project 20-07487S of the Czech Science Foundation, the FIT BUT internal project FIT-S-20-6427, and L. Hol\u00edk by the ERC.CZ project LL1908."
        }
    },
    "mount_outline": [
        {
            "section number": "1.1",
            "key information": "This paper addresses the issue of analyzing programs with dynamic pointer-linked data structures, particularly in the context of C programming, highlighting the integration of static analysis with software development."
        },
        {
            "section number": "1.2",
            "key information": "The proposed method, Low-Level Bi-Abduction, improves usability and scalability of static analysis, which is significant for enhancing software development practices."
        },
        {
            "section number": "1.3",
            "key information": "The main objective of the paper is to propose a new static analysis method that allows for the analysis of code fragments without the need for specialized initialization harnesses."
        },
        {
            "section number": "2.1",
            "key information": "The Low-Level Bi-Abduction method utilizes a modified bi-abductive approach based on separation logic to analyze dynamic pointer-linked data structures."
        },
        {
            "section number": "2.2",
            "key information": "Traditional shape analysis struggles with efficiently encoding and handling potentially infinite sets of graph structures corresponding to unknown memory configurations, indicating the historical context of challenges in static analysis."
        },
        {
            "section number": "3.1",
            "key information": "The method analyzes functions along the call tree, generating contracts that summarize their behavior, which is applicable in improving code documentation and requirement analysis."
        },
        {
            "section number": "4.1",
            "key information": "The Low-Level Bi-Abduction method can be considered an innovative approach to AI-driven code analysis, focusing on static analysis of incomplete code."
        },
        {
            "section number": "6.1",
            "key information": "The primary challenge addressed is the requirement to analyze fragments of code that start manipulating dynamic data structures without any initialization, which existing methods do not support adequately."
        },
        {
            "section number": "6.3",
            "key information": "Future research directions include enhancing the Low-Level Bi-Abduction method to handle more complex scenarios, such as recursive functions and disjunctive postconditions."
        }
    ],
    "similarity_score": 0.5770356197675484,
    "image": null,
    "path": "/home/dany/codes/autosurvey/outputs/2025-01-11-1832_natur/papers/Low-Level Bi-Abduction.json"
}