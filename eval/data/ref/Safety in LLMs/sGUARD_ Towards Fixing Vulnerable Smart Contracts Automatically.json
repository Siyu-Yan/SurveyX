{
    "from": "arxiv",
    "scholar_id": null,
    "detail_id": "arXiv:2101.01917",
    "title": "sGUARD: Towards Fixing Vulnerable Smart Contracts Automatically",
    "abstract": "Smart contracts are distributed, self-enforcing programs executing on top of blockchain networks. They have the potential to revolutionize many industries such as financial institutes and supply chains. However, smart contracts are subject to code-based vulnerabilities, which casts a shadow on its applications. As smart contracts are unpatchable (due to the immutability of blockchain), it is essential that smart contracts are guaranteed to be free of vulnerabilities. Unfortunately, smart contract languages such as Solidity are Turing-complete, which implies that verifying them statically is infeasible. Thus, alternative approaches must be developed to provide the guarantee. In this work, we develop an approach which automatically transforms smart contracts so that they are provably free of 4 common kinds of vulnerabilities. The key idea is to apply runtime verification in an efficient and provably correct manner. Experiment results with 5000 smart contracts show that our approach incurs minor run-time overhead in terms of time (i.e., 14.79%) and gas (i.e., 0.79%).",
    "bib_name": "nguyen2021sguardfixingvulnerablesmart",
    "md_text": "# SGUARD: Towards Fixing Vulnerable Smart Contracts Automatically\nTai D. Nguyen, Long H. Pham, Jun Sun dtnguyen.2019@smu.edu.sg, {longph1989, sunjunhqq}@gmail.com Singapore Management University, Singapore\nAbstract\u2014Smart contracts are distributed, self-enforcing programs executing on top of blockchain networks. They have the potential to revolutionize many industries such as financial institutes and supply chains. However, smart contracts are subject to code-based vulnerabilities, which casts a shadow on its applications. As smart contracts are unpatchable (due to the immutability of blockchain), it is essential that smart contracts are guaranteed to be free of vulnerabilities. Unfortunately, smart contract languages such as Solidity are Turing-complete, which implies that verifying them statically is infeasible. Thus, alternative approaches must be developed to provide the guarantee. In this work, we develop an approach which automatically transforms smart contracts so that they are provably free of 4 common kinds of vulnerabilities. The key idea is to apply runtime verification in an efficient and provably correct manner. Experiment results with 5000 smart contracts show that our approach incurs minor run-time overhead in terms of time (i.e., 14.79%) and gas (i.e., 0.79%).\n6 Jan 2021\n# I. INTRODUCTION\nBlockchain is a public list of records which are linked together. Thanks to the underlying cryptography mechanism, the records in the blockchain can resist against modification. Ethereum is a platform which allows programmers to write distributed, self-enforcing programs (a.k.a smart contracts) executing on top of the blockchain network. Smart contracts, once deployed on the blockchain network, become an unchangeable commitment between the involving parties. Because of that, they have the potential to revolutionize many industries such as financial institutes and supply chains. However, like traditional programs, smart contracts are subject to code-based vulnerabilities, which may cause huge financial loss and hinder its applications. The problem is even worse considering that smart contracts are unpatchable once they are deployed on the network. In other words, it is essential that smart contracts are guaranteed to be free of vulnerabilities before they are deployed. In recent years, researchers have proposed multiple approaches to ensure smart contracts are vulnerability-free. These approaches can be roughly classified into two groups, i.e., verification and testing. However, existing efforts do not provide the required guarantee. Verification of smart contracts is often infeasible since smart contracts are written in Turingcomplete programming languages (such as Solidity which is the most popular smart contract language), whereas it is known that testing (of smart contracts or otherwise) only shows the presence not the absence of vulnerabilities.\nIn this work, we propose an approach and a tool, called SGUARD, which automatically fixes potentially vulnerable smart contracts. SGUARD is inspired by program fixing techniques for traditional programs such as C or Java, and yet are designed specifically for smart contracts. First, SGUARD is designed to guarantee the correctness of the fixes. Existing program fixing approaches (e.g., GenFrog [1], PAR [2], Sapfix [3]) often suffer from the problem of weak specifications, i.e., a test suite is taken as the correctness specification. A fix driven by such a weak correctness criteria may over-fit the given test suites and does not provide correctness guarantee in all cases. Furthermore, fixes for smart contracts may suffer from not only time overhead but also gas overhead (i.e., extra fees for running the additional code) and SGUARD is designed to minimize the run-time overhead in terms of time and gas introduced by the fixes. Given a smart contract, at the high level, SGUARD works in two steps. In the first step, SGUARD first collects a finite set of symbolic execution traces of the smart contract and then performs static analysis on the collected traces to identify potential vulnerabilities. As of now, SGUARD supports 4 types of common vulnerabilities. Note that our static analysis engine is built from scratch as extending existing static analysis engines for smart contracts (e.g., Securify [4] and Ethainter [5]) for our purpose is infeasible. For instance, their sets of semantic rules are incomplete and sometimes produce conflicting results (i.e. a contract both complies and violates a security rule). In addition, they perform abstract interpretation locally (i.e., context/path-insensitive analysis) and thus suffer from many false positives. A contract fixed based on the analysis results from these tools may introduce unnecessary overhead. In the second step, SGUARD applies a specific fixing pattern for each type of vulnerability on the source code to guarantee that the smart contract is free of those vulnerabilities. Our approach is proved to be sound and complete on termination for the vulnerabilities that SGUARD supports. To summarize, our contribution in this work is as follows. \u2022 We propose an approach to fix 4 types of vulnerabilities in smart contracts automatically. \u2022 We prove that our approach is sound and complete for the considered vulnerabilities. \u2022 We implement our approach as a self-contained tool, which is then evaluated with 5000 smart contracts. The experiment results show that SGUARD fixes 1605 smart contracts. Furthermore, the fixes incur minor run-time\noverhead in terms of time (i.e., 14.79% on average) and gas (i.e., 0.79%). The remainder of the paper is organized as follows. In Section II, we provide some background about smart contracts and illustrate how our approach works through examples. The problem is then defined formally in Section III. In Section IV, we present the details of our approach. The experiment results are presented in Section V. We discuss related work in Section VI and conclude in Section VII.\nII. BACKGROUND AND OVERVIEW\n# II. BACKGROUND AND OVERVIEW\nIn this section, we introduce relevant background on smart contracts and illustrate how our approach addresses the problem of smart contract vulnerabilities through examples.\n# A. Smart Contract\nThe concept of smart contracts came into being with Ethereum [6], i.e., a digital currency platform with the capability of executing programmable code. It is subsequently supported by platforms such as RSK [7] and Hyperledger [8]. In this work, we focus on Ethereum smart contracts as it remains the most popular smart contracts platform. Intuitively speaking, an Ethereum smart contract implements a set of rules for managing digital assets in Ethereum accounts. In the Ethereum platform, there are two type of accounts, i.e., externally owned accounts (EOAs) and contract accounts. Both types of accounts have a 256-bit unique address and a balance which represents the amount of Ether (a.k.a. Ethereum currency unit) in the account. Contract accounts are the ones which are associated with smart contracts that can be used to perform certain predefined tasks. A smart contract is similar to a class in object-oriented programming languages such as Java or C#. It contains persistent data such as storage variables and functions that can modify these variables (including a constructor which initializes them). Functions that are declared public can be invoked from other accounts (either EOAs or other contract accounts) through transactions, i.e., a sequence of function invocations. The Etherum platform supports multiple programming languages for smart contracts programming. Currently, the most popular one is Solidity, i.e., a Turing-complete programming language. For instance, Figure 1(a) shows a public function in a contract named SmartMesh written in Solidity. Once invoked, the function transfers certain amount of tokens from an account (at address from) to another account (at address to). A Solidity contract is compiled into Ethereum bytecode. With the bytecode, a transaction is then executed by the Ethereum Virtual Machine (EVM) on miners\u2019 machines. In its essence, EVM is a stack-based machine. Its details can be referred to in Section III-A. Solidity programs have a number of language features which are specific to smart contracts and are often associated with vulnerabilities. For instance, a public function marked with keyword payable is allowed to receive Ether when it is invoked. The amount of Ether received is represented in the value of variable msg.value. That is, if an account invokes a\npayable function of a contract and sets the value of msg.value greater than 0, Ether is transferred from the invoking account to the invoked account. Besides that, Ether can also be sent to other contracts using function send() or transfer() which are globally defined. Note that in such a case, a specific noname function, called the fallback function, is executed if it is defined in the receiving contract. Note that a fallback function is meant to be a safety valve when a non-existing function is called upon the contract, although it seems to be a source of problems instead. Furthermore, to prevent the harmful exploit of the network such as running infinite loops, each bytecode instruction (called opcode) is associated with a running cost called gas, which is paid from the caller\u2019s account.\n# B. Vulnerabilities\nJust like traditional programs, smart contracts are subject to code-based vulnerabilities. A variety of vulnerabilities have been identified in real-world smart contracts, some of which have been exploited by attackers and have caused significant financial losses (e.g., [9], [10]). In the following, we introduce two kinds of vulnerabilities through examples.\nJust like traditional programs, smart contracts are subject to code-based vulnerabilities. A variety of vulnerabilities have been identified in real-world smart contracts, some of which have been exploited by attackers and have caused significant financial losses (e.g., [9], [10]). In the following, we introduce two kinds of vulnerabilities through examples. Example II.1. One category of vulnerabilities is arithmetic vulnerability, e.g., overflow. For instance, in April 2018, an attacker exploited an integer overflow bug in a smart contract named SmartMesh and stole a massive amount of tokens (i.e., digital currency). The same bug affected 9 tradable tokens at that time and was named as ProxyOverflow. Figure 1(a) shows the (simplified) function transferProxy in the SmartMesh contract which contains the bug. The function is designed for transferring tokens from one account to another, while paying certain fee to the sender (see lines 6 and 7). The developer was apparently aware of potential overflow and introduced relevant checks at lines 2, 4 and 5. Unfortunately, one subtle bug is missed by the checks. That is, if fee+value is 0 (due to overflow) and balances[from]=0, the attacker is able to bypass the check at line 2 and subsequently increase the balance of msg.sender and to (see lines 6 and 7) by an amount more than balances[from]. During the attack, this bug was exploited to create tokens out of air. This example highlights that manually-written checks could be error-prone. Example II.2. Reentrancy vulnerability is arguably the most infamous vulnerability for smart contracts. It happens when a smart contract C invokes a function of another contract D and subsequently a call back (e.g., through the fallback function in contract D) to contract C is made while it is in an inconsistent state, e.g., the balance of contract C is not updated. Figure 2(a) shows a part of a smart contract named MasBurn which contains a cross-function reentrancy vulnerability. MasBurn implements a Midas protocol token, i.e., a tradable ERC20 token. It allows token holders to burn their owned tokens by sending tokens to a specific BURN_ADDRESS, as shown at line 17. The total amount of burned tokens within one week can not exceed weeklyLimit (see line 16), which is a variable that limits the amount of tokens to be burned weekly. However, the problem is that the returned value of\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/5369/5369b87a-a7a8-4ea9-ac37-b739aa132a23.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">(a) Before</div>\n<div style=\"text-align: center;\">Fig. 1: CVE-2018-10376 patched by SGUARD</div>\nthe function getThisWeekBurnAmountLeft (see line 16) has a data dependency on variable numOfBurns, and would be wrongly calculated in the case of a reentrancy call at line 17. That is, if the fallback function of the contract at BURN_ADDRESS contains a call back to the function burn, the function getThisWeekBurnAmountLeft is called with an outdated value of numOfBurns. As a result, the amount of burned tokens would exceed what is allowed. Although no Ether is lost (or created from air) in such an attack, the (implicit) specification of MasBurn is violated in such a scenario. This example also shows the difficulty in handling reentrancy vulnerability, i.e., whether a reentrancy is a vulnerability may depend on the specification of the contract.\n# C. Patching Smart Contracts\nIn the following, we illustrate how SGUARD patches smart contracts through the two examples mentioned above. The technical details are presented in Section IV. We remark that SGUARD identifies vulnerabilities based on bytecode while patches them based on the corresponding source code. This is because analysis based on the bytecode is more precise than analysis based on the source code (as the former is not affected by bugs or optimizations in the Solidity compiler), whereas patching at the source code is transparent to the users. Example II.3. The result of patching the function shown in Figure 1(a) using SGUARD is shown in Figure 1(b). Almost all arithmetic operations (in statements or expressions) are replaced with function calls that perform the corresponding operations safely (i.e., with proper checks for arithmetic overflow or underflow). This effectively prevents the vulnerability as the function reverts immediately if fee+value overflows at line 2. Note that the addition at line 9 is not patched as the variable nonces is not deemed critical itself or is depended on by some critical variables. One might argue that some of the modifications are not necessary, e.g., the one at line 4. This is true for this smart contract, if the goal is to prevent this particular vulnerability. In general, whether a modification is necessary or not can only be answered when the specification of the smart contract is present. SGUARD does not require the specification from the\nIn the following, we illustrate how SGUARD patches smart contracts through the two examples mentioned above. The technical details are presented in Section IV. We remark that SGUARD identifies vulnerabilities based on bytecode while patches them based on the corresponding source code. This is because analysis based on the bytecode is more precise than analysis based on the source code (as the former is not affected by bugs or optimizations in the Solidity compiler), whereas patching at the source code is transparent to the users.\nfunction transferProxy(address from, address to, uint value, uint fee) public { if (balances[from] < add_uint256(fee, value)) revert (); uint nonce = nonces[from]; if (add_uint256(balances[to], value) < balances[to]) revert(); if (add_uint256(balances[msg.sender], fee) < balances [msg.sender]) revert(); balances[to] = add_uint256(balances[to], value); balances[msg.sender] = add_uint256(balances[msg. sender], fee); balances[from] = sub_uint256(balances[from], add_uint256(_value, fee)) nonces[from] = nonce + 1; }\n<div style=\"text-align: center;\">(b) After</div>\n# (b) After\nuser as that would limit its applicability in practice. SGUARD thus always conservatively assumes all arithmetic overflow that may lead to vulnerability are problematic. Although this patch is not minimal, we guarantee that the patched transferProxy is free of arithmetic vulnerability.\nExample II.4. The result of applying SGUARD to the contract shown in Figure 2(a) is shown in Figure 2(b). SGUARD identifies line 17 as an external call, which is critical as an external call invokes a function of another contract which might be under the control of an attacker. SGUARD systematically identifies variables that the external call at line 17 depends on (either through control dependency or data dependency). Afterwards, SGUARD patches these variables and operations accordingly. In particular, this external call has control dependency on the if-statement at line 5 and is followed by a storage update (++numOfBurns at line 18). \u2022 The subtractions at lines 4, 5, 6, 12 are replaced with calls of function sub_uint256, which checks underflow. \u2022 The additions at lines 6, 18 are replaced with calls of function add_uint256 to avoid overflow. \u2022 Function burn is patched to prevent reentrancy. That is, we introduce the modifier nonReentrant at line 15. This modifier is derived from OpenZeppelin [11], a library for secure smart contract development. The resultant smart contract is free of arithmetic vulnerability and reentrancy vulnerability.\nIII. PROBLEM DEFINITION\nIn the following, we first present the semantics for Solidity smart contracts, and then define our problem.\n# A. Concrete Semantics\nA smart contract S can be viewed as a finite state machine S = (V ar, init, N, i, E) where V ar is a set of variables; init is the initial valuation of the variables; N is a finite set of control locations; i \u2208N is the initial control location, i.e., the start of the contract; and E \u2286N \u00d7 C \u00d7 N is a set of labeled edges, each of which is of the form (n, c, n\u2032) where c is an opcode. There are a total of 78 opcodes in\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/aef0/aef0f42a-611b-409f-82ef-f9e3f933bcab.png\" style=\"width: 50%;\"></div>\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18\n<div style=\"text-align: center;\">(a) Before</div>\n# (a) Before\n<div style=\"text-align: center;\">Fig. 2: MasBurn patched by SGUARD</div>\nSolidity (as of version 0.5.3), as summarized in Table I. Note that each opcode is statically assigned with a unique program counter, i.e., each opcode can be uniquely identified based on the program counter. Note that V ar includes stack variables, memory variables, and storage variables. Stack variables are mostly used to store primitive values and memory variables are used to store arraylike values (declared explicitly with keyword memory). Both stack and memory variables are volatile, i.e., they are cleared after each transaction. In contrast, storage variables are nonvolatile, i.e., they are persistent on the blockchain. Together, the variables\u2019 values identify the state of the smart contract at a specific point of time. At the Solidity source code level, stack and memory variables can be considered as local variables in a specific function; and storage variables can be considered as contract-level variables. A concrete trace of the smart contract is an alternating sequence of states and opcodes \u27e8s0, op0, s1, op1, \u00b7 \u00b7 \u00b7 \u27e9such that each state si is of the form (pci, Si, Mi, Ri) where pci \u2208N is the program counter; Si is the valuation of the stack variables; Mi is the valuation of the memory variables; and Ri is the valuation of the storage variables. Note that the initial state s0 is (0, S0, M0, R0) where S0, M0 and R0 are the initial valuation of the variables defined by init. Furthermore, for all i, (pci+1, Si+1, Mi+1, Ri+1) is the result of executing opcode opi given the state (pci, Si, Mi, Ri) according to the semantic of opi. The semantics of opcodes are shown in Figure 3 in form of execution rules, each of which is associated with a specific opcode. Each rule is composed of multiple conditions above the line and a state change below the line. The state change is read from left to right, i.e., the state on the left changes to the state on the right if the conditions above the line are satisfied. Note that this formal semantics is based on\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/5958/595898cb-36bd-41ca-872a-a1263c84cfef.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">(b) After</div>\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/bcad/bcad1ad8-1027-46ea-ac39-f41758c6d0ad.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">TABLE I: The opcodes according to each rule</div>\nthe recent effort on formalizing Etherum [12]. Most of the rules are self-explanatory and thus we skip the details and refer the readers to [12]. It is worth mentioning how external calls are abstracted in our semantic model. Given an external function call (i.e., opcode CALL), the execution temporarily switches to an execution of the invoked contract. The result of the external call, abstracted as res, is pushed to the stack.\n# B. Symbolic Semantics\nIn order to define our problem, we must define the kinds of vulnerabilities that we focus on. Intuitively, we say that a smart contract suffers from certain vulnerability if there exists an execution of the smart contract that satisfies certain constraints. In the following, we extend the concrete traces to\n(pc, S, M, R) \u21dd\u25a1STOP\nS1, x = S.pop()\n(pc, S, M, R) \u21dd(pc + 1, S1, M, R) POP\nS1, x = S.pop() z = op(x) S2 = S1.push(z)\n(pc, S, M, R) \u21dd(pc + 1, S2, M, R)\nUNARY-OP\nS1, x = S.pop()\nS2, y = S1.pop()\nz = op(x, y)\nS3 = S2.push(z)\n(pc, S, M, R, pc) \u21dd(pc + 1, S3, M, R, pc + 1) BINARY-OP\nS1, x = S.pop() S2, y = S1.pop() S3, m = S2.pop()\nz = op(x, y, m)\nS4 = S3.push(z)\n(pc, S, M, R) \u21dd(pc + 1, S4, M, R)\nTERNARY-OP\nS1, p = S.pop() v = M[p] S2 = S1.push(v)\n(pc, S, M, R) \u21dd(pc + 1, S2, M, R)\nMLOAD\nS1, p = S.pop() S2, v = S1.pop() M1 = M[p \u2190v]\n(pc, S, M, R) \u21dd(pc + 1, S2, M1, R)\nMSTORE\nS1, p = S.pop() v = R[p] S2 = S1.push(v)\n(pc, S, M, R) \u21dd(pc + 1, S2, M, R)\nSLOAD\nS1, p = S.pop() S2, v = S1.pop() R1 = R[p \u2190v]\n(pc, S, M, R) \u21dd(pc + 1, S2, M, R1)\nSSTORE\nv = S.get(i) S1 = S.push(v)\n(pc, S, M, R) \u21dd(pc + 1, S1, M, R) DUP-I\nv0 = S.get(0) vi = S.get(i) S1 = S[0 \u2190vi] S2 = S1[i \u2190v0]\n(pc, S, M, R) \u21dd(pc + 1, S2, M, R)\nSWAP-I\nS1, lbl = S.pop() S2, c = S1.pop() c \u0338= 0\n(pc, S, M, R) \u21dd(lbl, S2, M, R)\nJUMPI-T\nS1, lbl = S.pop() S2, c = S1.pop() c = 0\n(pc, S, M, R) \u21dd(pc + 1, S2, M, R)\nJUMPI-F\nS1, lbl = S.pop()\n(pc, S, M, R) \u21dd(lbl, S1, M, R) JUMP\nres = call() S1 = S.push(res)\n(pc, S, M, R) \u21dd(pc + 1, S1, M, R) CALL\nS1, p = S.pop() S2, n = S1.pop() v = sha3(M[p, p + n]) S3 = S2.push(v)\n(pc, S, M, R) \u21dd(pc + 1, S3, M, R)\nSHA3\nig. 3: Operational semantics of Ethereum opcodes. pop, push, and get are self-explanatory stack operations. m[p \u2190v] enote an operations which returns the same stack/mapping as m except that the value of position/key p is changed to v. Rule UNARY-OP (BINARY-OP, TERNARY-OP) applies to all unary (binary, ternary) operations; rule DUP-I, applies to all uplicate operations; and rule SWAP-I applies to all swap operations.\ndefine symbolic traces of a smart contract so that we can define whether a symbolic trace suffers from certain vulnerability. To define symbolic traces, we first extend the concrete values to symbolic values. Formally, a symbolic value has the form of op(operand0, \u00b7 \u00b7 \u00b7 , operandn) where op is an opcode and operand0, \u00b7 \u00b7 \u00b7 , operandn are the operands. Each operand may be a concrete value (e.g., an integer number or an address) or a symbolic value. Note that if all operands of an opcode are concrete values, the symbolic value is a concrete value as well, i.e., the result of applying op to the concrete operands. For instance, ADD(5,6) is 11. Otherwise, the value is symbolic. One exception is that if op is MLOAD or SLOAD, the result is symbolic even if the operands are concrete, as it is not trivial to maintain the concrete content of the memory or storage. For instance, loading a value from address 0x00 from the storage results in the symbolic value SLOAD(0x00) and increasing the value at storage address 0x00 by 6 results in a symbolic value ADD(SLOAD(0x00),0x06). For another instance, the result of symbolically executing SHA3(n,p) is SHA3(MLOAD(n,p)), i.e., the SHA3 hash of the value located from address n to n + p in the memory. With the above, a symbolic trace is an alternating sequence of states and opcodes \u27e8s0, op0, s1, op1, \u00b7 \u00b7 \u00b7 \u27e9such that each state si is of the form (pci, Ss i , M s i , Rs i ) where pci is the program counter; Ss i , M s i and Rs i are the valuations of stack, memory and storage respectively. Note that Ss i , M s i and Rs i\nmay hold symbolic values as well as concrete ones. For all i, (pci+1, Ss i+1, M s i+1, Rs i+1) is the result of executing opcode opi symbolically given the state (pci, Ss i , M s i , Rs i ). A symbolic execution engine is one which systematically generate the symbolic traces of a smart contract. Note that different from concrete execution, a symbolic execution would generate two traces given an if-statement, one visits the thenbranch and the other visits the else-branch. Furthermore, in the case of an external call (i.e., CALL), instead of switching the current execution context to another smart contract, we can simply use a symbolic value to represent the returned value of the external call.\n# C. Problem Definition\nIntuitively, a vulnerability occurs when there are dependencies from certain critical instructions (e.g., CALL and DELEGATECALL) to a set of specific instructions (e.g., ADD, SUB and SSTORE). Therefore, to define our problem, we first define (control and data) dependency, based on which we define the vulnerabilities.\nDefinition 1 (Control dependency). An opcode opj is said to be control-dependent on opi if there exists an execution from opi to opj such that opj post-dominates all opk in the path from opi to opj (excluding opi) but does not post-dominates opi. An opcode opj is said to post-dominate an opcode opi if all traces starting from opi must go through opj.\nfunction transfer(address _to, uint _value) public { if (_value <= 0) revert(); if (balances[msg.sender] < _value) revert(); if (balances[_to] + _value < balances[_to]) revert(); balances[msg.sender] = balances[msg.sender] - _value; balances[_to] = balances[_to] + _value; }\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/5992/599269b9-8c44-4c93-b45e-03e95f695125.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Fig. 4: An example of control and data dependency</div>\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/5f63/5f63dd9a-8ca0-4e87-b590-8f7f2e73853a.png\" style=\"width: 50%;\"></div>\nFigure 4 illustrates an example of control dependency. The source code is shown on the top and the corresponding control flow graph is shown on the bottom. All variables and their symbolic values are summarized in Table II. The source code presents secure steps to transfer _value tokens from msg.sender account to _to account. There are 3 then-branches followed by 2 storage updates. According to the definition, both SSTORE3 and SSTORE4 are controldependent on ISZERO1, ISZERO2 and GT0. Definition 2 (Data dependency). An opcode opj is said to be data-dependent on opi if there exists a trace which executes opi and subsequently opj such that W(opi) \u2229R(opj) \u0338= \u2205 where R(opj) is a set of locations read by opj; W(opi) is a set of locations written by opi. Figure 4 also illustrates an example of data dependency. Opcode ISZERO1 and ISZERO2 are data-dependent on SSTORE3 and SSTORE4. It has 2 traces, i.e., one trace loads data from storage address SHA3(MLOAD(0x00,0x40)) which is written by SSTORE1 and SSTORE2 in another trace. We say an opcode opj is dependent on opcode opi if opj is control or data dependent on opi or opj is dependent on an opcode opk such that opk is dependent on opi. Vulnerabilities In the following, we define the 4 kinds of vulnerabilities that we focus on, i.e., intra-function and crossfunction reentrancy, dangerous tx.origin and arithmetic over-\nFigure 4 illustrates an example of control dependency. The source code is shown on the top and the corresponding control flow graph is shown on the bottom. All variables and their symbolic values are summarized in Table II. The source code presents secure steps to transfer _value tokens from msg.sender account to _to account. There are 3 then-branches followed by 2 storage updates. According to the definition, both SSTORE3 and SSTORE4 are controldependent on ISZERO1, ISZERO2 and GT0.\nDefinition 2 (Data dependency). An opcode opj is said to be data-dependent on opi if there exists a trace which executes opi and subsequently opj such that W(opi) \u2229R(opj) \u0338= \u2205 where R(opj) is a set of locations read by opj; W(opi) is a set of locations written by opi.\nFigure 4 also illustrates an example of data dependency. Opcode ISZERO1 and ISZERO2 are data-dependent on SSTORE3 and SSTORE4. It has 2 traces, i.e., one trace loads data from storage address SHA3(MLOAD(0x00,0x40)) which is written by SSTORE1 and SSTORE2 in another trace. We say an opcode opj is dependent on opcode opi if opj is control or data dependent on opi or opj is dependent on an opcode opk such that opk is dependent on opi.\nVulnerabilities In the following, we define the 4 kinds of vulnerabilities that we focus on, i.e., intra-function and crossfunction reentrancy, dangerous tx.origin and arithmetic overflow. We remark that while we can certainly detect more kinds of vulnerabilities, it is not always clear how to fix them, i.e., it may not be feasible to know the intended behavior. For example, in the case of fixing an accessible\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/a287/a28789d9-938b-4aa7-aee1-084d69e13605.png\" style=\"width: 50%;\"></div>\nuint numWithdraw = 0; function withdraw() external { uint256 amount = balances[msg.sender]; balances[msg.sender] = 0; (bool ret, ) = msg.sender.call.value(amount)(\"\"); require(ret); numWithdraw ++; }\n<div style=\"text-align: center;\">Fig. 5: A non-reentrant case captured by NW</div>\n# Fig. 5: A non-reentrant case captured by NW\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/5bb0/5bb0e32a-2a99-4631-a2db-4ef15bbf35f4.png\" style=\"width: 50%;\"></div>\nfunction transfer(address to, uint amount) external { if (balances[msg.sender] >= amount) { balances[to] += amount; balances[msg.sender] -= amount;\nfunction withdraw() external nonReentrant { uint256 amount = balances[msg.sender]; (bool ret, ) = msg.sender.call.value(amount)(\"\"); require(ret); balances[msg.sender] = 0;\nFig. 6: An example of cross-function reentrancy vulnerability\nFig. 6: An example of cross-function reentrancy vulnerability\nselfdestruct vulnerability (i.e., a smart contract suffers from this vulnerability if it may be destructed by anyone [5]), we would not know for sure who should have the privilege to access selfdestruct. Let C be a set of critical opcodes which contains CALL, CALLCODE, DELEGATECALL, SELFDESTRUCT, CREATE and CREATE2, i.e., the set of all opcode associated with external calls except STATICCALL. The reason that STATICCALL is excluded from C is that STATICCALL can not update storage variables of the called smart contract and thus is considered to be safe.\nDefinition 3 (Intra-function reentrancy vulnerability). A symbolic trace suffers from intra-function reentrancy vulnerability if it executes an opcode opc \u2208C and subsequently executes an opcode ops in the same function such that ops is SSTORE, and opc depends on ops.\nA smart contract suffers from intra-function reentrancy vulnerability if and only if at least one of its symbolic traces suffers from intra-function reentrancy vulnerability. The above definition is inspired from the no writes after call (NW) property [4]. It is however more accurate than NW, as it avoids violations of NW which are not considered as reentrancy vulnerability. For instance, the function shown in Figure 5 violates NW, although it is not subject to reentrancy vulnerability. It is because the external call msg.sender.call has no dependency on numWithdraw. In other words, there does not exist a dependency from opc to ops. Definition 4 (Cross-function reentrancy vulnerability). A symbolic trace tr suffers from cross-function reentrancy vulnerability if it executes an opcode ops where ops is SSTORE and there exists a symbolic trace tr\u2032 subject to intra-function reentrancy vulnerability such that the opcode opc of tr\u2032\nfunction sendTo(address receiver, uint amount) public { require(tx.origin == owner); receiver.transfer(amount);\nFig. 7: An example of dangerous tx.origin vulnerability\n# Fig. 7: An example of dangerous tx.origin vulnerability\ndepends on ops, and they belong to different functions.\nA smart contract suffers from cross-function reentrancy vulnerability if and only if at least one of its symbolic traces suffers from cross-function reentrancy vulnerability. This vulnerability differs from intra-function reentrancy as the attacker launches an attack through two different functions, which makes it harder to detect. Figure 6 shows an example of cross-function reentrancy. The developer is apparently aware of intra-function reentrancy and thus add the modifier nonReentrant to the function withdraw for preventing reentrancy. However, reentrancy is still possible through function transfer, in which case the attacker is able to double his Ether. That is, the attacker receives Ether at line 10 and illegally transfers it to another account at line 3. Although cross-function reentrancy vulnerabilities were described in Sereum [13] and Consensys [14], our work is the first work to define it formally.\nDefinition 5 (Dangerous tx.origin vulnerability). A symbolic trace suffers from dangerous tx.origin vulnerability if it executes an opcode opc \u2208C which depends on an opcode ORIGIN.\nA smart contract suffers from dangerous tx.origin vulnerability if and only if at least one of its symbolic traces suffer from dangerous tx.origin vulnerability. This vulnerability happens due to an incorrect usage of the global variable tx.origin to authorize an user. An attack happens when a user U sends a transaction to a malicious contract A, which intentionally forwards this transaction to a contract B that relies on a vulnerable authorization check (e.g., require(tx.origin == owner)). Since tx.origin returns the address of U, contract A successfully impersonates U. Figure 7 presents an example suffering from dangerous tx.orgin vulnerability, i.e., a malicious contract may impersonate the owner to withdraw all Ethers.\nDefinition 6 (Arithmetic vulnerability). A symbolic trace suffers from arithmetic vulnerability if it executes an opcode opc in C and opc depends on an opcode opa which is ADD, SUB, MUL or DIV.\nA smart contract suffers from arithmetic vulnerability if and only if at least one of its symbolic traces suffer from arithmetic vulnerability. Intuitively, this vulnerability occurs when an external call data-depends on an arithmetic operation (e.g., addition, subtraction, or multiplication). For instance, the example in the Figure 2 is vulnerable due to the presence of data dependency between the external call at line 17 and the expression weeklyLimit -\ngetThisWeekBurnedAmount() at line 12. Arithmetic vulnerabilities are the target of multiple tools designed for vulnerability detection. In general, arithmetic vulnerability detection using static analysis often results in high false positive. Therefore, tools such as Securify [4] and Ethainter [5] do not support this vulnerability in spite of its importance. In the above definition, we focus on only critical arithmetic operations to reduce false positives. That is, an arithmetic operation is not considered critical as long as the smart contract does not spread its wrong computation to other smart contracts through external calls. For instance, wrong ERC20 token transfer (e.g., CVE-2018-10376) is not critical because it can be reverted by the contract\u2019s admin, whereas wrong Ether transfer is irreversible.\nProblem definition Our problem is then defined as follows. Given a smart contract S, construct a smart contract T such hat T satisfies the following. \u2022 Soundness: T is free of any of the above vulnerabilities. \u2022 Preciseness: For every symbolic trace tr of S, if tr does not suffer from any of the vulnerabilities, there exists a symbolic trace tr\u2032 in T which, given the same inputs, produces the same outputs and states. \u2022 Efficiency: T\u2019s execution speed and gas consumption are minimally different from those of S.\nNote that the first two are about the correctness of construction, whereas the last one is about the performance in terms of computation and gas overhead.\nIV. DETAILED APPROACH\nIn this section, we present the details of our approach. The key challenge is to precisely identify where vulnerabilities might arise and fix them accordingly. Note that precisely identifying control/data-dependency is a prerequisite for precisely identifying vulnerabilities. One approach to identify vulnerabilities is through static analysis based on over-approximation. For instance, multiple existing tools (e.g., Securify [4] and Ethainter [5]) over-approximate Etherum semantics using rewriting rules and leverage rewriting systems such as Datalog to identify vulnerabilities through critical pattern matching. While useful (and typically efficient) in detecting vulnerabilities, such approaches are not ideal for our purpose for multiple reasons. First, there are often many false alarms as they perform abstract interpretation locally (i.e., context/path-insensitive analysis). In our setting, once a vulnerability is identified, we fix it by introducing additional runtime checks. False alarms thus translate to runtime overhead in terms of both time and gas. Second, existing approaches are often incomplete, i.e., not all dependencies are captured. For instance, Securify ignores data dependency through storage variables, i.e., the dependency due to SSTORE(c,b) is lost if c is not a constant, whereas Ethainter ignores control dependency completely. Thirdly, rewriting systems such as Datalog may terminate without any result, in which case the analysis result may not be sound. Therefore, in our work, we\n<div style=\"text-align: center;\">Algorithm 1: sGuard</div>\nAlgorithm 1: sGuard\n1 establish a bound for each loop;\n2 enumerate symbolic traces Tr;\n3 foreach trace tr in Tr do\n4\nlet dp \u2190dependency(tr);\n5\nfixReentrancy(tr, dp);\n6\nfixTxOriginAndArithemic(tr, dp);\npropose an algorithm which covers all dependencies with high precision and always terminates with the correct result. The details of our algorithm is shown in Algorithm 1. From a high-level point of view, it works as follows. First, symbolic traces are systematically enumerated, up to certain threshold number of iterations for each loop. Second, each symbolic trace is checked to see whether it is subject to certain vulnerability according to our definitions. Lastly, the corresponding source code of the vulnerability is identified based on the AST and fixed. In the following, we present details of each step one-by-one.\n# A. Enumerating Symbolic Traces\nNote that our definitions of vulnerabilities are based on symbolic traces. Thus, in this first step, we set out to collect a set of symbolic traces Tr. As defined in Section III-B, a symbolic trace is a sequence of the form \u27e8s0, op0, \u00b7 \u00b7 \u00b7 , sn, opn, sn+1\u27e9. In the following, we focus on symbolic traces that are maximum, i.e., the last opcode opn is either REVERT, INVALID, SELFDESTRUCT, RETURN, or STOP. Systematically generating the maximum symbolic traces is straightforward in the absence of loops, i.e., we simply apply the symbolic semantic rules iteratively until it terminates. In the presence of loops, however, as the condition to exit the loop is often symbolic, this procedure would not terminate. This is a well-known problem for symbolic execution and the remedy is typically to bound the number of iterations heuristically. Such an approach however does not work in our setting, since we must identify all data/control dependency to identify all potential vulnerabilities. In the following, we establish a bound on the number of iterations on the loops which we prove is sufficient for identifying the vulnerabilities that we focus on. Given a smart contract S = (V ar, init, N, i, E), a loop is in general a strongly connected component in S. Thanks to structural programming, we can always identify the loop heads, i.e., the control location where a while-loop starts or a recursive function is invoked. In the following, we associate each location n \u2208N with a bound, denoted as bound(n). If n is a loop head, bound(n) intuitively means how many times n has to be visited in at least one of symbolic traces we collect. If n is not part of any strongly connected component, we have bound(n) = 1. Otherwise, bound(n) is defined as follows. \u2022 If (n, opn, n\u2032) \u2208E and n\u2032 is the loop head, bound(n) = 0 if opn is not an assignment; otherwise bound(n) = 1. \u2022 If (n, opn, n\u2032) \u2208E, n\u2032 is not the loop head and there is no m such that (n, opn, m) \u2208E, i.e., n is not branching,\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/9a6b/9a6b3c39-3f72-4ee7-867b-daf3385dd380.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Fig. 8: An example on how the bound(n) is computed</div>\n<div style=\"text-align: center;\">Fig. 8: An example on how the bound(n) is computed</div>\nbound(n) = bound(n\u2032) if opn is not an assignment; otherwise bound(n) = bound(n\u2032) + 1. \u2022 If (n, opn, m0) \u2208E and (n, opn, m1) \u2208E, i.e., n is branching, bound(n) = bound(m1) + bound(m2).\nIntuitively, the bound of a loop head is computed based on the number of branching statements and assignment statements inside the loop. That is, the bound of a loop head n can be computed by traversing the CFG in the reverse order, i.e., from the exiting nodes of the loop to n. Every execution path maintains a bound, which equals to the number of assignment statements in that path. If two execution paths meet at a branching statement then the new bound is set to the sum of their bounds. In our implementation, the bounds for every node n \u2208N are statically computed using a fixed-point algorithm, with a complexity of O((#N)2) where #N is the number of nodes. Once the bounds are computed, we systematically enumerate all maximum symbolic traces such that each loop head n is visited at most bound(n) times. It is straightforward to see that this procedure always terminates and returns a finite set of symbolic traces. Example IV.1. In the following, we illustrate how bound(x < 100) is computed. The example is shown in the Figure 8 where the graph on the right represents the source code on the left (a.k.a. control flow graph which can be constructed using existing approaches [15]). Assignment statements are highlighted in blue. There is a total of 3 paths P1, P2, P3 in the whileloop, and they visit 5 assignment statements. Since we follow both branches of an if-statement, there exists a symbolic trace tr containing P1, P2, P3 regardless of the order. Trace tr is of the form \u27e8\u00b7 \u00b7 \u00b7 , opi, \u00b7 \u00b7 \u00b7 , opj, \u00b7 \u00b7 \u00b7 , opk, \u00b7 \u00b7 \u00b7 , op\u2032 i, \u00b7 \u00b7 \u00b7 \u27e9where opi and op\u2032 i are executed opcodes of the loop head x < 100; opj is mapped to y < 100 and opk is mapped to z < 100. There are 5 assignment statements between opi and op\u2032 i and the bound of the loop head is 5. Note that the number of assignment statements in the example is the number of SWAPs appeared in between opi and op\u2032 i. The following establishes the soundness of our approach,\nIntuitively, the bound of a loop head is computed based on the number of branching statements and assignment statements inside the loop. That is, the bound of a loop head n can be computed by traversing the CFG in the reverse order, i.e., from the exiting nodes of the loop to n. Every execution path maintains a bound, which equals to the number of assignment statements in that path. If two execution paths meet at a branching statement then the new bound is set to the sum of their bounds. In our implementation, the bounds for every node n \u2208N are statically computed using a fixed-point algorithm, with a complexity of O((#N)2) where #N is the number of nodes. Once the bounds are computed, we systematically enumerate all maximum symbolic traces such that each loop head n is visited at most bound(n) times. It is straightforward to see that this procedure always terminates and returns a finite set of symbolic traces.\nExample IV.1. In the following, we illustrate how bound(x < 100) is computed. The example is shown in the Figure 8 where the graph on the right represents the source code on the left (a.k.a. control flow graph which can be constructed using existing approaches [15]). Assignment statements are highlighted in blue. There is a total of 3 paths P1, P2, P3 in the whileloop, and they visit 5 assignment statements. Since we follow both branches of an if-statement, there exists a symbolic trace tr containing P1, P2, P3 regardless of the order. Trace tr is of the form \u27e8\u00b7 \u00b7 \u00b7 , opi, \u00b7 \u00b7 \u00b7 , opj, \u00b7 \u00b7 \u00b7 , opk, \u00b7 \u00b7 \u00b7 , op\u2032 i, \u00b7 \u00b7 \u00b7 \u27e9where opi and op\u2032 i are executed opcodes of the loop head x < 100; opj is mapped to y < 100 and opk is mapped to z < 100. There are 5 assignment statements between opi and op\u2032 i and the bound of the loop head is 5. Note that the number of assignment statements in the example is the number of SWAPs appeared in between opi and op\u2032 i. The following establishes the soundness of our approach,\ni.e., using the bounds, we are guaranteed to never miss any of the 4 kinds of vulnerabilities that we focus on.\ni.e., using the bounds, we are guaranteed to never miss any of the 4 kinds of vulnerabilities that we focus on. Lemma 1. Given a smart contract, if there exists a symbolic trace which suffers from intra-function reentrancy vulnerability (or cross-function reentrancy, or dangerous tx.origin, or arithmetic vulnerability), there must be one in Tr.\nLemma 1. Given a smart contract, if there exists a symbolic trace which suffers from intra-function reentrancy vulnerability (or cross-function reentrancy, or dangerous tx.origin, or arithmetic vulnerability), there must be one in Tr.\narithmetic vulnerability), there must be one in Tr. We sketch the proof in the following. All vulnerabilities in Section III are defined based on control/data dependency between opcodes. That means we always have a vulnerable trace, if there is, one as long as the set of symbolic traces we collect exhibit all possible dependency between opcodes. To see that all dependencies are exhibited in the traces we collect, we distinguish two cases. All control dependency between opcodes are identified as long as all possible branches in the smart contract are executed. This condition is satisfied based on the way we collect traces in Tr. This argument applies to data dependency between opcodes which do not belong to any loop as well. Next, we consider the data dependency between opcodes inside a loop. Note that with each loop iteration, there are two possible cases: no new data dependency is identified (i.e., the data dependency reaches fixed point) or at least 1 new dependency is identified. If the loop contains n assignments, in the worst case, all of these opcodes depend on each other and we need a trace with n iterations to identify all of them. Based on how we compute the bound for the loop heads, the trace is guaranteed to be in Tr. Thus, we establish that the above lemma is proved. It is well-known that symbolic execution engines may suffer from the path explosion problem. SGUARD is not immune as well, i.e., the number of symbolic paths explored by SGUARD is in general exponential in the loop bounds. Existing symbolic execution engines address the problem by allowing users to configure a bound K which is the maximum number of times any loop is unrolled. In practice, it is highly nontrivial to know what K value should be used. Given the impact of K, i.e., the number of paths are exponential in the value of K, existing tools often set K to be a small number by default, such as 3 in sCompile [16] and 5 in Manticore [17]; and it is unlikely that users would configure it differently. While having a large K leads to the path explosion problem, having a small K leads to false negatives. For instance, with K = 3, the overflow vulnerabilities due to the two expressions m = n+1, n = x + 1 in the Figure 8 would be missed as this bound is not sufficient to infer dependency from variable x on m and n. In contrast, SGUARD automatically identifies a loop bound for each loop which guarantees that no vulnerabilities are missed. In Section V, we empirically evaluate whether the path explosion problem occurs often in practice.\n# B. Dependency Analysis\nGiven the set of symbolic traces Tr, we then identify dependency between all opcodes in every symbolic trace in Tr, with the aim to check whether the trace suffers from any vulnerability. In the following, we present our approach to capture dependency from symbolic traces.\n<div style=\"text-align: center;\">Algorithm 2: build CFG</div>\nAlgorithm 2: build CFG\n1 let edges \u2190\u2205;\n2 foreach trace tr in Tr do\n3\nforeach opi, pci in tr do\n4\nif opi = JUMPI then\n5\nlet edge \u2190(pci, pci+1) ;\n6\nadd edge to edges;\n7 return edges;\nAlgorithm 3: fd(tr, opi)\n1 let opcodes \u2190\u2205;\n2 foreach opj that taints opi do\n3\nif opj is an assignment opcode then\n4\nadd opj to opcodes ;\n5\nif opj reads data from memory which was written by an\nassignment opcode opk then\n6\nadd opk to opcodes ;\n7\nadd fd(tr, opk) to opcodes;\n8\nif opj reads data from storage which was written by an\nassignment opcode opk then\n9\nif opk is not visited then\n10\nadd opk to opcodes;\n11\nforeach trace tr\u2032 contains opk do\n12\nadd fd(tr\u2032, opk) to opcodes;\n13 return opcodes;\nGiven a symbolic trace Tr, an opcode opi, we aim to identify a set of opcodes dp in Tr such that: (soundness) for all opk in dp, opi depends on opk; and (completeness) for all opk in Tr, if opi depends on opk then opk \u2208dp. To identify dp, we systematically identify all opcodes that opi is controldependent on in Tr, all opcodes that opi is data-dependent on in Tr and then compute their transitive closure. To systematically identify all control-dependency, we build a control flow graph (CFG) from Tr (as shown in Algorithm 2). Afterwards, we build a post-dominator tree based on the CFG using a workList algorithm [18]. The result is a set PD(opi) which are the opcodes that post-dominate opi. The set of opcodes which opi control-depend on in the symbolic trace tr is then systematically identified as the following.\n# { op | op \u2208tr; \u2203(opm, opn) \u2208succs(op), opi \u2208PD(opm), opi /\u2208PD(opn) }\n op | op \u2208tr; \u2203(opm, opn) \u2208succs(op), opi \u2208PD(opm), opi /\u2208PD(opn) }\n \u2208 opi \u2208PD(opm), opi /\u2208PD(opn) }\nwhere succs(op) returns successors of op according to CFG. Identifying the set of opcodes which opi is data-dependent on is more complicated. Data dependency arises from 3 data sources, i.e., stack, memory and storage. In the following, we present our over-approximation based algorithm which traces data-flow on these data sources in order to capture data dependency. Although an opcode typically reads and writes data to the same data source, an opcode may write data to a different data source in some cases. That makes data-flow tracing complicated, i.e., data flows from stack to memory\nthrough MSTORE, memory to stack through MLOAD, stack to storage through SSTORE and storage to stack through SLOAD. Since only assignment opcodes (i.e., SWAP, MSTORE, and SSTORE) create data dependency, we thus design an algorithm to identify data-dependency based on the assignment opcodes in tr. The details are presented in the Algorithm 3, which takes a symbolic trace tr and opcode opi as input and returns a set of opcodes that opi is data-dependent on. Algorithm 3 systematically identifies those opcodes in tr which taint opi. An opcode opj is said to taint another opcode opi if opi reads data from stack indexes written by opj, or there exists an opcode opt such that opj taints opt and opt taints opi. For each opj that taints opi, there are three possible dependency cases. \u2022 Stack dependency: opi is data-dependent on opj if opj is an assignment opcode (i.e., SWAP) (lines 3-4) \u2022 Memory dependency: opj is data-dependent on opk if opj reads data from memory which was written by the assignment opcode opk (i.e., MSTORE) (lines 5-7) \u2022 Storage dependency: opj is data-dependent on opk if opj reads data from storage which was written by the assignment opcode opk (i.e., SSTORE) (lines 8-12) Note that the algorithm is recursive, i.e., if opk is added into the set of opcodes to be returned, a recursive call is made to further identify those opcode that opk is data-dependent on (lines 7 and 12). Further note that since storage is globally accessible, the analysis may be cross different traces in Tr (line 11). Algorithm 3 in general over-approximates. For instance, because memory and storage addresses are likely symbolic values, a reading address and a writing address are often incomparable, in which case we conservatively assume that the addresses may be the same. In other words, R(opj) \u2229 W(opk) \u0338= \u2205is true if either R(opj) or W(opk) is a symbolic address.\n# C. Fixing the Smart Contract\nOnce the dependencies are identified, we check whether each symbolic tr suffers from any of the vulnerabilities defined in Section III-C and then fix the smart contract accordingly. In general, a smart contract is fixed as follows. Given a vulnerable trace tr, according to our definitions in Section III-C, there must be an external call opc \u2208C in tr. Furthermore, there must be some other opcode op that opc depends on which together makes tr vulnerable (e.g., if op is SSTORE, tr suffers from reentrancy vulnerability; if op is ADD, SUB, MUL or DIV, tr suffers from arithmetic vulnerability). The idea is to introduce runtime checks right before op so as to prevent the vulnerability. According to the type of vulnerability, the runtime checks are injected as follows. \u2022 To prevent intra-function reentrancy vulnerability, we add a modifier nonReentrant to the function F containing op. Note that the nonReentrant modifier works as a mutex which blocks an attacker from re-entering F. To prevent cross-function reentrancy vulnerability, we add\nthe modifier nonReentrant to the function containing op. The details of the fixing algorithm are presented in Algorithm 4 which takes a vulnerable trace tr and the dependency relation dp as inputs. \u2022 To fix dangerous tx.origin vulnerability, we replace op (i.e., ORIGIN) with msg.sender which returns address of the immediate account that invokes the function. \u2022 To fix arithmetic vulnerability, we replace op (i.e., ADD, SUB, MUL, DIV, or EXP) with a call to a safe math function which checks for overflow/underflow before performing the arithmetic operation.\nthe modifier nonReentrant to the function containing op. The details of the fixing algorithm are presented in Algorithm 4 which takes a vulnerable trace tr and the dependency relation dp as inputs. \u2022 To fix dangerous tx.origin vulnerability, we replace op (i.e., ORIGIN) with msg.sender which returns address of the immediate account that invokes the function. \u2022 To fix arithmetic vulnerability, we replace op (i.e., ADD, SUB, MUL, DIV, or EXP) with a call to a safe math function which checks for overflow/underflow before performing the arithmetic operation.\nNote that in the case of reentrancy vulnerability and arithmetic vulnerability, if a runtime check fails (e.g., assert(x > y) which is introduced before x - y fails), the transaction reverts immediately and thus the vulnerability is prevent, although the gas spent on executing the transaction so far would be wasted. Further note while Algorithm 4 is applied to every vulnerable trace, the same fix (e.g., introducing nonReentrant on the same function) is applied once. We refer the readers to Section II-C for examples on how smart contracts are fixed. The following establishes the soundness of our approach.\nTheorem 1. A smart contract fixed by Algorithm 1 is free of intra-function reentrancy vulnerability, cross-function reentrancy vulnerability, dangerous tx.origin vulnerability, and arithmetic vulnerability.\n\nThe proof of the theorem is sketched as follows. According to the Lemma 1, given a smart contract S, if there are vulnerable traces, at least one of them is identified by SGUARD. Given how SGUARD fixes each kind of vulnerability, fixing all vulnerable traces in Tr implies that all vulnerable traces are fixed in S. We acknowledge that our approach does not achieve the preciseness as discussed in Section III-C. That is, a trace which is not vulnerable may be affected by the fixes if it shares some opcodes with the vulnerable traces. For instance, an arithmetic opcode which is shared by a vulnerable trace and a non-vulnerable trace may be replaced with a safe version that checks for overflow. The non-vulnerable trace would revert in the case of an overflow even though the overflow might be benign. Such in-preciseness is an overhead to pay for security in our setting, along with the time and gas overhead. In Section V, we empirically evaluate that the overhead and show that they are negligible.\n# V. IMPLEMENTATION AND EVALUATION\nIn this section, we present implementation details of SGUARD and then evaluate it with multiple experiments.\n# A. Implementation\nSGUARD is implemented with around 3K lines of Node.js code. It is publicly available at GitHub1. It uses a locally installed compiler to compile a user-provided contract into a\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/f071/f071b440-edc0-42e8-8200-2f5eef5b5e94.png\" style=\"width: 50%;\"></div>\nAlgorithm 4: fixReentrancy(tr, dp)\n1 let tr \u2190\u27e8s0, op0, \u00b7 \u00b7 \u00b7 , sn, opn, sn+1\u27e9;\n2 foreach i in 0..n do\n3\nif opi \u2208C then\n4\nforeach j in i + 1..n do\n5\nif opj is SSTORE and opi depends on opj\naccording to dp then\n/* Fix intra-function reentrancy\n*/\n6\nadd modifier nonReentrant to the\nfunction containing opi;\n/* Fix cross-function reentrancy\n*/\n7\nforeach ops that opi depends on according\nto dp do\n8\nif ops is SSTORE then\n9\nadd modifier nonReentrant to\nthe function containing ops;\n<div style=\"text-align: center;\">Algorithm 4: fixReentrancy(tr, dp)</div>\nJSON file containing the bytecode, source-map and abstract syntax tree (AST). The bytecode is used for detecting vulnerability, whereas the source-map and AST are used for fixing the smart contract at the source code level. In general, a sourcemap links an opcode to a statement and a statement to a node in an AST. Given a node in an AST, SGUARD then has the complete control on how to fix the smart contract. In addition to what is discussed in previous sections, the actual implementation of SGUARD has to deal with multiple complications. First, Solidity allows developers to interleave their codes with inline-assembly (i.e., a language using EVM machine opcodes). This allows fine-grained controls, as well as opens a door for hard-to-discover vulnerabilities (e.g., arithmetic vulnerabilities). We have considered fixing vulnerabilities with SGUARD (which is possible with efforts). However, it is not trivial for a developer to evaluate the correctness of our fixes as SGUARD would introduce opcodes into the inline-assembly. We do believe that any modification of the source code should be transparent to the users, and thus decide not to support fixing vulnerabilities inside inlineassembly. Second, SGUARD employs multiple heuristics to avoid useless fixes. For instance, given an arithmetic expression whose operands are concrete values (which may be the case of the expression is independent of user-inputs), SGUARD would not replace it with a function from safe math even if it is a part of a vulnerable trace. Furthermore, since the number of iterations to be unfolded for each loop depends on the number of assignment statements inside the loop, SGUARD identifies a number of cases where certain assignments can be safely ignored without sacrificing the soundness of our method. In particular, although we count SSTORE, MSTORE or SWAP as assignment statements in general, they are not in the following exceptional cases.\n\u2022 A SWAP is not counted if it is not mapped to an assignment statement according source-map; \u2022 An assignment statement is not counted if its right-hand-\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/d8c7/d8c776fc-e90b-4763-94ab-69c0ec04b383.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Fig. 9: Loop bounds computed by SGUARD</div>\nside expression is a constant; \u2022 An assignment statement is not counted if its left-handside expression is a storage variable (since dependency due to the storage variables is analyzed regardless of execution order). In addition, SGUARD implements a strategy to estimate the value of memory pointers. A memory variable is always placed at a free memory pointer and it is never freed. However, the free pointer is often a symbolic value. That increases the complexity. To simplify the problem without missing dependency, SGUARD estimates the value of the free pointer ptr if it is originally a symbolic value. That is, if the memory size of a variable is only known at run-time, we assume that it occupies 10 memory slots. The free pointer is calculated as ptrn+1 = 10 \u00d7 0x20 + ptrn where ptrn is the previous free pointer. If memory overlap occurs due to this assumption, additional dependencies are introduced, which may introduce false alarms, but never false negatives. Lastly, SGUARD allows user to provide additional guide to generate contract-specific fixes. For instance, users are allowed to declare certain variables are critical variables so that it will be protected even if there is no dependency between the variable and external calls.\n# B. Evaluation\nIn the following, we evaluate SGUARD through multiple experiments to answer the following research questions (RQ). Our test subjects include 5000 contracts whose verified source code are collected from EtherScan [19]. This includes all the contracts after we filter 5000 incompilable contracts which contain invalid syntax or are implemented based on previous versions of Solidity (e.g., version 0.3.x). We systematically apply SGUARD to each contract. The timeout is set to be 5 minutes for each contract. Our experiments are conducted on with 10 concurrent processes and takes 6 hours to complete. All experiment results reported below are obtained on an Ubuntu 16.04.6 LTS machine with Intel(R) Core(TM) i9-9900 CPU @ 3.10GHz and 64GB of memory.\nRQ1: How bad is the path explosion problem? Out of the 5000 contract, SGUARD times out on 1767 (i.e., 35.34%) contracts and successfully finish analyzing and fixing the remaining contracts within the time limit. Among them, 1590 contracts\nare deemed safe (i.e., they do not contain any external calls) and no fix is applied. The remaining 1643 contracts are fixed in one way or another. We note that 38 of the fixed contracts are incompilable. There are two reasons. First, the contract sourcemap may refer to invalid code locations if the corresponding smart contract has special characters (e.g., copyright and heart emoji). This turns out to be a bug of the Solidity compiler and has been reported. Second, the formats of AST across many solidity versions are slightly different, e.g., version 0.6.3 declares a function which is implemented with attribute implemented while the attribute is absent in version 0.4.26. Note that the compiler version declared by pragma keyword is not supported in the experiment setup as SGUARD uses a list of compilers provided by solc-select [20]. In the end, we experiment with 1605 smart contracts and report the findings. Recall that the number of paths explored largely depend on the loop bounds. To understand why SGUARD times out on 35.34% of the contracts, we record the maximum loop bound for each of the 5000 smart contracts. Figure 9 summarizes the distribution of the loop bounds. From the figure, we observe that for 80% of the contracts, the loop bounds are no more than 17. The loop bounds of the remaining 20% contracts however vary quite a lot, e.g., with a maximum of 390. The average loop bound is 15, which shows that the default bounds in existing symbolic execution engines could be indeed insufficient.\nRQ2: Is SGUARD capable of pinpointing where fixes should be applied? This question asks whether SGUARD is capable of precisely identifying where the fixes should be applied. Recall that SGUARD determines where to apply the fix based on the result of the dependency analysis, i.e., a precise dependency analysis would automatically imply that the fix will be applied at the right place. Furthermore, control dependency is straightforward and thus the answer to this question relies on the preciseness of the data dependency analysis. Data dependency analysis in Algorithm 3 may introduce impreciseness (i.e., over-approximation) at lines 5 and 8 when checking the intersection of reading/writing addresses. In SGUARD, the checking is implemented by transforming each symbolic address to a range of concrete addresses using the base address and the maximum offset. The over-approximation is only applied if at least one symbolic address is failed to transform due to nonstandard access patterns. If both symbolic addresses are successfully transformed, we can use the ranges of concrete addresses to precisely check the intersection and there is no over-approximation. Thus, we can measure the over-approximation of our analysis by reporting the number of failed and successful address transformations. Figure 10 summarizes our experiment results where each bar represents the number of failed and successful address transformations regarding the memory (i.e., MLOAD, MSTORE) and storage (i.e., SLOAD, SSTORE) opcodes. From the results, we observe that the percentage of successful transformations are 99.99%, 85.58%, 99.98%, and 98.43% for SLOAD, MLOAD, SSTORE, and MSTORE respectively. MLOAD has\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/861f/861fe5d0-446c-4238-8ac4-a90a715cd214.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Fig. 10: Memory and storage address transformations</div>\nthe worst accuracy among the four opcodes. This is mainly because some opcodes (e.g., CALL, and CALLCODE) may load different sizes of data on the memory. In this case, the MLOAD may depend on multiple MSTOREs, and it becomes even harder considering the size of loaded data is a symbolic value. Therefore, we simplify the analysis by returning true (hence over-approximates) if the size of loaded data is not 0x20, a memory allocation unit size.\nthe worst accuracy among the four opcodes. This is mainly because some opcodes (e.g., CALL, and CALLCODE) may load different sizes of data on the memory. In this case, the MLOAD may depend on multiple MSTOREs, and it becomes even harder considering the size of loaded data is a symbolic value. Therefore, we simplify the analysis by returning true (hence over-approximates) if the size of loaded data is not 0x20, a memory allocation unit size. RQ3: What is the runtime overhead of SGUARD\u2019s fixes? This question is designed to measure the runtime overhead of SGUARD\u2019s fixes. Note that runtime overhead is often considered as a determining factor on whether to adopt additional checks at runtime. For instance, the C programming language has been refusing to introduce runtime overflow checks due to concerns on the runtime overhead, although many argue that it would reduce a significant number of vulnerabilities. The same question must thus be asked about SGUARD. Furthermore, runtime checks in smart contracts introduce not only time overhead but also gas overhead, i.e., gas must be paid for every additional check that is executed. Considering the huge number of transactions (e.g., 1.2 million daily transactions are reported on the Ethereum network [21]), each additional check may potential translate to large financial burden. To answer the question, we measure additional gas and computational time that users pay to deploy and execute the fixed contract in comparison with the original contract. That is, we download transactions from the Ethereum network and replicate them on our local network, and compare the gas/time consumption of the transactions. Among the 1605 smart contracts, 23 contracts are not considered as they are created internally. In the end, we replicate 6762 transactions of 1582 fixed contracts. We limit the number of transactions for each contract to a maximum of 10 such that the results are not biased towards those active contracts that have a huge number of transactions. Since our local setup is unable to completely simulate the actual Ethereum network (e.g., the block number and timestamps are different), a replicated transaction thus may end up being a revert. In our experiments, 3548 (52.47%) transactions execute successfully and thus we report the results based on them. A close investigation shows that the remaining transactions fail due to the difference between our private\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/d646/d646d574-4433-4be3-abd4-e64cd7831863.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Fig. 11: Overhead of fixed contracts</div>\nInstruction\nSGUARD\nBC\nBC/SGUARD\nADD\n576\n2245\n3.9\u00d7\nSUB\n394\n2125\n5.39\u00d7\nMUL\n198\n1423\n7.19\u00d7\nDIV\n179\n1508\n8.42\u00d7\n<div style=\"text-align: center;\">TABLE III: Total number of bound checks</div>\nnetwork and the Ethereum network except 1 transaction, which fails because the size of the bytecode of the fixed contract exceeds the size limit [22]. Figure 11 summarizes our results. The x-axis and y-axis show the time overhead and gas overhead of each transaction respectively. The data shows that the highest gas overhead is 42% while the lowest gas overhead is 0%. On average, users have to pay extra 0.79% gas to execute a transaction on the fixed contract. The highest and lowest time overhead are 455% and 0% respectively. On average, users have to wait extra 14.79% time on a transaction. Based on the result, we believe that the overhead of fixing smart contracts using SGUARD is manageable, considering its security guarantee. For arithmetic vulnerabilities, there is a simplistic fix, i.e., add a check to every arithmetic operation. To see the difference between SGUARD and such an approach, we conduct an additional experiment on the set of smart contracts that we successfully fixed (i.e., 1605 of them). We record the total number of bound checks added to the 4 arithmetic instructions (i.e., ADD, SUB, MUL and DIV) by SGUARD and the simplistic approach. The results are shown in Table III, where column BC shows the number for the simplistic approach. We observe that on average SGUARD introduces 5.42 times less bound checks than the simplistic approach. Since each bound check costs gas and time when executing a transaction, we consider such a reduction to be welcomed.\nRQ4: How long does SGUARD take to fix a smart contract? This question asks about the efficiency of SGUARD itself. We measure the execution time of SGUARD by recording time spending to fix each smart contract. Naturally, a more complicated contract (e.g., with more symbolic traces) takes more time to fix. Thus, we show how execution time varies for different contracts. Figure 12 summarizes our results, where each bar represents 10% of smart contracts and y-axis shows the execution time in seconds. The contracts are sorted according to the execution time. From the figure, we observe\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/84f8/84f8df59-e0f5-492f-8867-368eddc8b534.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Fig. 12: SGUARD execution time</div>\nNo.\nName\n#RE\n#AR\n#TX\nSymbolic traces\n#1\nUSDT\n\u0017\n\u0017\n\u0017\n265\n#2\nLINK\n\u0017\n\u0017\n\u0017\n291\n#3\nBNB\n\u0017\n\u0017\n\u0017\n128\n#4\nHT\n\u0017\n\u0017\n\u0017\n0\n#5\nBAT\n\u0017\n\u2713\n\u0017\n128\n#6\nCRO\n\u0017\n\u0017\n\u0017\n401\n#7\nLEND\n\u0017\n\u0017\n\u0017\n281\n#8\nKNC\n\u0017\n\u0017\n\u0017\n443\n#9\nZRX\n\u0017\n\u0017\n\u0017\n0\n#10\nDAI\n\u0017\n\u0017\n\u0017\n0\nTABLE IV: Fixing results on the high profile contracts\nthat 90% of contracts are fixed within 36 seconds. Among the different steps of SGUARD, SGUARD spends most of the time to identify dependency (70.57%) and find vulnerabilities (20.08%). On average, SGUARD takes 15 seconds to analyze and fix a contract.\nManual inspection of results To check the quality of the fix, we run an additional experiment on the top 10 ERC20 tokens in the market. That is, we apply SGUARD to analyze and fix the contracts and then manually inspect the results to check whether the fixed contracts contain any of the vulnerabilities, i.e., whether SGUARD fails to prevent certain vulnerability or whether SGUARD introduce unnecessary runtime checks (which translates to considerable overhead given the huge number of transactions on these contracts). The results are reported in Table IV where column RE (respectively AE and TX) shows whether any reentrancy (respectively arithmetic, and tx.origin) vulnerability is discovered and fixed respectively; and the symbol \u2713and \u0017 denote yes and no respectively. The last column shows the number of symoblic traces explored. We observe that the number of symbolic traces explored for three tokens HT, ZRX and DAI are 0. It is because these contracts contain no external calls and thus SGUARD stops immediately after scanning the bytecode. Among the remaining 7 tokens, six of them (i.e., LINK, BNB, CRO, LEND, KNC, and USDT) are found to be safe and thus no modification is made. One arithmetic vulnerability in the smart contracts BAT is reported and fixed by SGUARD. We confirm that a runtime check is added to prevent the discovered vulnerability. A close investigation however reveals that this vulnerability is unexploitable although it confirms to our definition. This is because the contract already has runtime checks. We further\nmeasure the overhead of the fix by executing 10 transactions obtained from the Ethereum network on the smart contract. The result shows that SGUARD introduces a gas overhead of 18%. Lastly, our manual investigation confirms that all of the contracts are free of the vulnerabilities.\n# VI. RELATED WORK\nTo the best of our knowledge, SGUARD is the first tool that aims to repair smart contracts in a provably correct way. SGUARD is closely related to the many works on automated program repair, which we highlight a few most relevant ones in the following. GenProg [1] applies evolutionary algorithm to search for program repairs. A candidate repair patch is considered successful if the repaired program passes all test cases in the test suite. In [2], Dongsun et al. presented PAR, which improves GenProg by learning fix patterns from existing human-written patches to avoid nonsense patches. In [23], Abadi et al. automatically rewrites binary code to enforce control flow integrity (CFI). In [24], Jeff et al. presented ClearView, which learns invariants from normal behavior of the application, generates patches and observes the execution of patched applications to choose the best patch. While there are many other program repair works, none of them focus on fixing smart contracts in a provably correct way. SGUARD is closely related to the many work on applying static analysis techniques on smart contracts. Securify [4] and Ethainter [5] are approaches which leverage a rewriting system (i.e., Datalog) to identify vulnerabilities through pattern matching. In terms of symoblic execution, in [25], Luu et al. presented the first engine to find potential security bugs in smart contracts. In [26], Krupp and Rossow presented teEther which finds vulnerabilities in smart contracts by focusing on financial transactions. In [27], Nikolic et al. presented MAIAN, which focus on identifying trace-based vulnerabilities through a form of symoblic execution. In [28], Torres et al. presented Osiris which focuses on discovering integer bugs. Unlike these engines, SGUARD not only detects vulnerabilities, but also fixes them automatically. SGUARD is related to some work on verifying and analyzing smart contracts. Zeus [29] is a framework which verifies the correctness and fairness of smart contracts based on LLVM. Bhargavan et al. proposed a framework to verify smart contracts by transforming the source code and the bytecode to an intermediate language called F* [30]. In [31], the author used Isabelle/HOL to verify the Deed contract. In [32], the authors showed that only 40% of smart contracts are trustworthy based on their call graph analysis. In [33], Chen et al. showed that most of the contracts suffer from some gas-cost programming patterns. Finally, SGUARD is remotely related to approaches on testing smart contracts. ContractFuzzer [34] is a fuzzing engine which checks 7 different types of vulnerabilities. sFuzz [15] is another fuzzer which extends ContractFuzzer by using feedback from test cases execution to generate new test cases.\n# VII. CONCLUSION\nVII. CONCLUSION\nIn this work, we propose an approach to fix smart contracts so that they are free of 4 kinds of common vulnerabilities. Our approach uses run-time information and is proved to be sound. The experiment results show the usefulness of our approach, i.e., SGUARD is capable of fixing contracts correctly while introducing only minor overhead. In the future, we intend to improve the performance of SGUARD further with optimization techniques.\n# REFERENCES\n[1] W. Weimer, T. Nguyen, C. Le Goues, and S. Forrest, \u201cAutomatically finding patches using genetic programming,\u201d in Proceedings of the 31st International Conference on Software Engineering, ser. ICSE \u201909, 2009, pp. 364\u2013374. [2] D. Kim, J. Nam, J. Song, and S. Kim, \u201cAutomatic patch generation learned from human-written patches,\u201d in 2013 35th International Conference on Software Engineering (ICSE). IEEE, 2013, pp. 802\u2013811. [3] A. Marginean, J. Bader, S. Chandra, M. Harman, Y. Jia, K. Mao, A. Mols, and A. Scott, \u201cSapfix: Automated end-to-end repair at scale,\u201d in 2019 IEEE/ACM 41st International Conference on Software Engineering: Software Engineering in Practice (ICSE-SEIP). IEEE, 2019, pp. 269\u2013278. [4] P. Tsankov, A. Dan, D. Drachsler-Cohen, A. Gervais, F. Buenzli, and M. Vechev, \u201cSecurify: Practical security analysis of smart contracts,\u201d in Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, 2018, pp. 67\u201382. [5] L. Brent, N. Grech, S. Lagouvardos, B. Scholz, and Y. Smaragdakis, \u201cEthainter: a smart contract security analyzer for composite vulnerabilities.\u201d in PLDI, 2020, pp. 454\u2013469. [6] G. Wood et al., \u201cEthereum: A secure decentralised generalised transaction ledger,\u201d Ethereum project yellow paper, vol. 151, no. 2014, pp. 1\u201332, 2014. [7] RSK. [Online]. Available: https://www.rsk.co/ [8] Hyperledger. [Online]. Available: https://www.hyperledger.org/ [9] A Postmortem on the Parity Multi-Sig Library Self-Destruct. [Online]. Available: https://www.parity.io/ a-postmortem-on-the-parity-multi-sig-library-self-destruct/ [10] Thinking About Smart Contract Security. [Online]. Available: https: //blog.ethereum.org/2016/06/19/thinking-smart-contract-security/ [11] OpenZeppelin. [Online]. Available: https://github.com/OpenZeppelin/ openzeppelin-contracts [12] J. Jiao, S. Kan, S. Lin, D. Sanan, Y. Liu, and J. Sun, \u201cSemantic understanding of smart contracts: Executable operational semantics of solidity,\u201d in 2020 IEEE Symposium on Security and Privacy (SP). Los Alamitos, CA, USA: IEEE Computer Society, may 2020, pp. 1695\u20131712. [Online]. Available: https://doi.ieeecomputersociety.org/10. 1109/SP40000.2020.00066 [13] M. Rodler, W. Li, G. Karame, and L. Davi, \u201cSereum: Protecting existing smart contracts against re-entrancy attacks,\u201d in Proceedings of the Network and Distributed System Security Symposium (NDSS\u201919), 2019. [14] Known Attacks. [Online]. Available: https://consensys.github.io/ smart-contract-best-practices/known attacks/ [15] T. D. Nguyen, L. H. Pham, J. Sun, Y. Lin, and Q. T. Minh, \u201csfuzz: An efficient adaptive fuzzer for solidity smart contracts,\u201d in Proceedings of the 42nd International Conference on Software Engineering (ICSE), 2020, pp. 778\u2013788. [16] J. Chang, B. Gao, H. Xiao, J. Sun, Y. Cai, and Z. Yang, \u201cscompile: Critical path identification and analysis for smart contracts,\u201d in International Conference on Formal Engineering Methods. Springer, 2019, pp. 286\u2013304. [17] M. Mossberg, F. Manzano, E. Hennenfent, A. Groce, G. Grieco, J. Feist, T. Brunson, and A. Dinaburg, \u201cManticore: A user-friendly symbolic execution framework for binaries and smart contracts,\u201d in 2019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE). IEEE, 2019, pp. 1186\u20131189. [18] A worklist algorithm for dominators. [Online]. Available: http: //pages.cs.wisc.edu/\u223cfischer/cs701.f08/lectures/Lecture19.4up.pdf [19] Etherscan. [Online]. Available: https://etherscan.io/ [20] Solc-Select. [Online]. Available: https://github.com/crytic/solc-select\n[21] Ethereum transactions per day. [Online]. Available: https://etherscan.io/ chart/tx [22] EIP-170. [Online]. Available: https://github.com/ethereum/EIPs/blob/ master/EIPS/eip-170.md [23] M. Abadi, M. Budiu, \u00b4U. Erlingsson, and J. Ligatti, \u201cControl-flow integrity principles, implementations, and applications,\u201d ACM Transactions on Information and System Security (TISSEC), vol. 13, no. 1, pp. 1\u201340, 2009. [24] J. H. Perkins, S. Kim, S. Larsen, S. Amarasinghe, J. Bachrach, M. Carbin, C. Pacheco, F. Sherwood, S. Sidiroglou, G. Sullivan et al., \u201cAutomatically patching errors in deployed software,\u201d in Proceedings of the ACM SIGOPS 22nd symposium on Operating systems principles, 2009, pp. 87\u2013102. [25] L. Luu, D.-H. Chu, H. Olickel, P. Saxena, and A. Hobor, \u201cMaking smart contracts smarter,\u201d in Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security. ACM, 2016, pp. 254\u2013269. [26] J. Krupp and C. Rossow, \u201cteether: Gnawing at ethereum to automatically exploit smart contracts,\u201d in 27th {USENIX} Security Symposium ({USENIX} Security 18), 2018, pp. 1317\u20131333. [27] I. Nikoli\u00b4c, A. Kolluri, I. Sergey, P. Saxena, and A. Hobor, \u201cFinding the greedy, prodigal, and suicidal contracts at scale,\u201d in Proceedings of the 34th Annual Computer Security Applications Conference. ACM, 2018, pp. 653\u2013663. [28] C. F. Torres, J. Sch\u00a8utte et al., \u201cOsiris: Hunting for integer bugs in ethereum smart contracts,\u201d in Proceedings of the 34th Annual Computer Security Applications Conference. ACM, 2018, pp. 664\u2013676. [29] S. Kalra, S. Goel, M. Dhawan, and S. Sharma, \u201cZeus: Analyzing safety of smart contracts,\u201d in 25th Annual Network and Distributed System Security Symposium (NDSS\u201918), 2018. [30] K. Bhargavan, A. Delignat-Lavaud, C. Fournet, A. Gollamudi, G. Gonthier, N. Kobeissi, N. Kulatova, A. Rastogi, T. Sibut-Pinote, N. Swamy et al., \u201cFormal verification of smart contracts: Short paper,\u201d in Proceedings of the 2016 ACM Workshop on Programming Languages and Analysis for Security. ACM, 2016, pp. 91\u201396. [31] Y. Hirai, \u201cFormal verification of deed contract in ethereum name service,\u201d November-2016.[Online]. Available: https://yoichihirai. com/deed. pdf, 2016. [32] M. Fr\u00a8owis and R. B\u00a8ohme, \u201cIn code we trust?\u201d in Data Privacy Management, Cryptocurrencies and Blockchain Technology. Springer, 2017, pp. 357\u2013372. [33] T. Chen, X. Li, X. Luo, and X. Zhang, \u201cUnder-optimized smart contracts devour your money,\u201d in 2017 IEEE 24th International Conference on Software Analysis, Evolution and Reengineering (SANER). IEEE, 2017, pp. 442\u2013446. [34] B. Jiang, Y. Liu, and W. K. Chan, \u201cContractf",
    "paper_type": "method",
    "attri": {
        "background": "Smart contracts are distributed, self-enforcing programs executing on top of blockchain networks. They have the potential to revolutionize many industries such as financial institutes and supply chains. However, smart contracts are subject to code-based vulnerabilities, which casts a shadow on its applications. As smart contracts are unpatchable (due to the immutability of blockchain), it is essential that smart contracts are guaranteed to be free of vulnerabilities. Unfortunately, smart contract languages such as Solidity are Turing-complete, which implies that verifying them statically is infeasible. Thus, alternative approaches must be developed to provide the guarantee.",
        "problem": {
            "definition": "The problem is to ensure that smart contracts are free from vulnerabilities before they are deployed, given that existing verification and testing methods do not provide the required guarantees.",
            "key obstacle": "Existing verification methods are often infeasible due to the Turing-completeness of smart contract languages, and testing can only show the presence, not the absence, of vulnerabilities."
        },
        "idea": {
            "intuition": "The idea is inspired by program fixing techniques used for traditional programs and aims to adapt them specifically for smart contracts.",
            "opinion": "SGUARD is proposed as a tool that automatically fixes potentially vulnerable smart contracts by applying runtime verification efficiently.",
            "innovation": "The primary innovation of SGUARD lies in its ability to guarantee the correctness of the fixes and minimize runtime overhead, unlike existing approaches that often suffer from weak specifications."
        },
        "method": {
            "method name": "SGUARD",
            "method abbreviation": "SGUARD",
            "method definition": "SGUARD is an approach that automatically transforms smart contracts to eliminate vulnerabilities by applying specific fixing patterns based on static analysis of symbolic execution traces.",
            "method description": "SGUARD identifies vulnerabilities in smart contracts and applies runtime checks to ensure they are free from common vulnerabilities.",
            "method steps": [
                "Collect symbolic execution traces of the smart contract.",
                "Perform static analysis on the collected traces to identify potential vulnerabilities.",
                "Apply specific fixing patterns for each type of identified vulnerability."
            ],
            "principle": "The effectiveness of SGUARD is based on its sound and complete approach to identifying and fixing vulnerabilities in smart contracts."
        },
        "experiments": {
            "evaluation setting": "SGUARD was evaluated using 5000 smart contracts, with experiments conducted to measure its performance in fixing vulnerabilities and the overhead incurred.",
            "evaluation method": "The evaluation involved applying SGUARD to the contracts, measuring the time and gas overhead introduced by the fixes, and analyzing the fixed contracts for vulnerabilities."
        },
        "conclusion": "SGUARD successfully fixes smart contracts to be free of 4 types of vulnerabilities while introducing only minor overhead, demonstrating its practical applicability.",
        "discussion": {
            "advantage": "SGUARD provides a provably correct method to automatically fix vulnerabilities in smart contracts, which is a significant advancement over existing methods.",
            "limitation": "The method may introduce unnecessary runtime checks that can lead to performance overhead, particularly in cases where non-vulnerable traces are affected.",
            "future work": "Future improvements will focus on optimizing SGUARD to reduce overhead and enhance performance."
        },
        "other info": {
            "tool availability": "SGUARD is implemented in Node.js and is publicly available on GitHub.",
            "experimental results": {
                "contracts analyzed": 5000,
                "contracts fixed": 1605,
                "average gas overhead": "0.79%",
                "average time overhead": "14.79%"
            }
        }
    },
    "mount_outline": [
        {
            "section number": "2.1",
            "key information": "The fundamental principles of AI safety include ensuring that systems are free from vulnerabilities, particularly in the context of smart contracts which are immutable and cannot be patched once deployed."
        },
        {
            "section number": "3.1",
            "key information": "The main challenges in AI safety and evaluation include the Turing-completeness of smart contract languages, which makes existing verification methods infeasible."
        },
        {
            "section number": "3.2",
            "key information": "SGUARD is proposed as a tool that applies runtime verification to automatically fix potentially vulnerable smart contracts, serving as a framework for safe AI development in this context."
        },
        {
            "section number": "5.1",
            "key information": "SGUARD was evaluated using 5000 smart contracts, measuring its performance in fixing vulnerabilities and assessing the time and gas overhead introduced by the fixes."
        },
        {
            "section number": "7.1",
            "key information": "Future research directions for SGUARD include optimizing the tool to reduce performance overhead while maintaining its ability to fix vulnerabilities."
        },
        {
            "section number": "8",
            "key information": "SGUARD demonstrates the importance of ensuring that smart contracts are free of vulnerabilities, highlighting the practical applicability and necessity of robust evaluation methods in AI safety."
        }
    ],
    "similarity_score": 0.5643943889016955,
    "image": null,
    "path": "/home/dany/codes/autosurvey/outputs/2025-01-12-1050_,AI_s/papers/sGUARD_ Towards Fixing Vulnerable Smart Contracts Automatically.json"
}