{
    "from": "arxiv",
    "scholar_id": null,
    "detail_id": "arXiv:2011.04341",
    "title": "Hierarchical routing control in discrete manufacturing plants via model predictive path allocation and greedy path following",
    "abstract": "The problem of real-time control and optimization of components' routing in discrete manufacturing plants, where distinct items must undergo a sequence of jobs, is considered. This problem features a large number of discrete control inputs and the presence of temporal-logic constraints. A new approach is proposed, adopting a shift of perspective with respect to previous contributions, from a Eulerian system model that tracks the state of plant nodes, to a Lagrangian model that tracks the state of each part being processed. The approach features a hierarchical structure. At a higher level, a predictive receding horizon strategy allocates a path across the plant to each part in order to minimize a chosen cost criterion. At a lower level, a path following logic computes the control inputs in order to follow the assigned path, while satisfying all constraints. The approach is tested here in simulations, reporting extremely good performance as measured by closed-loop cost function values and computational efficiency, also with very large prediction horizon values. These features pave the way to a number of subsequent research steps, which will culminate with the experimental testing on a pilot plant.",
    "bib_name": "fagiano2020hierarchicalroutingcontroldiscrete",
    "md_text": "# Hierarchical routing control in discrete manufacturing plants via model predictive path allocation and greedy path following\norenzo Fagiano, Marko Tanaskovic, Lenin Cucas Mallitasig, Andrea Cataldo and Riccardo Scattolini\nAbstract\nThe problem of real-time control and optimization of components\u2019 routing in discrete manufacturing plants, where distinct items must undergo a sequence of jobs, is considered. This problem features a large number of discrete control inputs and the presence of temporal-logic constraints. A new approach is proposed, adopting a shift of perspective with respect to previous contributions, from a Eulerian system model that tracks the state of plant nodes, to a Lagrangian model that tracks the state of each part being processed. The approach features a hierarchical structure. At a higher level, a predictive receding horizon strategy allocates a path across the plant to each part in order to minimize a chosen cost criterion. At a lower level, a path following logic computes the control inputs in order to follow the assigned path, while satisfying all constraints. The approach is tested here in simulations, reporting extremely good performance as measured by closed-loop cost function values and computational efficiency, also with very large prediction horizon values. These features pave the way to a number of subsequent research steps, which will culminate with the experimental testing on a pilot plant.\n2020\n9 Nov\nManufacturing is a key strategic sector in all industrialized countries. In many product categories, a high level of automation has enabled the mass production of goods with very high throughput and quality, and low unit cost. This is one of the main building blocks of modern economies. Yet, the strong global competition, together with the combined trends of higher product customization, more agile supply chains, and higher environmental sustainability, motivate further research and development in advanced manufacturing solutions [1], [2], [3]. This interdisciplinary research domain involves many fields, from industrial communications to collaborative robotics, from human-machine interaction to routing and logistics, leading to a large number of interesting and challenging problems [4], [5], [6], [7]. Among the latter, we focus on the real-time control and optimization of components\u2019 routing in discrete manufacturing plants, where distinct items must undergo a sequence of jobs. Depending on the specific manufacturing process at hand, this problem may entail several requirements. The discrete parts must be routed to a number of stations, via physical lines that present handling constraints, for example in terms of limited movement speed and potential line congestion. Different lines may also merge at some points, leading to possible lockouts to be avoided. Moreover, the processing time at each station may be uncertain within some limits, and the sequence of jobs to be done on a part may be not fully known a priori, since it can change depending on the outcome of each job. For example, some parts may need reworking due to a non-satisfactory outcome of one job, or they may undergo a random quality test at certain stages of the production process. In addition, the priorities among parts can also change in real-time, for example due to the segmentation of products and the need to increase flexibility and deliver production-on-demand. Other external factors such as component unavailabilities or faults may also affect the production lines. Finally, sustainability goals translate to minimization of waste and of energy consumption. From a control engineering perspective, the mathematical transcription of this problem leads to a prohibitive large-scale integer or mixed-integer optimal control program, involving a dynamical system with discrete state variables, discrete input commands, and discrete output measurements, and subject to temporal logic constraints and external disturbance signals, where the goal is to guarantee the required throughput with minimal waste and energy cost. To tame such a complexity, hierarchical approaches are adopted: the overall problem is divided into sub-problems addressed separately, such as low level feedback control of individual machines and of segments of movement lines, computation of feasible routes, machine scheduling, etc.. Approaches in the literature that aim to address one or more of these sub-problems include rule-based techniques [9], [10], [11], [12], [13], integer programming [14], multi-agent architectures [15], short-term simulation and ordinal optimization [16], heuristic search combined with Petri nets [17], and model predictive control (MPC) [18], [19], [20], [8], [21]. In particular, in [8] a receding horizon approach has been employed to control in real-time a de-manufacturing plant composed of 35 nodes (comprising either discrete movement elements or working/testing machines), accounting for temporal logic constraints and optimizing a multi-objective criterion that trades off the system throughput and the energy consumption. In an analogy with fluid modeling, this approach adopted a Eulerian description, where the state vector includes the status of each node in the plant (which is conceptually similar to a control volume in fluid dynamics). The resulting control policy, experimentally tested on a laboratory setup (shown in Fig. 1), has the merit of providing the optimal solution to the finite horizon routing problem at each time step. However, the drawback of this approach is the rapid increase of\nL. Fagiano, L. Cucas and R. Scattolini are with the Dipartimento di Elettronica, Informazione e Bioingegneria, Politecnico di Milano, Piazza Leonardo da Vinci 32, 20133 Milano, Italy. M. Tanaskovic is with Singidunum University, 32 Danijelova St., Belgrade, 160622 Serbia. A. Cataldo is with the Institute of Industrial Technology and Automation, National Research Council, Via Alfonso Corti 12, 20133 Milano, Italy. Corresponding author: L. Fagiano, lorenzo.fagiano@polimi.it. This research was funded by a grant from the Italian Ministry of Foreign Affairs and International Cooperation (MAECI), project \u201cReal-time control and optimization for smart factories and advanced manufacturing\u201d.\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/303a/303a9deb-e875-49a7-bb96-803019d81918.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Fig. 1. Laboratory de-manufacturing plant at the National Research Council in Milano ([8]), showing the loading/unloading node with a manipulato the transportation nodes and a machine node in the background.</div>\ncomputational complexity with the number of prediction steps and of nodes in the plant, which limits its application to a relatively short prediction horizon and small system size. This paper presents the first accomplished step of a research project aimed to improve over the results of [8] in terms of scalability, while still satisfying the same, demanding temporal logic constraints. The main contribution presented here is a new approach to address the real-time routing problem, with two novelties: 1) a shift of perspective from a Eulerian to a Lagrangian description, where the system state includes the status of each part that must be routed in the plant, instead of each node; and 2) a hierarchical MPC structure, where the receding horizon strategy allocates a path to each part (as well as the part\u2019s position on the path) and a lower-level logic computes the control inputs in order to follow the assigned path. We tested the new approach in simulation and report extremely good performance as measured by closed-loop cost function values and computational efficiency, also with very large prediction horizon values. These features pave the way to a number of subsequent research steps, which will culminate with the experimental testing on the pilot plant of Fig. 1.\nWe consider a discrete manufacturing plant composed of a finite number Nn \u2208N of nodes. At each discrete time instant k, each node h = 1, . . . , Nn may be empty or it may host one (and only one) part being processed. For a reference, consider the diagram of Fig. 2 representing the small-scale system that we use in this paper to test the proposed approach, composed of 12 nodes. A more complex diagram representing the laboratory testbed at the National Research Council in Milano, with 35 nodes, can be found in [8]. The boolean variable zh(k) \u2208{0, 1} indicates whether a part is present at node h (i.e., zh(k) = 1) or not. We assume that Nt out of Nn nodes are transportation modules, and the remaining Nm = Nn \u2212Nt are machines. In particular, let us denote the set of indexes of machine nodes as\nM = {h : node h is a machine}.\nEach node (be it a transportation module or a machine) is able to either hold one part in place, or to move it to a fixed number of specific, directly connected nodes according to the plant topology (see, e.g., Fig. 2). Each machine must, in addition, execute a specific job on each part it receives. Without loss of generality we assume that a movement from one node to a connected one lasts one time step (direct movement), while the job carried out by a machine m lasts an integer number Lm \u22651 of time steps. The boolean control signal uh,j(k) \u2208{0, 1} dictates whether a part will move from node h at time k to node j at time k + 1. Finally, we also assume that two special nodes are present, the loading node and the unloading one, with indexes hl and hu, respectively. These nodes are the interface between the plant under study and the outside, denoted with index 0, through two control variables: u0,hl can move to the loading node a part from outside the plant, e.g. from a buffer containing the incoming parts that must be processed, while a part can be moved from the\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/09e7/09e786ec-ad7b-4e36-8821-5c71e78d53da.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Fig. 2. Small-scale system considered as test case in this paper. Node 10 is both the loading and unloading one (i.e., hl = hu = 10) and nodes 1 re machines (i.e., M = {11, 12}).</div>\nunloading node to the outside via the control variable uhu,0, e.g. to a buffer of finished parts. We denote with Nf(k) the total number of finished parts at time k. In summary, the number Nu of boolean control signals to be computed at each time step is equal to the number of valid direct transitions among the nodes, plus the two loading and unloading commands u0,hl, uhu,0. We collect these inputs into a column vector, denoted with U(k) \u2208{0, 1}Nu. For each node h = 1, . . . , Nn, we define the following sets. Definition 1: (Outgoing and Incoming sets) \u2022 The outgoing set Oh is the set containing the indexes of all nodes that can be reached directly from h, including possibly the outside, i.e. Oh = {j : \u2203uh,j}; \u2022 The incoming set Ih is the set containing the indexes of all nodes for which h is a direct destination, including possibly the outside, i.e. Ih = {j : \u2203uj,h}. We thus have {0} \u2208Ohu and {0} \u2208Ihl. Defining z = [z1, . . . , zNn]T (\u00b7T is the vector transpose operation) and \uf8ee \ufffd \ufffd \uf8f9\n\uf8f0 \ufffd \ufffd we can introduce the following linear model describing the plant\u2019s behavior:\n\uf8f0 \ufffd \ufffd ntroduce the following linear model describing the plant\u2019s behavior:\nThis model corresponds to a Eulerian description of the system, where the nodes are taken as control volumes, the system state corresponds to the number of parts in each of these volumes, and the model essentially corresponds to a series of mass conservation equations. To keep consistency with the real system, the boolean control inputs must comply with the following operational constraints at all time steps:\n\ufffd \ufffd j\u2208Ih uj,h(k) = 0, \u2200h : zh(k) = 1 \u2227 \ufffd j\u2208Oh uh,j(k) = 0\n(1)\n(2a) (2b) (2c) (2d)\n(2a)\n(2b)\n(2c)\n(2d)\nConstraints (2a)-(2b) impose that a part shall move to at most one destination from node h, and that only one part shall reach node h at the next time step. Constraint (2c) states that all control signals from an empty node shall be zero, finally constraint (2d) imposes that no part can move to node h if the latter is occupied and it will hold its current part in the next step. Moreover, temporal logic constraints on the control inputs pertaining to machine nodes arise, due to the fact that once a job is started it must be completed before the part can be moved. Denoting with km the time when a new job is started by machine m, such constraints take the form:\n\ufffd um,j(k) = 0, \u2200k \u2264km + Lm, \u2200m \u2208M : zm(k) = 1\nThe problem we address can be described as follows: derive a control policy that computes, at each time instant k, all of the control variables uh,j in order to satisfy the operational constraints (2)-(3) and to minimize a suitably defined cost criterion. In [8], this problem has been addressed resorting to MPC, after a suitable manipulation of the model and of the constraints that leads to a mixed logical dynamic (MLD) formulation and a large-scale mixed-integer linear program to be solved at each time step. The considered cost criterion was a weighted sum of terms that penalize the permanence of parts in the plant (thus encouraging a higher throughput) and the energy consumption as measured by a number of non-zero control inputs (which correspond to a physical movement of a part in the plant). The approach has been tested experimentally with good performance, however it suffers from the high computational complexity due to the large number of auxiliary integer and continuous variables that need to be introduced in the MLD reformulation. To give an example, in the small test case of Fig. 2, 160 integer auxiliary variables need to be introduced per each time step in the prediction horizon (e.g., with a 5-time-steps horizon about 800 integer variables are used). The approach introduced in this paper, presented next, aims to overcome this issue by taking a different perspective on the problem at hand.\n<div style=\"text-align: center;\">III. LAGRANGIAN SYSTEM MODEL AND PROPOSED APPROACH</div>\nTo reduce the computational complexity while still retaining an optimization-based predictive approach, we propose here the hierarchical control structure presented in Fig. 3:\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/52cb/52cb4bd1-2988-4513-908c-c8f167f25d61.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Fig. 3. Hierarchical control approach proposed in this paper.</div>\n\u2022 a low-level greedy path following strategy is in charge to compute feasible control inputs and to move forward each part along its assigned path; \u2022 a high-level model predictive path allocation module solves a finite horizon optimal control problem (FHOCP), where the decision variables are the sequences that each part shall follow, as well as their position in such sequences. Thus, the predictive controller can shift parts forward and backward on the various paths and move them from a path to another one, as long as consistency with their physical location is maintained. As suggested by the adopted terminology, in this new approach we follow the parts\u2019 trajectories instead of keeping track of the status of each control volume, i.e. we adopt a Lagrangian description of the plant instead of an Eulerian one. Consistency/translation between the two descriptions is provided by the fact that each path is a sequence of nodes, thus the position of a part on a given path unequivocally identifies the node where that part is located. In the next sections, we present in detail the hierarchical approach by describing the two elements listed above.\n# A. Lagrangian model state\nLet us denote with i = 1, . . . , Np(k) an index that identifies each one of the Np(k) \u2208N parts in the plant at time k. The value of Np(k) \u2208N can change over time as new parts enter the plant and/or finished ones exit. We further denote with S = {1, 2, . . . , Ns} a set of integers, each one corresponding unequivocally to a sequence (or path). Such sequences are assumed to be precomputed and stored: sequence generation and selection methods are not addressed in this paper, yet we will briefly comment on this aspect later on in Remark 1. For each s \u2208S, the operator S(s) returns the actual sequence corresponding to index s. Each sequence S(s) has the following structure: \ufffd\ufffd \ufffd \ufffd \ufffd \ufffd \ufffd\ufffd\nwhere Ns is the sequence length, p = 1, . . . , Ns is the position along the sequence, and hp, gp are integers corresponding to nodes in the plant. In particular, each value of hp corresponds to a node that is either equal to hp+1 (i.e. the part shall be held), or directly connected to hp+1 (i.e., the part shall be moved from node hp to hp+1), while each value of gp is the index of a node chosen as goal for that part of the sequence. Usually, such goal indexes correspond to machines or to the outside (node 0). We indicate with si(k) \u2208S the sequence that part i is following at time k, with pi(k) \u2208N the position of part i along such a sequence, and with S(si(k))(1,pi(k)), S(si(k))(2,pi(k)) the first and second entry, respectively, of the vector in position pi(k) of sequence S(si(k)) (compare (4)). For example, referring to Fig. 2, the sequence identified by index s = 1 could correspond to: \ufffd\ufffd \ufffd \ufffd \ufffd \ufffd \ufffd \ufffd \ufffd \ufffd \ufffd\nand a part i with si(k) = 1 and pi(k) = 3 would be located at node h = 2 at time k, i.e. S(si(k))(1,pi(k)) = 2 and have as goal the machine node S(si(k))(2,pi(k)) = 12. Moreover, we denote with ki the time step when part i appeared on the plant, and with ti(k) the time elapsed since then:\nFinally, we denote with\nri(k) = card(S(si(k))) \u2212pi(k)\nthe number of remaining nodes that part i shall visit to complete its current sequence. Variable ri(k) is thus a function of the state.\nthe number of remaining nodes that part i shall visit to complete its current sequence. Variable ri(k) is thus a function of the state xi(k).\nmber of remaining nodes that part i shall visit to complete its current sequence. Variable ri(k) is thus a function of te xi(k). er use, we also collect all the state variables in vector\nter use, we also collect all the state variables in vector\nXNp(k)(k) = [x1(k)T , . . . , xNp(k)T ]T \u2208N3Np\nwhich represents the overall state of the Lagrangian plant model. Note that such a state vector can change dimension in time as it depends on the value of Np(k) (which we denote with the subscript \u00b7Np(k) in (8)). Albeit rather unusual in dynamical models, this feature does not lead to any technical problem as long as consistency with the Eulerian model is ensured. In turn, this is obtained by always applying feasible inputs to the plant, as achieved by our path following algorithm, introduced next.\nThe greedy path following strategy is a rule-based controller that acts according to the following principles: a) if possible, move each part forward in its current sequence; b) if the next node in the sequence is blocked, wait; c) if a potential conflict among parts is detected, the part with smallest ri(k) value shall move, and the other ones shall wait. To account for new parts that must be loaded to the plant from the outside, we introduce the boolean a(k), which is equal to 1 when such a new part is available to be moved to the loading node.\nAlgorithm 1 Greedy path following strategy. At each time step k: 1. Compute ri(k), i = 1, . . . , Np(k) according to (7);\n(4)\n(5)\n(6)\n(7)\n(8)\n2. Compute the one-step-ahead predicted states \u02c6xi, i = 1, . . . , Np(k), by forward-propagation of all parts along their current paths:\n2. Compute the one-step-ahead predicted states \u02c6xi, i = 1, . . . , Np(k), by forward-propagation of all  current paths:\n\uf8f0 \uf8fb  For each node h = 1, . . . , Nn, compute the number of potential conflicts nh(k + 1) as:\nCh(k) = {i : c(\u02c6xi(k + 1), h) = 1}\n. Check if a part is being held at node h:\n4.e. \u2200i \u2208Ch(k) : i \u0338= i\u2217 h(k), correct the corresponding one-step-ahead predicted state as \u02c6pi(k + 1) = pi(k) \uf8ee \uf8f9\n4.e. \u2200i \u2208Ch(k) : i \u0338= i\u2217 h(k), correct the corresponding one-step-ahead predicted state as:\n\u02c6pi(k + 1) = pi(k) \u02c6xi(k + 1) = \uf8ee \uf8f0 si(k) \u02c6pi(k + 1) ti(k + 1) \uf8f9 \uf8fb.\n\u02c6pi(k + 1) = pi(k) \u02c6xi(k + 1) = \uf8ee \uf8f0 si(k) \u02c6pi(k + 1) ti(k + 1) \uf8f9 \uf8fb\n4.f. Go to 3.\n5. Apply to the plant the following inputs, corresponding to the computed part movements\nStep 4.d. of Algorithm 1 sets the priority as follows: a part being held at a node has the highest priority, if no part is held then the one that is most advanced in its own sequence (i.e. minimal ri(k)) has the second-highest priority, if more than one part has minimal ri(k) then the one that has been in the plant for the longest time has the third-highest priority. Assuming that only one new part can enter the plant at each time (e.g., if there is only one loading node), this guarantees that eventually only one part is selected and advanced. If more than one loading node exist, then another condition (e.g. based on part number) can be easily implemented to sort out possible ambiguities. Lemma 1: (Recursive feasibility of Algorithm 1). Assume that at a given time k at most one part is present at each node, and that for any index s \u2208S, if the corresponding sequence S(s) includes a machine node m \u2208M at some position p, and\na node h \u0338= m at position p \u22121, then such a machine node appears at least Lm times consecutively, i.e. inside S(s) there is a subsequence\na node h \u0338= m at position p \u22121, then such a machine node appears at least Lm times consecutively, i.e. inside S is a subsequence \ufffd \ufffd \ufffd \ufffd \ufffd \ufffd\na node h \u0338= m at position p \u22121, then such a machine node appears at least  is a subsequence \ufffd \ufffd \ufffd \ufffd \ufffd\nwith v \u2265Lm. Then, the inputs computed by Algorithm 1 satisfy the constraints (2)-(3) for all k \u2265k. Proof: A sketch of the proof is provided for the sake of compactness. At time k + 1, constraints (2) are satisfied by the conflict-resolution logic of Algorithm 1, which always ends with at most only one incoming part at each node, except for nodes where a part is being held. Constraint (3) is satisfied by the assumption that each sequence containing a machine node m features that node repeated consecutively for at least Lm positions, which results in a part being held at least Lm time steps in machine m. Feasibility of the inputs at all time steps k > k + 1 is obtained by induction. The feedback control policy defined by Algorithm 1 corresponds to a set of functions \u03baNp, Np \u2208N. Each one of these functions pertains to a specific number of parts Np and its input arguments are the corresponding Lagrangian state XNp(k) and signal a(k), while the output of all of them is a vector of plant commands U \u2208{0, 1}Nu (see step 5. of Algorithm 1):\nU(k) = \u03baNp(k)(XNp(k)(k), a(k)).\nAs shown in Lemma 1, such a control policy generates inputs that are always feasible under a rather mild assumption, since the sequences S(s), s \u2208S, are selected/computed by the designer, who can easily enforce the property required by Lemma 1. However, input feasibility by itself does not prevent the controlled system from running into a lockout, and in general the greedy path following approach can give suboptimal behavior with respect to the performance criteria of interest. On the other hand, when combined with the model (1), Algorithm 1 allows one to predict the system behavior without having to explicitly enforce the challenging constraints (2)-(3) and at extremely low computational cost. We exploit such closed-loop predictions in a high-level MPC strategy, described in the next Section. Before proceeding further, we also introduce the closed loop Lagrangian model of the system, provided by the following algorithm.\nAlgorithm 2 Closed-loop Lagrangian plant model. At each time step k: 1. Run Algorithm 1 with the current values of XNp(k)(k) and a(k) as inputs, collect all the resulting values of \u02c6xi(k + and uh,j(k), \u2200(h, j) : \u2203uh,j; 2. Compute the Lagrangian state dimension Np(k + 1) as\nNp(k + 1) = Np(k) + u0,hl \u2212uhu,0;\n3. If u0,hl = 1, generate the state \u02dcx(k + 1) of the new part that will be loaded to the plant at time t + 1; 4. For all i : S(si(k))(1,\u02c6pi(k+1)) \u0338= hl, compute the state xi(k + 1) = \u02c6xi(k + 1). 5. Compute the Lagrangian state XNp(k+1)(k +1) by stacking all vectors xi(k +1) computed at step 4. and, if availab vector \u02dcx(k + 1) computed at step 3.. Set k = k + 1 and go to 1..\nThe state initialization of a new part at step 3. can be done by assigning a sequence s \u2208S and position p to it (typically, but not necessarily, p = 1), and by setting the third state equal to zero (compare (5)-(6)). Since their state value is not updated at step 4., parts that are unloaded from the plant naturally disappear from the Lagrangian model. Similarly to the control policy (11), the system model defined by Algorithm 2 also corresponds to a set of functions, f(N + p ,Np) : 3NNp \u21923NN + p , each one pertaining to a specific pair of part quantities, i.e. those at the current and at next time steps, while the signal a(k) is an exogenous input:\nXNp(k+1)(k + 1) = f(Np(k+1),Np(k))(XNp(k)(k), a(k)).\nEquation (12) highlights the fact that the Lagrangian model describes the motion of the parts, whose number can incre or decrease from one step to the next depending on the number of newly loaded parts and of unloaded ones.\n# C. Model predictive path allocation\nAt each time step, the predictive control logic chooses whether to keep each part on its current path si(k) and at its current position pi(k), or to change one or both of these elements in order to optimize the predicted plant performance. The result is a dynamic, optimization-based path allocation strategy that can exploit very large prediction horizon values, thus guaranteeing the absence of lockouts, and allows one to easily consider different performance indexes and to generally improve the plant behavior with respect to the one obtained by the greedy path following policy alone.\n(12)\n# At each time step k, let us consider the following sets Xi(k), i = 1, . . . , Np(k):\nAt each time step k, let us consider the following sets Xi(k), i = 1, . . . , Np(k):\nif S(si(k))(1,pi(k)) /\u2208M : Xi(k) = \uf8f1 \uf8f2 \uf8f3 (s, p) \u2208S \u00d7 N : S(s)(1,p) = S(si(k))(1,pi(k)) \u2227S(s)(2,p) = S(si(k))(2,pi(k)) \uf8fc \uf8fd \uf8fe\n\uf8f3 else if S(si(k))(1,pi(k)) \u2208M : \uf8f1\n S \u2208M Xi(k) = \uf8f1 \uf8f4 \uf8f4 \uf8f2 \uf8f4 \uf8f4 \uf8f3 (s, p) \u2208S \u00d7 N : S(s)(1,p\u2212j) = S(si(k))(1,pi(k)\u2212j), j = 0, . . . , k \u2212kS(si(k))(1,pi(k)) \u2227S(s)(2,p) = S(si(k))(2,pi(k))\n\uf8f4 \uf8f4 \uf8f3 \uf8f4 \uf8f4 \uf8fe where kS(si(k))(1,pi(k)) is the time step when part i started the job of machine m = S(si(k))(1,pi(k)) (compare (3)). Namely, each set Xi(k) contains all the pairs (s, p) of sequence index and position index such that the corresponding vector \ufffd S(s)(1,p)S(s)(2,p)\ufffdT corresponds to that of part i at time k, also considering a possible ongoing job and its remaining duration, if S(si(k))(1,pi(k)) is a machine node. These sets are never empty by construction, since they always include the current pair (si(k), pi(k)). At any time k, exchanging these two components of the state xi(k) to any other pair (s, p) \u2208Xi(k) implies that we are allocating to part i another sequence and/or position among those that are compatible with its current physical location and goal. For example, in this way it is possible to select one out of several parallel paths originating from a certain node in the plant, or to make a part wait or repeat several times a single loop in the plant, each time by shifting it back in a sequence that contains that loop only once. Our high-level predictive controller exploits precisely this feature, as described in the following algorithm. We denote with XNp(o|k)(o|k), x(o|k) the predictions of plant input and Lagrangian states, respectively, computed at time k and pertaining to time k + o.\nAlgorithm 3 Model Predictive Path Allocation. 1. At time k acquire the state variables xi(k), i = 1, . . . , Np(k) and compute the corresponding sets Xi(k); 2. Solve the following finite horizon optimal control problem (FHOCP):\n1. At time k acquire the state variables xi(k), i = 1, . . . , Np(k) and compute the corresponding sets Xi(k); 2. Solve the following finite horizon optimal control problem (FHOCP):\n<div style=\"text-align: center;\">(\u03c3i, \u03c0i) \u2208Xi(k), i = 1, . . . , Np(k)</div>\nwhere N \u2208N is the prediction horizon, the sequence a(o|k) \u2208{0, 1}, o = 0, . . . , N \u22121 contains the predictions of new parts that need to be worked (if available), and the stage cost functions \u2113Np \ufffd XNp \ufffd are chosen by the designer according to the plant performance indicator of interest. . Let (\u03c3\u2217 i , \u03c0\u2217 i ), i = 1, . . . , Np(k) be the solution to (14). Compute the new state vectors x\u2217 i (k) as:\n\ufffd  \ufffd and provide these values to Algorithm 1 to compute the control inputs via (11) U \u2217(k) = \u03baNp(k)(X\u2217 Np(k)(k), a(k)).\n<div style=\"text-align: center;\">\ufffd  \ufffd and provide these values to Algorithm 1 to compute the control inputs via (11): U \u2217(k) = \u03baNp(k)(X\u2217 Np(k)(k), a(k)).</div>\n(13a)\n(13b)\n(14a)\n(14b)\n(14c)\n(14d)\n(14e)\n4. Apply to the plant the control inputs U \u2217(k), set k = k + 1, go to 1.. The predictive control strategy defined by Algorithm 3 is thus able to directly modify the state of each part that is fed to the path following strategy (see Fig. 3), ensuring consistency with its current positions and goal (constraint (14e)), in order to optimize the chosen performance index (14a) on the basis of a prediction of the plant behavior under the greedy path following algorithm, see (14b)-(14d). Note that the optimization variables (\u03c3i, \u03c0i), i = 1, . . . , Np(k) pertain only to the current time step, i.e. the sequence index is not changed during the predictions. This clearly reduces the degrees of freedom of the solver, resulting in possible sub-optimality but gaining in computational efficiency, similarly to what is done in move blocking strategies in MPC, see e.g. [22]. On the other hand, being a receding horizon strategy, Algorithm 3 is able to change the sequence and position indexes si(k), pi(k) of all states at each time step k, resulting in practice in good closedloop performance. Signal a(k), which is managed by the greedy path following algorithm as described in Section III-B, is considered as an external disturbance, of which a prediction may be available (otherwise one can simply set a(o|k) = 0 in (14d)). Regarding the choice of cost functions \u2113Np \ufffd XNp \ufffd , possible examples include the sum, over all parts, of the remaining steps in their respective sequences (which favors plant throughput), plus the sum of non-zero control inputs (which favors energy saving). The design of cost functions accounting for different real-world requirements is subject of current research. As regards the guaranteed closed-loop performance, the optimization problem (14) is always feasible by construction, since to a minimum the controller can just leave sequence and position indexes unchanged, and plant constraints are always satisfied by the path following approach. On the other hand, a sensible question pertains to what we refer to as the lockout avoidance property, i.e. the guarantee that the predictive approach always prevents occurrence of a lockout. Under mild assumptions on the chosen sequences and prediction horizon N,we can indeed prove that Algorithm 3 guarantees lockout avoidance. This result and its proof are omitted here for the sake of brevity. Remark 1: (Computation of node sequences) The performance of the closed-loop plant under the proposed hierarchical approach strongly depend on the pre-computed paths. The generation of these paths entails a trade-off between two conflicting aspects: on the one hand, a large number of comprehensive paths will provide the predictive controller with more degrees of freedom to accommodate more parts and reach higher performance, on the other hand a set of sequences that is too rich can lead to very high computational complexity, reducing the scalability of the proposed approach. In the numerical example presented in this paper, where each part has to visit the two machines one after the other, we adopted a manual selection based on physical insight, see Section IV. We plan to rigorously investigate the problem of optimal sequence computation and selection in the next future, adopting approaches from graph theory combined with closed-loop system analysis.\n# IV. NUMERICAL RESULTS\nWe present the tests of the hierarchical approach on the small-scale example of Fig. 2, with Nu = 22 boolean control inputs. The two machine nodes 11, 12 have the same processing time L11 = L12 = 3 time steps, and each part must visit first machine 12, then machine 11 before leaving the plant from node 10, which is also the loading node. We assume that a(k) = 1 \u2200k, i.e. a new part is loaded to the plant whenever the loading node is free, and that the predictive controller does not have this information. The maximum throughput of the plant depends on the processing time of machine 12 and on the fact that node 10 has to switch between loading a new part or unloading a finished one, thus adding two additional time steps. Its value is thus equal to 1/(L12 + 2) = 0.20 parts per time step. We set a prediction horizon of N = 50 time steps, and we use as stage cost in (14a) the following function:\n\ufffd \ufffd \ufffd where \u03b2 \u22650 is a weighting factor, ri(o|k) is computed as in (7) considering the predicted Lagrangian states, and U(o|k) = \u03baNp(o|k)(X\u2217 Np(o|k)(o|k), 0) is the vector of simulated actuation commands given to the plant. Function (15) is thus the weighted sum of two objectives: the total number of remaining steps in the sequence assigned to each part, related to throughput maximization, and the total number of commanded inputs, related to energy minimization. As regards the sequence computation, since the considered example is essentially a series manufacturing process, we adopt here a single path, composed of redundant sub-sequences going several times through all possible loops across nodes 2, 3, 4, 5, 6, 7 (see Fig. 2) and of sub-sequences of identical values for each node, in order to provide the predictive controller with the option to make one part wait in place by shifting it back with such sub-sequences. The criteria that we considered in the path generation are: the inclusion in each sequence of all the machines in the correct order, the inclusion of subsequences as required by Lemma 1, and the inclusion in each sequence of a terminal sub-path leading to the outside of the plant (unloading node). We ran all the simulations starting from one part in node 10. In this example, the maximum throughput can be reached with different strategies that lead to different values of energy consumption: in fact, during each job it is possible to let the waiting parts be held on the nodes, or to make them circulate in the available loops within the plant. We illustrate that the proposed strategy switches between these two behaviors as the value of \u03b2 decreases. This is clearly visible in Figs. 4-5: with \u03b2 = 5 the plant reaches the maximum throughput and a number of commands per time step equal to 3.5, while with\n(15)\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/aa53/aa538e7f-727a-438a-b0ec-b2d1dfcbc2d2.png\" style=\"width: 50%;\"></div>\nFig. 4. Simulation example. Course of the plant throughput expressed as number of finished parts per time step, with \u03b2 = 5 (dashed line), \u03b2 and \u03b2 = 8 (dash-dotted).\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/793b/793b215d-a560-4126-b53a-39fa48fa167f.png\" style=\"width: 50%;\"></div>\n\u03b2 = 6 the same throughput is obtained with only 2.5 commands per time step, i.e. 30% less. In both cases, a number of parts oscillating between 7 and 8 is present on the plant at each time step, after the initial transient. If we further increase \u03b2, the controller reaches a lockout with eight parts on the plant, since it becomes more convenient to avoid any actuation rather than to push the parts forward in their paths. This is also shown in Figs. 4-5. Finally, regarding the computational aspects, we solved the problem (14) via extensive search over all possible valid (\u03c3i, \u03c0i) pairs. On a Laptop with 8GB RAM and an Intel Core i7 CPU at 2.6 GHz running Matlab, the resulting computational time\n# s 0.45 s per time step, without any attempt to improve the solver efficiency (e.g. by parallelizing the computations and/o adopting a non-brute-force approach to solve the optimization problem).\nis 0.45 s per time step, without any attempt to improve the solver efficiency (e.g. by parallelizing the computatio adopting a non-brute-force approach to solve the optimization problem).\nV. CONCLUSIONS\nA new approach to the problem of routing parts in discrete manufacturing plants has been presented, adopting a Lagrangian modeling perspective and a hierarchical control structure. Simulation results on a small example illustrate the behavior of the closed loop system, which achieves the theoretical maximum throughput and allow one to optimize energy consumption, as measured by the number of actuated commands. The obtained computational times are very low for the considered application, also considering the rather large employed prediction horizon. This makes us confident about the scalability to larger plants. Next steps in this research are aimed to investigate the generation of optimal sequences, the derivation of theoretical guarantees about lockout avoidance, testing in scenarios with uncertain outcomes of each job and non-series manufacturing processes, and the experimental validation on a pilot plant.\n# REFERENCES\n[1] European Commission, \u201cFactory of the future,\u201d Multi-Annual Roadmap for the Contractual PPP Under Horizon 2020. Belgium: Publications Office of the European Union, 2013. [2] H. S. Kang, J. Y. Lee, S. Choi, H. Kim, J. H. Park, J. Y. Son, B. H. Kim, and S. D. Noh, \u201cSmart manufacturing: Past research, present findings, and future directions,\u201d International Journal of Precision Engineering and Manufacturing-Green Technology, vol. 3, pp. 111\u2013128, 2016. [3] P. Zheng, H. Wang, Z. Sang, R. Y. Zhong, Y. Liu, C. Liu, K. Mubarok, S. Yu, and X. Xu, \u201cSmart manufacturing systems for industry 4.0: Conceptual framework, scenarios, and future perspectives,\u201d Frontiers of Mechanical Engineering, vol. 13, pp. 137\u2013150, 2018. [4] W. Na, Y. Lee, N. Dao, D. N. Vu, A. Masood, and S. Cho, \u201cDirectional link scheduling for real-time data processing in smart manufacturing system,\u201d IEEE Internet of Things Journal, vol. 5, no. 5, pp. 3661\u20133671, Oct 2018. [5] S. Ren, Y. Zhang, Y. Liu, T. Sakao, D. Huisingh, and C. M. Almeida, \u201cA comprehensive review of big data analytics throughout product lifecycle to support sustainable smart manufacturing: A framework, challenges and future research directions,\u201d Journal of Cleaner Production, vol. 210, pp. 1343 \u2013 1365, 2019. [6] N. Tuptuk and S. Hailes, \u201cSecurity of smart manufacturing systems,\u201d Journal of Manufacturing Systems, vol. 47, pp. 93 \u2013 106, 2018. [7] H. Yan, Q. Hua, Y. Wang, W. Wei, and M. Imran, \u201cCloud robotics in smart manufacturing environments: Challenges and countermeasures,\u201d Computers & Electrical Engineering, vol. 63, pp. 56 \u2013 65, 2017. [8] A. Cataldo and R. Scattolini, \u201cDynamic pallet routing in a manufacturing transport line with model predictive control,\u201d IEEE Transactions on Control Systems Technology, vol. 24, no. 5, pp. 1812\u20131819, Sep. 2016. [9] Y. P. GUPTA, M. C. GUPTA, and C. R. BECTOR, \u201cA review of scheduling rules in flexible manufacturing systems,\u201d International Journal of Computer Integrated Manufacturing, vol. 2, no. 6, pp. 356\u2013377, 1989. [10] M. Byrne and P. Chutima, \u201cReal-time operational control of an fms with full routing flexibility,\u201d International Journal of Production Economics, vol. 51, no. 1, pp. 109 \u2013 113, 1997, raising the Competitive Edge in Manufacturing. [11] C. Saygin, F. Chen, and J. Singh, \u201cReal-time manipulation of alternative routeings in flexible manufacturing systems: A simulation study,\u201d The International Journal of Advanced Manufacturing Technology, vol. 18, pp. 755\u2013763, 2001. [12] R. Bucki, B. Chramcov, and P. Such\u00e1nek, \u201cHeuristic algorithms for manufacturing and replacement strategies of the production system,\u201d Journal of Universal Computer Science, vol. 21, no. 4, pp. 503\u2013525, apr 2015. [13] M. Souier, A. Hassam, and Z. Sari, Meta-heuristics for Real-time Routing Selection in Flexible Manufacturing Systems. London: Springer London, 2010, pp. 221\u2013248. [14] S. K. Das and P. Nagendra, \u201cSelection of routes in a flexible manufacturing facility,\u201d International Journal of Production Economics, vol. 48, no. 3, pp. 237 \u2013 247, 1997. [15] K. Kouiss, H. Pierreval, and N. Mebarki, \u201cUsing multi-agent architecture in fms for dynamic scheduling,\u201d Journal of Intelligent Manufacturing, vol. 8, pp. 41\u201347, 1997. [16] C. Peng and F. Chen, \u201cReal-time control and scheduling of flexible manufacturing systems: An ordinal optimisation based approach,\u201d The International Journal of Advanced Manufacturing Technology, vol. 14, pp. 775\u2013786, 1998. [17] A. R. Moro, H. Yu, and G. Kelleher, \u201cHybrid heuristic search for the scheduling of flexible manufacturing systems using petri nets,\u201d IEEE Transactions on Robotics and Automation, vol. 18, no. 2, pp. 240\u2013245, 2002. [18] F. D. Vargas-Villamil and D. E. Rivera, \u201cMultilayer optimization and scheduling using model predictive control: application to reentrant semiconductor manufacturing lines,\u201d Computers & Chemical Engineering, vol. 24, no. 8, pp. 2009 \u2013 2021, 2000. [19] \u2014\u2014, \u201cA model predictive control approach for real-time optimization of reentrant manufacturing lines,\u201d Computers in Industry, vol. 45, no. 1, pp. 45 \u2013 57, 2001. [20] A. Cataldo, A. Perizzato, and R. Scattolini, \u201cProduction scheduling of parallel machines with model predictive control,\u201d Control Engineering Practice, vol. 42, pp. 28 \u2013 40, 2015. [21] A. Cataldo, M. Morescalchi, and R. Scattolini, \u201cFault tolerant model predictive control of a de-manufacturing plant,\u201d The International Journal of Advanced Manufacturing Technology, vol. 9, no. 12, pp. 4803\u20134812, 2019. [22] R. Cagienard, P. Grieder, E. Kerrigan, and M. Morari, \u201cMove blocking strategies in receding horizon control,\u201d Journal of Process Control, vol. 17, no. 6, pp. 563 \u2013 570, 2007.\n",
    "paper_type": "method",
    "attri": {
        "background": "This paper addresses the issue of real-time control and optimization of components\u2019 routing in discrete manufacturing plants, highlighting the limitations of previous Eulerian system models and the necessity for a new Lagrangian model that tracks parts instead of nodes.",
        "problem": {
            "definition": "The problem involves deriving a control policy to compute control inputs that satisfy operational constraints while minimizing a cost criterion in a discrete manufacturing environment.",
            "key obstacle": "The main challenge is the computational complexity arising from the large-scale integer or mixed-integer optimal control programs required to manage the routing of parts effectively."
        },
        "idea": {
            "intuition": "The idea is inspired by the need to reduce computational complexity while maintaining an optimization-based predictive approach to routing in manufacturing plants.",
            "opinion": "The proposed method employs a hierarchical control structure with a Lagrangian perspective, allowing for real-time routing decisions that optimize plant performance.",
            "innovation": "This approach differs from existing methods by shifting from an Eulerian to a Lagrangian model and implementing a hierarchical structure that separates path allocation and path following."
        },
        "method": {
            "method name": "Hierarchical Model Predictive Control (HMPC)",
            "method abbreviation": "HMPC",
            "method definition": "HMPC is a control strategy that allocates paths to parts in a manufacturing plant while ensuring that all operational constraints are met.",
            "method description": "The method combines a high-level predictive controller for path allocation with a low-level greedy strategy for path following.",
            "method steps": [
                "Compute the state of each part in the plant.",
                "Allocate paths to each part using a finite horizon optimal control problem.",
                "Follow the assigned paths using a greedy strategy that resolves conflicts among parts."
            ],
            "principle": "The effectiveness of this method lies in its ability to predict and optimize the routing of parts while maintaining compliance with operational constraints, thus avoiding lockouts."
        },
        "experiments": {
            "evaluation setting": "The method was tested in simulations on a small-scale discrete manufacturing plant model with 12 nodes and various control inputs.",
            "evaluation method": "Performance was assessed through closed-loop cost function values and computational efficiency, comparing the results with existing methods."
        },
        "conclusion": "The new approach demonstrates significant improvements in routing efficiency and computational performance, achieving maximum throughput while minimizing energy consumption, with promising scalability for larger plants.",
        "discussion": {
            "advantage": "Key advantages include reduced computational complexity and the ability to handle larger prediction horizons, leading to better real-time routing decisions.",
            "limitation": "The method may encounter challenges related to the complexity of pre-computed paths and potential sub-optimal behaviors due to greedy decisions.",
            "future work": "Future research will focus on optimizing sequence generation, ensuring theoretical guarantees for lockout avoidance, and validating the approach in experimental settings."
        },
        "other info": {
            "funding": "This research was funded by a grant from the Italian Ministry of Foreign Affairs and International Cooperation (MAECI).",
            "contact": {
                "corresponding author": "Lorenzo Fagiano",
                "email": "lorenzo.fagiano@polimi.it"
            }
        }
    },
    "mount_outline": [
        {
            "section number": "5.3",
            "key information": "The proposed method employs a hierarchical control structure with a Lagrangian perspective, allowing for real-time routing decisions that optimize plant performance."
        },
        {
            "section number": "5",
            "key information": "The problem involves deriving a control policy to compute control inputs that satisfy operational constraints while minimizing a cost criterion in a discrete manufacturing environment."
        },
        {
            "section number": "3.3",
            "key information": "The effectiveness of this method lies in its ability to predict and optimize the routing of parts while maintaining compliance with operational constraints, thus avoiding lockouts."
        },
        {
            "section number": "2.1",
            "key information": "This paper addresses the issue of real-time control and optimization of components\u2019 routing in discrete manufacturing plants, highlighting the limitations of previous Eulerian system models and the necessity for a new Lagrangian model that tracks parts instead of nodes."
        },
        {
            "section number": "6.3",
            "key information": "Key advantages include reduced computational complexity and the ability to handle larger prediction horizons, leading to better real-time routing decisions."
        }
    ],
    "similarity_score": 0.5206213072587268,
    "image": null,
    "path": "/home/dany/codes/autosurvey/outputs/2025-01-11-1142_cogni/papers/Hierarchical routing control in discrete manufacturing plants via model predictive path allocation and greedy path following.json"
}