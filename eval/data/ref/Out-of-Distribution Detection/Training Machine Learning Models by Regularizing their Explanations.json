{
    "from": "arxiv",
    "scholar_id": null,
    "detail_id": "arXiv:1810.00869",
    "title": "Training Machine Learning Models by Regularizing their Explanations",
    "abstract": "Neural networks are among the most accurate supervised learning methods in use today. However, their opacity makes them difficult to trust in critical applications, especially when conditions in training may differ from those in practice. Recent efforts to develop explanations for neural networks and machine learning models more generally have produced tools to shed light on the implicit rules behind predictions. These tools can help us identify when models are right for the wrong reasons. However, they do not always scale to explaining predictions for entire datasets, are not always at the right level of abstraction, and most importantly cannot correct the problems they reveal. In this thesis, we explore the possibility of training machine learning models (with a particular focus on neural networks) using explanations themselves. We consider approaches where models are penalized not only for making incorrect predictions but also for providing explanations that are either inconsistent with domain knowledge or overly complex. These methods let us train models which can not only provide more interpretable rationales for their predictions but also generalize better when training data is confounded or meaningfully different from test data (even adversarially so).",
    "bib_name": "ross2018trainingmachinelearningmodels",
    "md_text": "# Training Machine Learning Models by Regularizing their Explanations\n# Andrew Slavin Ross\n# The Institute for Applied Computational Science\nThe Institute for Applied Computational Science\nHarvard University Cambridge, Massachusetts May 2018\nc\u20dd2018 Andrew Slavin Ross All rights reserved.\nThesis Advisor: Finale Doshi-Velez\n# Training Machine Learning Models by Regularizing their Explanations\n# Abstract\nNeural networks are among the most accurate supervised learning methods in use today. However, their opacity makes them difficult to trust in critical applications, especially when conditions in training may differ from those in practice. Recent efforts to develop explanations for neural networks and machine learning models more generally have produced tools to shed light on the implicit rules behind predictions. These tools can help us identify when models are right for the wrong reasons. However, they do not always scale to explaining predictions for entire datasets, are not always at the right level of abstraction, and most importantly cannot correct the problems they reveal. In this thesis, we explore the possibility of training machine learning models (with a particular focus on neural networks) using explanations themselves. We consider approaches where models are penalized not only for making incorrect predictions but also for providing explanations that are either inconsistent with domain knowledge or overly complex. These methods let us train models which can not only provide more interpretable rationales for their predictions but also generalize better when training data is confounded or meaningfully different from test data (even adversarially so).\nAuthor: Andrew Slavin Ross\n# Contents\n# Introduction\n# 1 Introduction\n# 2 Right for the Right Reasons\nRight for the Right Reasons 6 2.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 2.1.1 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 2.1.2 Background: Input Gradient Explanations . . . . . . . . . . . . . . . . 9 2.2 Our Approach . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 2.2.1 Loss Functions that Constrain Explanations . . . . . . . . . . . . . . . 10 2.2.2 Find-Another-Explanation: Discovering Many Possible Rules without Annotations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 2.3 Empirical Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 2.3.1 Toy Color Dataset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 2.3.2 Real-world Datasets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 2.3.3 Limitations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 2.4 Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22 Appendix 2.A Cross-Validation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 Appendix 2.B Learning with Less Data . . . . . . . . . . . . . . . . . . . . . . . . 24 Appendix 2.C Simultaneous Find-Another-Explanation . . . . . . . . . . . . . . . 25\n# 3 Interpretability and Robustness\n3.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.2 Background . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.2.1 Attacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.2.2 Defenses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.3 Gradient Regularization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.4 Experiments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 3.2 Background . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 3.2.1 Attacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 3.2.2 Defenses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 3.3 Gradient Regularization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 3.4 Experiments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n2 4\n3.4.1 Accuracy Evaluations (FGSM and TGSM) . . . . . . . . . . . . . . . . 3 3.4.2 Human Subject Study (JSMA and Iterated TGSM) . . . . . . . . . . . . 3 3.4.3 Connections to Interpretability . . . . . . . . . . . . . . . . . . . . . . . 4 3.5 Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n# 4 General Explanation Regularization 4.1 Alternative Input Gradient Pena\n# 4 General Explanation Regularization\n4.1 Alternative Input Gradient Penalties \n4.1.1 L1 Regularization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4.1.2 Higher-Order Derivatives . . . . . . . . . . . . . . . . . . . . . . . . . . 4.2 Heftier Surrogates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4.3 Examples and Exemplars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4.4 Emergent Abstractions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4.5 Interpretability Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4.6 Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n4.1.1 L1 Regularization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4.1.2 Higher-Order Derivatives . . . . . . . . . . . . . . . . . . . . . . . . . . 4.2 Heftier Surrogates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4.3 Examples and Exemplars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4.4 Emergent Abstractions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4.5 Interpretability Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4.6 Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n# 5 Conclusion\n# References\n35 38 42 43\n# Chapter 1\n# Introduction\nmotivation for this thesis is easiest to express with a story:\nA father decides to teach his young son what a sports car is. Finding it difficult to explain in words, he decides to give some examples. They stand on a motorway bridge and as each car passes underneath, the father cries out \u201cthat\u2019s a sports car!\u201d when a sports car passes by. After ten minutes, the father asks his son if he\u2019s understood what a sports car is. The son says, \u201csure, it\u2019s easy\u201d. An old red VW Beetle passes by, and the son shouts \u2013 \u201cthat\u2019s a sports car!\u201d. Dejected, the father asks \u2013 \u201cwhy do you say that?\u201d. \u201cBecause all sports cars are red!\u201d, replies the son. (Barber, 2012)\n# There is another popular version that pokes fun at the Department of Defense:\nThere is another popular version that pokes fun at the Department of Defense:\nIn the early days of the perceptron the army decided to train an artificial neural network to recognize tanks partly hidden behind trees in the woods. They took a number of pictures of a woods without tanks, and then pictures of the same woods with tanks clearly sticking out from behind trees. They then trained a net to discriminate the two classes of pictures. The results were impressive, and the army was even more impressed when it turned out that the net could generalize its knowledge to pictures from each set that had not been used in training the net. Just to make sure that the net had indeed learned to recognize partially hidden tanks, however, the researchers took some more pictures in the same woods and showed them to the trained net. They were shocked and depressed to find that with the new pictures the net totally failed to discriminate between pictures of trees with partially concealed tanks behind them and just plain trees. The mystery was finally solved when someone noticed that the training pictures of the woods without tanks were taken on a cloudy day, whereas those with tanks\nwere taken on a sunny day. The net had learned to recognize and generalize the difference between a woods with and without shadows! (Dreyfus and Dreyfus, 1992)\nwere taken on a sunny day. The net had learned to recognize and generalize the difference between a woods with and without shadows! (Dreyfus and Dreyfus,\nThe first story is a parable and the second is apocryphal1, but both illustrate an inherent limitation in learning by example, which is how we currently train machine learning systems: we only provide them with inputs (questions, X) and outputs (answers, y). When we train people to perform tasks, however, we usually provide them with explanations, since without them many problems are ambiguous. In machine learning, model developers usually circumvent such ambiguities via regularization, inductive biases (e.g. using CNNs when you need translational invariance), or simply acquiring vast quantities of data (such that the problem eventually becomes unambiguous, as if the child had seen every car in the world). But there is still a risk our models will be right for the wrong reasons \u2013 which means that if conditions change, they will simply be wrong. As we begin to use ML in sensitive domains such as healthcare, this risk has highlighted the need for interpretable models, as this final story illustrates:\nAlthough models based on rules were not as accurate as the neural net models, they were intelligible, i.e., interpretable by humans. On one of the pneumonia datasets, the rule-based system learned the rule \u201cHasAsthma(x) \u2192LowerRisk(x)\u201d, i.e., that patients with pneumonia who have a history of asthma have lower risk of dying from pneumonia than the general population. Needless to say, this rule is counterintuitive. But it reflected a true pattern in the training data: patients with a history of asthma who presented with pneumonia usually were admitted not only to the hospital but directly to the ICU (Intensive Care Unit). The good news is that the aggressive care received by asthmatic pneumonia patients was so effective that it lowered their risk of dying from pneumonia compared to the general population. The bad news is that because the prognosis for these patients is better than average, models trained on the data incorrectly learn that asthma lowers risk, when in fact asthmatics have much higher risk (if not hospitalized). (Caruana et al., 2015)\nIn this case, a pneumonia risk prediction model learned an unhelpful rule because it training outcomes didn\u2019t actually represent medical risk. Had the model been put int\n1https://www.gwern.net/Tanks\nproduction, it would have endangered lives. The fact that they used an interpretable model let them realize and avoid this danger (by not using the neural network at all). But clearly, the dataset they used still contains information that, say, a human analyst could use to draw useful conclusions about how to treat pneumonia. How can machine learning models utilize it despite its flaws? This thesis seeks to provide both concrete methods for addressing these types of problems in specific cases and more abstract arguments about how they should be solved in general. The main strategy we will consider is explanation regularization, which means jointly optimizing a machine learning model to make correct predictions and to explain those predictions well. Quantifying the quality of an explanation may seem difficult (especially if we would like it to be differentiable), but we will delve into cases where it is straightforward and intuitive, as well as strategies for making it so.\n# 1.1 Contributions\nThe major contributions of this thesis are as follows:\n\u2022 It presents a framework for encoding domain knowledge about a classification problem as local penalties on the gradient of the model\u2019s decision surface, which can be incorporated into the loss function of any differentiable model (e.g. a neural network). Applying this framework in both supervised and unsupervised formulations, it trains models that generalize to test data from different distributions, which would otherwise be unobtainable by traditional optimization methods. (Chapter 2) \u2022 It applies a special case of this framework (where explanations are regularized to be simple) to the problem of defending against adversarial examples. It demonstrates increased robustness of regularized models to white- and black-box attacks, at a level comparable or better than adversarial training. It also demonstrates both increased transferability and interpretability of adversarial examples created to fool regularized models, which we evaluate in a human subject experiment. (Chapter 3)\n It considers cases where we can meaningfully change what models learn by regularizing more general types of explanations. We review literature and suggest directions for explanation regularization, using sparse gradients, input Hessians, decision trees, nearest neighbors, and even abstract concepts that emerge or that we encourage to emerge in deep neural networks. It concludes by outlining an interface for interpretable machine teaching. (Chapter 4)\n# Right for the Right Reasons1\n# 2.1 Introduction\nHigh-dimensional real-world datasets are often full of ambiguities. When we train classifiers on such data, it is frequently possible to achieve high accuracy using classifiers with qualitatively different decision boundaries. To narrow down our choices and encourage robustness, we usually employ regularization techniques (e.g. encouraging sparsity or small parameter values). We also structure our models to ensure domain-specific invariances (e.g. using convolutional neural nets when we would like the model to be invariant to spatial transformations). However, these solutions do not address situations in which our training dataset contains subtle confounds or differs qualitatively from our test dataset. In these cases, our model may fail to generalize no matter how well it is tuned. Such generalization gaps are of particular concern for uninterpretable models such as neural networks, especially in sensitive domains. For example, Caruana et al. (2015) describe a model intended to prioritize care for patients with pneumonia. The model was trained to predict hospital readmission risk using a dataset containing attributes of patients hospitalized at least once for pneumonia. Counterintuitively, the model learned that the\n1Significant portions of this chapter also appear in Ross, A. S., Hughes, M. C. and Doshi-Velez, F. (2017b) Right for the right reasons: Training differentiable models by constraining their explanations. In Proceedings of the Twenty-Sixth International Joint Conference on Artificial Intelligence, pp. 2662\u20132670.\npresence of asthma was a negative predictor of readmission, when in reality pneumonia patients with asthma are at a greater medical risk. This model would have presented a grave safety risk if used in production. This problem occurred because the outcomes in he dataset reflected not just the severity of patients\u2019 diseases but the quality of care they nitially received, which was higher for patients with asthma. This case and others like it have motivated recent work in interpretable machine learning, where algorithms provide explanations for domain experts to inspect for correctness before rusting model predictions. However, there has been limited work in optimizing models to find not just the right prediction but also the right explanation. Toward this end, this work makes the following contributions: \u2022 We confirm empirically on several datasets that input gradient explanations match state of the art sample-based explanations (e.g. LIME, Ribeiro (2016)). \u2022 Given annotations about incorrect explanations for particular inputs, we efficiently optimize the classifier to learn alternate explanations (to be right for better reasons). \u2022 When annotations are not available, we sequentially discover classifiers with similar accuracies but qualitatively different decision boundaries for domain experts to inspect for validity.\n# 2.1.1 Related Work\nWe first define several important terms in interpretable machine learning. All classifiers have implicit decision rules for converting an input into a decision, though these rules may be opaque. A model is interpretable if it provides explanations for its predictions in a form humans can understand; an explanation provides reliable information about the model\u2019s implicit decision rules for a given prediction. In contrast, we say a machine learning model is accurate if most of its predictions are correct, but only right for the right reasons if the implicit rules it has learned generalize well and conform to domain experts\u2019 knowledge about the problem.\nExplanations can take many forms (Keil, 2006) and evaluating the quality of explanations or the interpretability of a model is difficult (Lipton, 2016; Doshi-Velez and Kim, 2017). However, within the machine learning community recently there has been convergence (Lundberg and Lee, 2016) around local counterfactual explanations, where we show how perturbing an input x in various ways will affect the model\u2019s prediction \u02c6y. This approach to explanations can be domain- and model-specific (e.g. \u201cannotator rationales\u201d used to explain text classifications by Li et al. (2016); Lei et al. (2016); Zhang et al. (2016)). Alternatively, explanations can be model-agnostic and relatively domain-general, as exemplified by LIME (Local Interpretable Model-agnostic Explanations, Ribeiro et al. (2016); Singh et al. (2016)) which trains and presents local sparse models of how predictions change when inputs are perturbed. The per-example perturbing and fitting process used in models such as LIME can be computationally prohibitive, especially if we seek to explain an entire dataset during each training iteration. If the underlying model is differentiable, one alternative is to use input gradients as local explanations (Baehrens et al. (2010) provides a particularly good introduction; see also Selvaraju et al. (2016); Simonyan et al. (2013); Li et al. (2015); Hechtlinger (2016)). The idea is simple: the gradients of the model\u2019s output probabilities with respect to its inputs literally describe the model\u2019s decision boundary (see Figure 2.1). They are similar in spirit to the local linear explanations of LIME but much faster to compute. Input gradient explanations are not perfect for all use-cases\u2014for points far from the decision boundary, they can be uniformatively small and do not always capture the idea of salience (see discussion and alternatives proposed by Shrikumar et al. (2016); Bach et al. (2015); Montavon et al. (2017); Sundararajan et al. (2017); Fong and Vedaldi (2017)). However, they are exactly what is required for constraining the decision boundary. In the past, Drucker and Le Cun (1992) showed that applying penalties to input gradient magnitudes can improve generalization; to our knowledge, our application of input gradients to constrain explanations and find alternate explanations is novel. More broadly, none of the works above on interpretable machine learning attempt to\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/bf50/bf505f94-9576-4ff8-a02e-8e4b5d78c056.png\" style=\"width: 50%;\"></div>\nFigure 2.1: Input gradients lie normal to the model\u2019s decision boundary. Examples above are for simple 2D, two- and three-class datasets, with input gradients taken with respect to a two hidden layer multilayer perceptron with ReLU activations. Probability input gradients are sharpest near decision boundaries, while log probability input gradients are more consistent within decision regions. The sum of log probability gradients contains information about the full model.\noptimize explanations for correctness. For SVMs and specific text classification architectures, there exists work on incorporating human input into decision boundaries in the form of annotator rationales (Zaidan et al., 2007; Donahue and Grauman, 2011; Zhang et al., 2016). Unlike our approach, these works are either tailored to specific domains or do not fully close the loop between generating explanations and constraining them.\n# 2.1.2 Background: Input Gradient Explanations\nConsider a differentiable model f parametrized by \u03b8 with inputs X \u2208RN\u00d7D and probability vector outputs f (X|\u03b8) = \u02c6y \u2208RN\u00d7K corresponding to one-hot labels y \u2208RN\u00d7K. Its input gradient is given by fX(Xn|\u03b8) or \u2207X \u02c6yn, which is a vector normal to the model\u2019s decision boundary at Xn and thus serves as a first-order description of the model\u2019s behavior near Xn. The gradient has the same shape as each vector Xn; large-magnitude values of the input gradient indicate elements of Xn that would affect \u02c6y if changed. We can visualize explanations by highlighting portions of Xn in locations with high input gradient magnitudes.\n# 2.2 Our Approach\nWe wish to develop a method to train models that are right for the right reasons. If explanations faithfully describe a model\u2019s underlying behavior, then constraining its explanations to match domain knowledge should cause its underlying behavior to more closely match that knowledge too. We first describe how input gradient-based explanations lend themselves to efficient optimization for correct explanations in the presence of domain knowledge, and then describe how they can be used to efficiently search for qualitatively different decision boundaries when such knowledge is not available.\n# 2.2.1 Loss Functions that Constrain Explanations\nWhen constraining input gradient explanations, there are two basic options: we can either constrain them to be large in relevant areas or small in irrelevant areas. However, because input gradients for relevant inputs in many models should be small far from the decision boundary, and because we do not know in advance how large they should be, we opt to shrink irrelevant gradients instead. Formally, we define an annotation matrix A \u2208{0, 1}N\u00d7D, which are binary masks indicating whether dimension d should be irrelevant for predicting observation n. We would like \u2207X \u02c6y to be near 0 at these locations. To that end, we optimize a loss function L(\u03b8, X, y, A) of the form\n\ufffd \ufffd\ufffd \ufffd \ufffd \ufffd\ufffd \ufffd \ufffd\ufffd\ufffd\ufffd which contains familiar cross entropy and \u03b8 regularization terms along with a new regularization term that discourages the input gradient from being large in regions marked by A. This term has a regularization parameter \u03bb1 which should be set such that the \u201cright answers\u201d and \u201cright reasons\u201d terms have similar orders of magnitude; see Appendix 2.A for more details. Note that this loss penalizes the gradient of the log probability, which performed best in practice, though in many visualizations we show fX, which is the gradient\nof the predicted probability itself. Summing across classes led to slightly more stable results than using the predicted class log probability max log( \u02c6yk), perhaps due to discontinuities near the decision boundary (though both methods were comparable). We did not explore regularizing input gradients of specific class probabilities, though this would be a natural extension. Because this loss function is differentiable with respect to \u03b8, we can easily optimize it with gradient-based optimization methods. We do not need annotations (nonzero An) for every input in X, and in the case A = 0N\u00d7D, the explanation term has no effect on the loss. At the other extreme, when A is a matrix of all 1s, it encourages the model to have small gradients with respect to its inputs; this can improve generalization on its own (Drucker and Le Cun, 1992). Between those extremes, it biases our model against particular implicit rules. This penalization approach enjoys several desirable properties. Alternatives that specify a single Ad for all examples presuppose a coherent notion of global feature importance, but when decision boundaries are nonlinear many features are only relevant in the context of specific examples. Alternatives that simulate perturbations to entries known to be irrelevant (or to determine relevance as in Ribeiro et al. (2016)) require defining domain-specific perturbation logic; our approach does not. Alternatives that apply hard constraints or completely remove elements identified by And miss the fact that the entries in A may be imprecise even if they are human-provided. Thus, we opt to preserve potentially misleading features but softly penalize their use.\n# 2.2.2 Find-Another-Explanation: Discovering Many Possible Rules without An-\n# 2.2.2 Find-Another-Explanation: Discovering Many Possible Rules without An notations\nAlthough we can obtain the annotations A via experts as in Zaidan et al. (2007), we may not always have this extra information or know the \u201cright reasons.\u201d In these cases, we propose an approach that iteratively adapts A to discover multiple models accurate for qualitatively different reasons; a domain expert could then examine them to determine which is the right for the best reasons. Specifically, we generate a \u201cspectrum\u201d of models with different decision\nA0 = 0, \u03b80 = arg min \u03b8 L(\u03b8, X, y, A0), A1 = Mc [ fX|\u03b80] , \u03b81 = arg min \u03b8 L(\u03b8, X, y, A1), A2 = Mc [ fX|\u03b81] \u222aA1, \u03b82 = arg min \u03b8 L(\u03b8, X, y, A2),\nwhere the function Mc returns a binary mask indicating which gradient components have a magnitude ratio (their magnitude divided by the largest component magnitude) of at least c and where we abbreviated the input gradients of the entire training set X at \u03b8i as fX|\u03b8i. In other words, we regularize input gradients where they were largest in magnitude previously. If, after repeated iterations, accuracy decreases or explanations stop changing (or only change after significantly increasing \u03bb1), then we may have spanned the space of possible models.2 All of the resulting models will be accurate, but for different reasons; although we do not know which reasons are best, we can present them to a domain expert for inspection and selection. We can also prioritize labeling or reviewing examples about which the ensemble disagrees. Finally, the size of the ensemble provides a rough measure of dataset redundancy.\n# 2.3 Empirical Evaluation\nWe demonstrate explanation generation, explanation constraints, and the find-anotherexplanation method on a toy color dataset and three real-world datasets. In all cases, we used a multilayer perceptron with two hidden layers of size 50 and 30, ReLU nonlinearities with a softmax output, and a \u03bb2 = 0.0001 penalty on \u2225\u03b8\u22252 2. We trained the network using Adam (Kingma and Ba, 2014) with a batch size of 256 and Autograd (Mclaurin et al., 2017).\n2Though one can design simple pathological cases where we do not discover all models with this method; we explore an alternative version in Appendix 2.C that addresses some of these cases.\nFor most experiments, we used an explanation L2 penalty of \u03bb1 = 1000, which gave our \u201cright answers\u201d and \u201cright reasons\u201d loss terms similar magnitudes. More details about cross-validation are included in Appendix 2.A. For the cutoff value c described in Section 2.2.2 and used for display, we often chose 0.67, which tended to preserve 2-5% of gradient components (the average number of qualifying elements tended to fall exponentially with c). Code for all experiments is available at https://github.com/dtak/rrr.\n# 2.3.1 Toy Color Dataset\nWe created a toy dataset of 5 \u00d7 5 \u00d7 3 RGB images with four possible colors. Images fell into two classes with two independent decision rules a model could implicitly learn: whether their four corner pixels were all the same color, and whether their top-middle three pixels were all different colors. Images in class 1 satisfied both conditions and images in class 2 satisfied neither. Because only corner and top-row pixels are relevant, we expect any faithful explanation of an accurate model to highlight them.\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/c62c/c62cf628-ba63-4533-93e4-119e989ad894.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Figure 2.2: Gradient vs. LIME explanations of nine perceptron predictions on the Toy Color dataset. For gradients, we plot dots above pixels identified by M0.67 [ fX] (the top 33% largest-magnitude input gradients), and for LIME, we select the top 6 features (up to 3 can reside in the same RGB pixel). Both methods suggest that the model learns the corner rule.</div>\nIn Figure 2.2, we see both LIME and input gradients identify the same relevant pixels, which suggests that (1) both methods are effective at explaining model predictions, and (2) the model has learned the corner rather than the top-middle rule, which it did consistently across random restarts. However, if we train our model with a nonzero A (specifically, setting And = 1 for\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/de7b/de7bfa7d-7e91-490d-8413-794cf50b8aca.png\" style=\"width: 50%;\"></div>\nFigure 2.3: Implicit rule transitions as we increase \u03bb1 and the number of nonzero rows of A. Pairs of points represent the fraction of large-magnitude (c = 0.67) gradient components in the corners and top-middle for 1000 test examples, which almost always add to 1 (indicating the model is most sensitive to these elements alone, even during transitions). Note there is a wide regime where the model learns a hybrid of both rules. corners d across examples n), we were able to cause it to use the other rule. Figure 2.3 shows how the model transitions between rules as we vary \u03bb1 and the number of examples penalized by A. This result demonstrates that the model can be made to learn multiple rules despite only one being commonly reached via standard gradient-based optimization methods. However, it depends on knowing a good setting for A, which in this case would still require annotating on the order of 103 examples, or 5% of our dataset (although always including examples with annotations in Adam minibatches let us consistently switch rules with only 50 examples, or 0.2% of the dataset). Finally, Figure 2.4 shows we can use the find-another-explanation technique from Sec. 2.2.2 to discover the other rule without being given A. Because only two rules lead to high accuracy on the test set, the model performs no better than random guessing when prevented from using either one (although we have to increase the penalty high enough that this accuracy number may be misleading - the essential point is that after the first iteration, explanations stop changing). Lastly, though not directly relevant to the discussion on interpretability and explanation, we demonstrate the potential of explanations to reduce the amount of data required for training in Appendix 2.B.\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/7427/74271e7e-ae8c-402c-8469-0d029aa7b180.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\"></div>\n<div style=\"text-align: center;\">Figure 2.4: Rule discovery using find-another-explanation method with 0.67 cutoff and \u03bb1 = 103 for \u03b81 and \u03bb1 = 106 for \u03b82. Note how the first two iterations produce explanations corresponding to the two rules in the dataset while the third produces very noisy explanations (with low accuracies).</div>\n# 2.3.2 Real-world Datasets\nTo demonstrate real-world, cross-domain applicability, we test our approach on variants of three familiar machine learning text, image, and tabular datasets:\n# To demonstrate real-world, cross-domain applicability, we test our approach on variants of three familiar machine learning text, image, and tabular datasets:\n\u2022 20 Newsgroups: As in Ribeiro et al. (2016), we test input gradients on the alt.atheism vs. soc.religion.christian subset of the 20 Newsgroups dataset Lichman (2013). We used the same two-hidden layer network architecture with a TF-IDF vectorizer with 5000 components, which gave us a 94% accurate model for A = 0. \u2022 Iris-Cancer: We concatenated all examples in classes 1 and 2 from the Iris dataset with the the first 50 examples from each class in the Breast Cancer Wisconsin dataset (Lichman, 2013) to create a composite dataset X \u2208R100\u00d734, y \u2208{0, 1}. Despite the dataset\u2019s small size, our network still obtains an average test accuracy of 92% across 350 random 2 3-1 3 training-test splits. However, when we modify our test set to remove the 4 Iris components, average test accuracy falls to 81% with higher variance, suggesting the model learns to depend on Iris features and suffers without them. We verify that\n Decoy MNIST: On the baseline MNST dataset (LeCun et al., 2010), our network obtains 98% train and 96% test accuracy. However, in Decoy MNIST, images x have 4 \u00d7 4 gray swatches in randomly chosen corners whose shades are functions of their digits y in training (in particular, 255 \u221225y) but are random in test. On this dataset, our model has a higher 99.6% train accuracy but a much lower 55% test accuracy, indicating that the decoy rule misleads it. We verify that both gradient and LIME explanations let users detect this issue and that explanation regularization lets us overcome it.\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/a3df/a3df8326-3ba7-464b-81f0-a2d690727b36.png\" style=\"width: 50%;\"></div>\nFigure 2.5: Words identified by LIME vs. gradients on an example from the atheism vs. Christianity subset of 20 Newsgroups. More examples are available at https://github.com/dtak/rrr. Words are blue if they support soc.religion.christian and orange if they support alt.atheism, with opacity equal to the ratio of the magnitude of the word\u2019s weight to the largest magnitude weight. LIME generates sparser explanations but the weights and signs of terms identified by both methods match closely. Note that both methods reveal some aspects of the model that are intuitive (\u201cchurch\u201d and \u201cservice\u201d are associated with Christianity), some aspects that are not (\u201c13\u201d is associated with Christianity, \u201cedu\u201d with atheism), and some that are debatable (\u201cfreedom\u201d is associated with atheism, \u201cfriends\u201d with Christianity).\n# Input gradients are consistent with sample-based methods such as LIME, and faster. On\n20 Newsgroups (Figure 2.5), input gradients are less sparse but identify all of the same words in the document with similar weights. Note that input gradients also identify words outside the document that would affect the prediction if added.\n\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/75e9/75e975d9-fa51-4c52-b37c-f084db08a983.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Figure 2.6: Input gradient explanations for Decoy MNIST vs. LIME, using the LIME image library Ribeiro (2016). In this example, the model incorrectly predicts 3 rather than 7 because of the decoy swatch.</div>\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/6437/64375bfa-a470-4ab2-a0dd-c1dc7eeee1d0.png\" style=\"width: 50%;\"></div>\nFigure 2.7: Iris-Cancer features identified by input gradients vs. LIME, with Iris features highlighted in red. Input gradient explanations are more faithful to the model. Note that most gradients change sign when switching between \u02c6y0 and \u02c6y1, and that the magnitudes of input gradients are different across examples, which provides information about examples\u2019 proximity to the decision boundary.\nOn Decoy MNIST (Figure 2.6), both LIME and input gradients reveal that the model predicts 3 rather than 7 due to the color swatch in the corner. Because of their finegrained resolution, input gradients sometimes better capture counterfactual behavior, where extending or adding lines outside of the digit to either reinforce it or transform it into another digit would change the predicted probability (see also Figure 2.10). LIME, on the other hand, better captures the fact that the main portion of the digit is salient (because its super-pixel perturbations add and remove larger chunks of the digit). On Iris-Cancer (Figure 2.7), input gradients actually outperform LIME. We know from the accuracy difference that Iris features are important to the model\u2019s prediction, but LIME only identifies a single important feature, which is from the Breast Cancer dataset (even when we vary its perturbation strategy). This example, which is tabular and contains\ncontinuously valued rather categorical features, may represent a pathological case for LIME, which operates best when it can selectively mask a small number of meaningful chunks of its inputs to generate perturbed samples. For truly continuous inputs, it should not be surprising that explanations based on gradients perform best. There are a few other advantages input gradients have over sample-based perturbation methods. On 20 Newsgroups, we noticed that for very long documents, explanations generated by the sample-based method LIME are often overly sparse, and there are many words identified as significant by input gradients that LIME ignores. This may be because the number of features LIME selects must be passed in as a parameter beforehand, and it may also be because LIME only samples a fixed number of times. For sufficiently long documents, it is unlikely that sample-based approaches will mask every word even once, meaning that the output becomes increasingly nondeterministic\u2014an undesirable quality for explanations. To resolve this issue, one could increase the number of samples, but that would increase the computational cost since the model must be evalutated at least once per sample to fit a local surrogate. Input gradients, on the other hand, only require on the order of one model evaluation total to generate an explanation of similar quality (generating gradients is similar in complexity to predicting probabilities), and furthermore, this complexity is based on the vector length, not the document length. This issue (underscored by Table 2.1) highlights some inherent scalability advantages input gradients enjoy over sample-based perturbation methods.\nLIME\nGradients\nDimension of x\nIris-Cancer\n0.03s\n0.000019s\n34\nToy Colors\n1.03s\n0.000013s\n75\nDecoy MNIST\n1.54s\n0.000045s\n784\n20 Newsgroups\n2.59s\n0.000520s\n5000\nTable 2.1: Gradient vs. LIME runtimes per explanation. Note that each method uses a different version o LIME; Iris-Cancer and Toy Colors use lime_tabular with continuous and quartile-discrete perturbatio methods, respectively, Decoy MNIST uses lime_image, and 20 Newsgroups uses lime_text. Code wa executed on a laptop and input gradient calculations were not optimized for performance, so runtimes are onl meant to provide a sense of scale.\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/d78f/d78f6c03-5ff7-4608-98a9-eff887f2756b.png\" style=\"width: 50%;\"></div>\nFigure 2.8: Overcoming confounds using explanation constraints on Iris-Cancer (over 350 random train-test splits). By default (A = 0), input gradients tend to be large in Iris dimensions, which results in lower accuracy when Iris is removed from the test set. Models trained with And = 1 in Iris dimensions (full A) have almost exactly the same test accuracy with and without Iris.\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/6a52/6a52646a-f81f-43af-9cc3-f3c52e58e1d6.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Figure 2.9: Training with explanation constraints on Decoy MNIST. Accuracy is low (A = 0) on the swatch color-randomized test set unless the model is trained with And = 1 in swatches (full A). In that case, test accuracy matches the same architecture\u2019s performance on the standard MNIST dataset (baseline).</div>\nGiven annotations, input gradient regularization finds solutions consistent with domain knowledge. Another key advantage of using an explanation method more closely related to our model is that we can then incorporate explanations into our training process, which are most useful when the model faces ambiguities in how to classify inputs. We deliberately constructed the Decoy MNIST and Iris-Cancer datasets to have this kind of ambiguity, where a rule that works in training will not generalize to test. When we train our network on these confounded datasets, their test accuracy is better than random guessing, in part because the decoy rules are not simple and the primary rules not complex, but their performance is still significantly worse than on a baseline test set with no decoy rules. By penalizing\nexplanations we know to be incorrect using the loss function defined in Section 2.2.1, we are able to recover that baseline test accuracy, which we demonstrate in Figures 2.8 and 2.9.\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/6028/6028eb80-219b-4310-94a0-b6e651f2339c.png\" style=\"width: 50%;\"></div>\nFigure 2.10: Find-another-explanation results on Iris-Cancer (top; errorbars show standard deviations across 50 trials), 20 Newsgroups (middle; blue supports Christianity and orange supports atheism, word opacity set to magnitude ratio), and Decoy MNIST (bottom, for three values of \u03bb1 with scatter opacity set to magnitude ratio cubed). Real-world datasets are often highly redundant and allow for diverse models with similar accuracies. On Iris-Cancer and Decoy MNIST, both explanations and accuracy results indicate we overcome confounds after 1-2 iterations without any prior knowledge about them encoded in A.\nWhen annotations are unavailable, our find-another-explanation method discovers diverse classifiers. As we saw with the Toy Color dataset, even if almost every row of A is 0, we can still benefit from explanation regularization (meaning practitioners can gradually incorporate these penalties into their existing models without much upfront investment). However, annotation is never free, and in some cases we either do not know the right explanation or cannot easily encode it. Additionally, we may be interested in exploring the structure of our model and dataset in a less supervised fashion. On real-world datasets, which are usually overdetermined, we can use find-another-explanation to discover \u03b8s in\nshallower local minima that we would normally never explore. Given enough models right for different reasons, hopefully at least one is right for the right reasons. Figure 2.10 shows find-another-explanation results for our three real-world datasets, with example explanations at each iteration above and model train and test accuracy below. For Iris-Cancer, we find that the initial iteration of the model heavily relies on the Iris features and has high train but low test accuracy, while subsequent iterations have lower train but higher test accuracy (with smaller gradients in Iris components). In other words, we spontaneously obtain a more generalizable model without a predefined A alerting us that the first four features are misleading. Find-another-explanation also overcomes confounds on Decoy MNIST, needing only one iteration to recover baseline accuracy. Bumping \u03bb1 too high (to the point where its term is a few orders of magnitude larger than the cross-entropy) results in more erratic behavior. Interestingly, in a process remniscent of distillation (Papernot et al., 2016c), the gradients themselves become more evenly and intuitively distributed at later iterations. In many cases they indicate that the probabilities of certain digits increase when we brighten pixels along or extend their distinctive strokes, and that they decrease if we fill in unrelated dark areas, which seems desirable. However, by the last iteration, we start to revert to using decoy swatches in some cases. On 20 Newsgroups, the words most associated with alt.atheism and soc.religion.christian change between iterations but remain mostly intuitive in their associations. Train accuracy mostly remains high while test accuracy is unstable. For all of these examples, accuracy remains high even as decision boundaries shift significantly. This may be because real-world data tends to contain significant redundancies.\n# 2.3.3 Limitations\nInput gradients provide faithful information about a model\u2019s rationale for a prediction but trade interpretability for efficiency. In particular, when input features are not individually meaningful to users (e.g. for individual pixels or word2vec components), input gradients\nmay be difficult to interpret and A may be difficult to specify. Additionally, because they can be 0 far from the decision boundary, they do not capture the idea of salience as well as other methods (Zeiler and Fergus, 2014; Sundararajan et al., 2017; Montavon et al., 2017; Bach et al., 2015; Shrikumar et al., 2016). However, they are necessarily faithful to the model and easy to incorporate into its loss function. Input gradients are first-order linear approximations of the model; we might call them first-order explanations.\n# 2.4 Discussion\nIn this chapter, we showed that:\n\u2022 On training sets that contain confounds which would fool any model trained just to make correct predictions, we can use gradient-based explanation regularization to learn models that still generalize to test. These results imply that gradient regularization actually changes why our model makes predictions. \u2022 When we lack expert annotations, we can still use our method in an unsupervised manner to discover models that make predictions for different reasons. This \u201cfindanother-explanation\u201d technique allowed us to overcome confounds on Decoy MNIST and Iris-Cancer, and even quantify the ambiguity present in the Toy Color dataset. \u2022 Input gradients are consistent with sample-based methods such as LIME but faster to compute and sometimes more faithful to the model, especially for continuous inputs. Our consistent results on several diverse datasets show that input gradients merit further investigation as building blocks for optimizable explanations; there exist many options for further advancements such as weighted annotations A, different penalty norms, and more general specifications of whether features should be positively or negatively predictive of specific classes for specific inputs. Finally, our \u201cright for the right reasons\u201d approach may be of use in solving related problems, e.g. in integrating causal inference with deep neural networks or maintaining\nrobustness to adversarial examples (which we discuss in Chapter 3). Building on our find-another-explanation results, another promising direction is to let humans in the loop interactively guide models towards correct explanations. Overall, we feel that developing methods of ensuring that models are right for better reasons is essential to overcoming the inherent obstacles to generalization posed by ambiguities in real-world datasets.\n# 2.A Cross-Validation\nMost regularization parameters are selected to maximize accuracy on a validation set. However, when your training and validation sets share the same misleading confounds, validation accuracy may not be a good proxy for test accuracy. Instead, we recommend increasing the explanation regularization strength \u03bb1 until the cross-entropy and \u201cright reasons\u201d terms have roughly equal magnitudes (which corresponds to the region of highest test accuracy below). Intuitively, balancing the terms in this way should push our optimization away from cross-entropy minima that violate the explanation constraints specified in A and towards ones that correspond to \u201cbetter reasons.\u201d Increasing \u03bb1 too much makes the cross-entropy term negligible. In that case, our model performs no better than random guessing.\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/2dd9/2dd9d4e5-3a72-48ae-84d6-3d55353acbc1.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\"></div>\nFigure 2.11: Cross-validating \u03bb1. The regime of highest accuracy (highlighted) is also where the initial cross-entropy and \u03bb1 loss terms have similar magnitudes. Exact equality is not required; being an order of magnitude off does not significantly affect accuracy.\n# 2.B Learning with Less Data\nIt is natural to ask whether explanations can reduce data requirements. Here we explore that question on the Toy Color dataset using four variants of A (with \u03bb1 chosen to match loss terms at each N).\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/e12f/e12feb2a-1907-4e88-b115-0237a19ac915.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Figure 2.12: Explanation regularization can reduce data requirements</div>\nWe find that when A is set to the Pro-Rule 1 mask, which penalizes all pixels except the corners, we reach 95% accuracy with fewer than 100 examples (as compared to A = 0, where we need almost 10000). Penalizing the top-middle pixels (Anti-Rule 2) or all pixels except the top-middle (Pro-Rule 2) also consistently improves accuracy relative to data. Penalizing the corners (Anti-Rule 1), however, reduces accuracy until we reach a threshold N. This may be because the corner pixels can match in 4 ways, while the top-middle pixels can differ in 4 \u00b7 3 \u00b7 2 = 24 ways, suggesting that Rule 2 could be inherently harder to learn from data and positional explanations alone.\n# 2.C Simultaneous Find-Another-Explanation\nIn Section 2.2.2, we introduced a method of training classifiers to make predictions for different reasons by sequentially augmenting A to penalize more features. However, as our ensemble grows, A can saturate to 1N\u00d7D, and subsequent models will be trained with uniform gradient regularization. While these models may have desirable properties (which we explore in the following chapter), they will not be diverse. As a simple example, consider a 2D dataset with one class confined to the first quadrant and the other confined to the third. In theory, we have a full degree of decision freedom; it should be possible to learn two perfect and fully orthogonal boundaries (one horizontal, one vertical). However, when we train our first MLP, it learns a diagonal surface; both features have large gradients everywhere, so A = 1N\u00d72 immediately. To resolve this, we propose a simultaneous training procedure:\nwhere L refers to our single-model loss function, and for our similarity measure we use the squared cosine similarity sim(v, w) = (vTw)2 (vTv)(wTw)+\u03f5, where we add \u03f5 = 10\u22126 to the denominator for numerical stability. Squaring the cosine similarity ensures our penalty is positive, is minimized by orthogonal boundaries, and is soft for nearly orthogonal boundaries. We show in Figure 2.13 that this lets us obtain the two desired models.\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/21fd/21fd4414-d341-45c0-8e8b-607ed735d70f.png\" style=\"width: 50%;\"></div>\nFigure 2.13: Toy 2D problem with one degree of decision boundary freedom. Across random restarts (left two plots), we tend to learn a boundary in which both features are significant, which prevents sequential find-another-explanation from producing diverse models. If we jointly train two models with a penalty on the cosine similarity of their gradients (right plot), they end up with orthogonal boundaries.\n(2.1)\n# Interpretability and Robustness1\n# 3.1 Introduction\nIn the previous chapter, we used input gradient penalties to encourage neural networks to make predictions for specific reasons. We demonstrated this on \u201cdecoy\u201d datasets deliberately designed to deceive models making decisions for different reasons. This philosophy of testing \u2013 that we should measure generalization by testing on data from a different distribution than we trained on \u2013 can be taken to its extreme by testing models in an adversarial setting, where neural networks have known vulnerabilities (Szegedy et al., 2013). In this chapter, we consider whether a domain knowledge-agnostic application of explanation regularization (a uniform L2 penalty on input gradients, similar in spirit to Ridge regression on the model\u2019s local linear approximations) could help defend against adversarial examples. Adversarial examples pose serious obstacles for the adoption of neural networks in settings which are security-sensitive or have legal ramifications (Kang and Kang, 2017). Although many techniques for generating these examples (which we call \u201cattacks\u201d) require access to model parameters, Papernot et al. (2017) have shown that it is possible and even practical to attack black-box models in the real world, in large part because of transferability;\n1Significant portions of this chapter also appear in Ross, A. and Doshi-Velez, F. (2018). Improving the adversarial robustness and interpretability of deep neural networks by regularizing their input gradients. In Proceedings of the Thirty-Second AAAI Conference on Artificial Intelligence.\nexamples generated to fool one model tend to fool all models trained on the same dataset. Particularly for images, these adversarial examples can be constructed to fool models across a variety of scales and perspectives (Athalye and Sutskever, 2017), which poses a problem for the adoption of deep learning models in systems like self-driving cars. Although there has recently been a great deal of research in adversarial defenses, many of these methods have struggled to achieve robustness to transferred adversarial examples (Tram\u00e8r et al., 2017b). Some of the most effective defenses simply detect and reject them rather than making predictions (Xu et al., 2017). The most common, \u201cbrute force\u201d solution is adversarial training, where we include a mixture of normal and adversarially-generated examples in the training set (Kurakin et al., 2016b). However, Tram\u00e8r et al. (2017a) show that the robustness adversarial training provides can be circumvented by randomizing or transferring perturbations from other models (though ensembling helps). As we noted in Chapter 2, domain experts are also often concerned that DNN predictions are uninterpretable. The lack of interpretability is particularly problematic in domains where algorithmic bias is often a factor (Angwin et al., 2016) or in medical contexts where safety risks can arise when there is mismatch between how a model is trained and used (Caruana et al., 2015). For computer vision models (the primary target of adversarial attacks), the most common class of explanation is the saliency map, either at the level of raw pixels, grid chunks, or superpixels (Ribeiro et al., 2016). The local linear approximation provided by raw input gradients (Baehrens et al., 2010) is sometimes used for pixel-level saliency maps (Simonyan et al., 2013). However, computer vision practitioners tend not to examine raw input gradients because they are noisy and difficult to interpret. This issue has spurred the development of techniques like integrated gradients (Sundararajan et al., 2017) and SmoothGrad (Smilkov et al., 2017) that generate smoother, more interpretable saliency maps from noisy gradients. The rationale behind these techniques is that, while the local behavior of the model may be noisy, examining the gradients over larger length scales in input space provides a better intution about the model\u2019s behavior.\nHowever, raw input gradients are exactly what many attacks use to generate adversarial examples. Explanation techniques which smooth out gradients in background pixels may be inappropriately hiding the fact that the model is quite sensitive to them. We consider that perhaps the need for these smoothing techniques in the first place is indicative of a problem with our models, related to their adversarial vulnerability and capacity to overfit. Perhaps it is fundamentally hard for adversarially vulnerable models to be interpretable. On the other hand, perhaps it is hard for interpretable models to be adversarially vulnerable. Our hypothesis is that by training a model to have smooth input gradients with fewer extreme values, it will not only be more interpretable but also more resistant to adversarial examples. In the experiments that follow we confirm this hypothesis using uniform gradient regularization, which optimizes the model to have smooth input gradients with respect to its predictions during training. Using this technique, we demonstrate robustness to adversarial examples across multiple model architectures and datasets, and in particular demonstrate robustness to transferred adversarial examples: gradient-regularized models maintain significantly higher accuracy on examples generated to fool other models than baselines. Furthermore, both qualitatively and in human subject experiments, we find that adversarial examples generated to fool gradient-regularized models are, in a particular sense, more \u201cinterpretable\u201d: they fool humans as well.\n# 3.2 Background\nIn this section, we will (re)introduce notation, and give a brief overview of the baseline attacks and defenses against which we will test and compare our methods. The methods we will analyze again apply to all differentiable classification models f\u03b8(X), which are functions parameterized by \u03b8 that return predictions \u02c6y \u2208RN\u00d7K given inputs X \u2208RN\u00d7D. These predictions indicate the probabilities that each of N inputs in D dimensions belong to each of K class labels. To train these models, we try to find sets of parameters \u03b8\u2217that minimize the total information distance between the predictions \u02c6y and the true labels y (also\nwhich we will sometimes write as\nwith H giving the sum of the cross entropies between the predictions and the labels\nwith H giving the sum of the cross entropies between the predictions and the labels.\n# 3.2.1 Attacks\n# Fast Gradient Sign Method (FGSM)\nGoodfellow et al. (2014) introduced this first method of generating adversarial example by perturbing inputs in a manner that increases the local linear approximation of the lo function:\nby perturbing inputs in a manner that increases the local linear approximation of the loss function: XFGSM = X + \u03f5 sign (\u2207xH(y, \u02c6y)) (3.2) If \u03f5 is small, these adversarial examples are indistinguishable from normal examples to a human, but the network performs significantly worse on them. Kurakin et al. (2016a) noted that one can iteratively perform this attack with a small \u03f5 to induce misclassifications with a smaller total perturbation (by following the nonlinear loss function in a series of small linear steps rather than one large linear step). Targeted Gradient Sign Method (TGSM) A simple modification of the Fast Gradient Sign Method is the Targeted Gradient Sign Method, introduced by Kurakin et al. (2016a). In this attack, we attempt to decrease a modified version of the loss function that encourages the model to misclassify examples in a specific way: \ufffd \ufffd\nXFGSM = X + \u03f5 sign (\u2207xH(y, \u02c6y))\nIf \u03f5 is small, these adversarial examples are indistinguishable from normal examples to a human, but the network performs significantly worse on them. Kurakin et al. (2016a) noted that one can iteratively perform this attack with a small \u03f5 to induce misclassifications with a smaller total perturbation (by following the nonlinear loss function in a series of small linear steps rather than one large linear step).\nIf \u03f5 is small, these adversarial examples are indistinguishable from normal examples to a human, but the network performs significantly worse on them. Kurakin et al. (2016a) noted that one can iteratively perform this attack with a small \u03f5 to induce misclassifications with a smaller total perturbation (by following the nonlinear loss function in a series of small linear steps rather than one large linear step). Targeted Gradient Sign Method (TGSM) A simple modification of the Fast Gradient Sign Method is the Targeted Gradient Sign\nA simple modification of the Fast Gradient Sign Method is the Targeted Gradient Sign Method, introduced by Kurakin et al. (2016a). In this attack, we attempt to decrease a modified version of the loss function that encourages the model to misclassify examples in a specific way: XTGSM = X \u2212\u03f5 sign \ufffd\u2207xH(ytarget, \u02c6y) \ufffd , (3.3)\n(3.1)\n(3.2)\n(3.3)\nwhere ytarget encodes an alternate set of labels we would like the model to predict instead. In the digit classification experiments below, we often picked targets by incrementing the labels y by 1 (modulo 10), which we will refer to as y+1. The TGSM can also be performed iteratively.\nJacobian-based Saliency Map Approach (JSMA)\nThe final attack we consider, the Jacobian-based Saliency Map Approach (JSMA), also takes an adversarial target vector ytarget. It iteratively searches for pixels or pairs of pixels in X to change such that the probability of the target label is increased and the probability of all other labels are decreased. This method is notable for producing examples that have only been changed in several dimensions, which can be hard for humans to detect. For a full description of the attack, we refer the reader to Papernot et al. (2016b).\n# 3.2.2 Defenses\nAs baseline defenses, we consider defensive distillation and adversarial training. To simplify comparison, we omit defenses (Xu et al., 2017; Nayebi and Ganguli, 2017) that are not fully architecture-agnostic or which work by detecting and rejecting adversarial examples.\n# Distillation\nDistillation, originally introduced by Ba and Caruana (2014), was first examined as a potential defense by Papernot et al. (2016c). The main idea is that we train the model twice, initially using the one-hot ground truth labels but ultimately using the initial model\u2019s softmax probability outputs, which contain additional information about the problem. Since the normal softmax function tends to converge very quickly to one-hot-ness, we divide all of the logit network outputs (which we will call \u02c6zk instead of the probabilities \u02c6yk) by a temperature T (during training but not evaluation):\nfT,\u03b8(Xn)k = e\u02c6zk(Xn)/T \u2211K i=1 e\u02c6zi(Xn)/T ,\n(3.4)\nwhere we use fT,\u03b8 to denote a network ending in a softmax with temperature T. Note tha as T approaches \u221e, the predictions converge to 1 K. The full process can be expressed as\nDistillation is usually used to help small networks achieve the same accuracy as larger DNNs, but in a defensive context, we use the same model twice. It has been shown to be an effective defense against white-box FGSM attacks, but Carlini and Wagner (2016) have shown that it is not robust to all kinds of attacks. We will see that the precise way it defends against certain attacks is qualitatively different than gradient regularization, and that it can actually make the models more vulnerable to attacks than an undefended model.\n# Adversarial Training\nIn adversarial training (Kurakin et al., 2016b), we increase robustness by injecting adversarial examples into the training procedure. We follow the method implemented in Papernot et al. (2016a), where we augment the network to run the FGSM on the training batches and compute the model\u2019s loss function as the average of its loss on normal and adversarial examples without allowing gradients to propogate so as to weaken the FGSM attack (which would also make the method second-order). We compute FGSM perturbations with respect to predicted rather than true labels to prevent \u201clabel leaking,\u201d where our model learns to classify adversarial examples more accurately than regular examples.\n# 3.3 Gradient Regularization\nWe defined our \u201cright for the right reasons\u201d objective in Chapter 2 using an L2 penalty on the gradient of the model\u2019s predictions across classes with respect to input features marked irrelevant by domain experts. We encoded their domain knowledge using an annotation matrix A. If we set A = 1, however, and consider only the log-probabilities of\n(3.5)\nthe predicted classes, we recover what Drucker and Le Cun (1992) introduced as \u201cdouble backpropagation\u201d, which trains neural networks by minimizing not just the \u201cenergy\u201d of the network but the rate of change of that energy with respect to the input features. In their formulation the energy is a quadratic loss, but we can reformulate it almost equivalently using the cross-entropy:\nwhose objective we can write a bit more concisely as\narg min H(y, \u02c6y) + \u03bb||\u2207xH(y, \u02c6y)||2 2,\nwhere \u03bb is again a hyperparameter specifying the penalty strength. The intuitive objective of this function is to ensure that if any input changes slightly, the divergence between the predictions and the labels will not change significantly (though including this term does not guarantee Lipschitz continuity everywhere). Double backpropagation was mentioned as a potential adversarial defense in the same paper which introduced defensive distillation (Papernot et al., 2016c), but at publish time, its effectiveness in this respect had not yet been analyzed in the literature \u2013 though Gu and Rigazio (2014) previously and Hein and Andriushchenko (2017); Czarnecki et al. (2017) concurrently consider related objectives, and Raghunathan et al. (2018) derive and minimze an upper bound on adversarial vulnerability based on the maximum gradient norm in a ball around each training input. These works also provide stronger theoretical explanations for why input gradient regularization is effective, though they do not analyze its relationship to model interpretability. In this work, we interpret gradient regularization as a quadratic penalty on our model\u2019s saliency map.\n(3.6)\n# 3.4 Experiments\nDatasets and Models\nWe evaluated the robustness of distillation, adversarial training, and gradient regularization to the FGSM, TGSM, and JSMA on MNIST (LeCun et al., 2010), Street-View House Numbers (SVHN) (Netzer et al., 2011), and notMNIST Butalov (2011). On all datasets, we test a simple convolutional neural network with 5x5x32 and 5x5x64 convolutional layers followed by 2x2 max pooling and a 1024-unit fully connected layer, with batch-normalization after all convolutions and both batch-normalization and dropout on the fully-connected layer. All models were implemented in Tensorflow and trained using Adam (Kingma and Ba, 2014) with \u03b1 = 0.0002 and \u03f5 = 10\u22124 for 15000 minibatches of size of 256. For SVHN, we prepare training and validation set as described in Sermanet et al. (2012), converting the images to grayscale following Grundland and Dodgson (2007) and applying both global and local contrast normalization.\n# Attacks and Defenses\nFor adversarial training and JSMA example generation, we used the Cleverhans adversarial example library (Papernot et al., 2016a). For distillation, we used a softmax temperature of T = 50, and for adversarial training, we trained with FGSM perturbations at \u03f5 = 0.3, averaging normal and adversarial losses. For gradient regularized models, we use double backpropagation, which provided the best robustness, and train over a spread of \u03bb values. We choose the \u03bb with the highest accuracy against validation black-box FGSM examples but which is still at least 97% as accurate on normal validation examples (though accuracy on normal examples tended not to be significantly different). Code for all models and experiments has been open-sourced2.\n2https://github.com/dtak/adversarial-robustness-public\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/c241/c2415f0e-3fd1-4e56-85d5-944fd0d9c966.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\"></div>\n<div style=\"text-align: center;\"></div>\nFigure 3.1: Accuracy of all CNNs on FGSM examples generated to fool undefended models, defensively distilled, adversarially trained, and gradient regularized models (from left to right) on MNIST, SVHN and notMNIST (from top to bottom). Gradient-regularized models are the most resistant to other models\u2019 adversarial examples at high \u03f5, while all models are fooled by gradient-regularized model examples. On MNIST and notMNIST, distilled model examples are usually identical to non-adversarial examples (due to gradient underflow), so they fail to fool any of the other models.\n# Evaluation Metrics\nFor the FGSM and TGSM, we test all models against adversarial examples generated for each model and report accuracy. Testing this way allows us to simultaneously measure whiteand black-box robustness. On the JSMA and iterated TGSM, we found that measuring accuracy was no longer a good evaluation metric, since for our gradient-regularized models, the generated adversarial examples often resembled their targets more than their original labels. To investigate this, we performed a human subject experiment to evaluate the legitimacy of adversarial example misclassifications.\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/f604/f604daa2-6f6a-4896-87c4-5f5f5d8e92c0.png\" style=\"width: 50%;\"></div>\nFigure 3.2: Applying both gradient regularization and adversarial training (\u201cboth defenses\u201d) allows us to obtain maximal robustness to white-box and normal black-box attacks on SVHN (with a very slight label leaking effect on the FGSM, perhaps due to the inclusion of the \u2207xH(y, \u02c6y) term). However, no models are able to maintain robustness to black-box attacks using gradient regularization.\n# 3.4.1 Accuracy Evaluations (FGSM and TGSM)\n# FGSM Robustness\nFigure 3.1 shows the results of our defenses\u2019 robustness to the FGSM on MNIST, SVHN, and notMNIST for our CNN at a variety of perturbation strengths \u03f5. Consistently across datasets, we find that gradient-regularized models exhibit strong robustness to black-box transferred FGSM attacks (examples produced by attacking other models). Although adversarial training sometimes performs slightly better at \u03f5 \u22640.3, the value we used in training, gradient regularization generally surpasses it at higher \u03f5 (see the green curves in the leftmost plots). The story with white-box attacks is more interesting. Gradient-regularized models are generally more robust to than undefended models (visually, the green curves in the rightmost plots fall more slowly than the blue curves in the leftmost plots). However, accuracy still eventually falls for them, and it does so faster than for adversarial training. Even though their robustness to white-box attacks seems lower, though, the examples produced by those white-box attacks actually fool all other models equally well. This effect is particularly pronounced on SVHN. In this respect, gradient regularization may\nhold promise not just as a defense but as an attack, if examples generated to fool them are inherently more transferable. Models trained with defensive distillation in general perform no better and often worse than undefended models. Remarkably, except on SVHN, attacks against distilled models actually fail to fool all models. Closer inspection of distilled model gradients and examples themselves reveals that this occurs because distilled FGSM gradients vanish \u2013 so the examples are not perturbed at all. As soon as we obtain a nonzero perturbation from a different model, distillation\u2019s appearance of robustness vanishes as well. Although adversarial training and gradient regularization seem comparable in terms of accuracy, they work for different reasons and can be applied in concert to increase robustness, which we show in Figure 3.2. In Figure 3.3 we also show that, on normal and adversarially trained black-box FGSM attacks, models trained with these two defenses are fooled by different sets of adversarial examples. We provide intuition for why this might be the case in Figure 3.4.\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/905d/905d3fcd-d187-41a0-83e4-dafdd3d0aeb7.png\" style=\"width: 50%;\"></div>\n\nFigure 3.3: Venn diagrams showing overlap in which MNIST \u03f5 = 0.4 FGSM examples, generated for normal, adversarially trained, and gradient regularized models, fool all three. Undefended models tend to be fooled by examples from all models, while the sets of adversarially trained model FGSM examples that fool the two defended models are closer to disjoint. Gradient-regularized model FGSM examples fool all models. These results suggest that ensembling different forms of defense may be effective in defending against black box attacks (unless those black box attacks use a gradient-regularized proxy).\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/7f4c/7f4c5527-74a6-48f7-99af-ddb53355b555.png\" style=\"width: 50%;\"></div>\n\nFigure 3.4: Conceptual illustration of the difference between gradient regularization and gradient masking. In (idealized) gradient masking, input gradients are completely uninformative, so following them doesn\u2019t affect either the masked model\u2019s predictions or those of any other model. In gradient regularization, gradients actually become more informative, so following them will ultimately fool all models. However, because gradients are also smaller, perturbations need to be larger to flip predictions. Unregularized, unmasked models are somewhere in between. We see quantitative support for this interpretation in Figure 3.3, as well as qualitative evidence in Figure 3.9.\n<div style=\"text-align: center;\">Figure 3.4: Conceptual illustration of the difference between gradient regularization and gradient masking. In (idealized) gradient masking, input gradients are completely uninformative, so following them doesn\u2019t affect either the masked model\u2019s predictions or those of any other model. In gradient regularization, gradients actually become more informative, so following them will ultimately fool all models. However, because gradients are also smaller, perturbations need to be larger to flip predictions. Unregularized, unmasked models are somewhere in between. We see quantitative support for this interpretation in Figure 3.3, as well as qualitative evidence in Figure 3.9.</div>\n# TGSM Robustness\nAgainst the TGSM attack (Figure 3.5), defensively distilled model gradients no longer vanish, and accordingly these models start to show the same vulnerability to adversarial attacks as others. Gradient-regularized models still exhibit the same robustness even at large perturbations \u03f5, and again, examples generated to fool them fool other models equally well. One way to better understand the differences between gradient-regularized, normal, and distilled models is to examine the log probabilities they output and the norms of their loss function input gradients, whose distributions we show in Figure 3.6 for MNIST. We can see that the different defenses have very different statistics. Probabilities of non-predicted classes tend to be small but remain nonzero for gradient-regularized models, while they vanish\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/4d1d/4d1d2592-072d-49c8-a794-1c4b89633117.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\"></div>\n<div style=\"text-align: center;\">Figure 3.5: CNN accuracy on y+1 TGSM examples generated to fool the four models on three dataset (see Figure 3.1 for more explanation). Gradient-regularized models again exhibit robustness to other models adversarial examples. Distilled model adversarial perturbations fool other models again since their inpu gradients no longer underflow.</div>\non defensively distilled models evaluated at T = 0 (despite distillation\u2019s stated purpose of discouraging certainty). Perhaps because \u2207log p(x) = 1 p(x)\u2207p(x), defensively distilled models\u2019 non-predicted log probability input gradients are the largest by many orders of magnitude, while gradient-regularized models\u2019 remain controlled, with much smaller means and variances. The other models lie between these two extremes. While we do not have a strong theoretical argument about what input gradient magnitudes should be, we believe it makes intuitive sense that having less variable, well-behaved, and non-vanishing input gradients should be associated with robustness to attacks that consist of small perturbations in input space.\n# 3.4.2 Human Subject Study (JSMA and Iterated TGSM) Need for a Study\n# 3.4.2 Human Subject Study (JSMA and Iterated TGSM)\n# Need for a Study\nAccuracy scores against the JSMA can be misleading, since without a maximum distortion constraint it necessarily runs until the model predicts the target. Even with such a constraint,\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/5150/5150728a-be53-45e6-992b-21ccf88cb2e1.png\" style=\"width: 50%;\"></div>\nFigure 3.6: Distributions of (L2 norm) magnitudes of FGSM input gradients (top), TGSM input gradients (middle), and predicted log probabilities across all classes (bottom) for each defense. Note the logarithmic scales. Gradient-regularized models tend to assign non-predicted classes higher probabilities, and the L2 norms of the input gradients of their FGSM and TGSM loss function terms have similar orders of magnitude. Distilled models (evaluated at T = 0) assign extremely small probabilities to all but the predicted class, and their TGSM gradients explode while their FGSM gradients vanish (we set a minimum value of 10\u221220 to prevent underflow). Normal and adversarially trained models lie somewhere in the middle.\n# \nFigure 3.7: Results of applying the JSMA to MNIST 0 and 1 images with maximum distortion parameter \u03b3 = 0.25 for a distilled model (left) and a gradient-regularized model (right). Examples in each row start out as the highlighted digit but are modified until the model predicts the digit corresponding to their column or the maximum distortion is reached.\nthe perturbations it creates sometimes alter the examples so much that they no longer resemble their original labels, and in some cases bear a greater resemblance to their targets. Figure 3.7 shows JSMA examples on MNIST for gradient-regularized and distilled models which attempt to convert 0s and 1s into every other digit. Although all of the perturbations \u201csucceed\u201d in changing the model\u2019s prediction, in the gradient-regularized case, many of the JSMA examples strongly resemble their targets. The same issues occur for other attack methods, particularly the iterated TGSM, for which we show confusion matrices for different models and datasets in Figure 3.8. For the gradient-regularized models, these psuedo-adversarial examples quickly become almost prototypical examples of their targets, which is not reflected in accuracies with respect to the original labels. To test these intuitions more rigorously, we ran a small pilot study with 11 subjects\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/46a6/46a67716-2f9d-4881-8353-b34d25c5142b.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\"></div>\n\nFigure 3.8: Partial confusion matrices showing results of applying the iterated TGSM for 15 iterations at \u03f5 = 0.1. Each row is generated from the same example but modified to make the model to predict every other class. TGSM examples generated for gradient-regularized models (right) resemble their targets more than their original labels and may provide insight into what the model has learned. Animated versions of these examples can be seen at http://goo.gl/q8ZM1T.\nFigure 3.8: Partial confusion matrices showing results of applying the iterated TGSM for 15 iterations at \u03f5 = 0.1. Each row is generated from the same example but modified to make the model to predict every other class. TGSM examples generated for gradient-regularized models (right) resemble their targets more than their original labels and may provide insight into what the model has learned. Animated versions of these examples can be seen at http://goo.gl/q8ZM1T.\nto measure whether they found examples generated by these methods to be more or less plausible instances of their targets.\nStudy Protocol\n# Study Protocol\nThe pilot study consisted of a quantitative and qualitative portion. In the quantitative portion, subjects were shown 30 images of MNIST JSMA or SVHN iterated TGSM examples. Each of the 30 images corresponded to one original digit (from 0 to 9) and one model (distilled, gradient-regularized, or undefended). Note that for this experiment, we used \u2207xH( 1 K, \u02c6y) gradient regularization, ran the TGSM for just 10 steps, and trained models for 4 epochs at a learning rate of 0.001. This procedure was sufficient to produce examples with explanations similar to the longer training procedure used in our earlier experiments, and actually increased the robustness of the undefended models (adversarial accuracy tends to fall with training iteration). Images were chosen uniformly at random from a larger set of 45 examples that corresponded to the first 5 images of the original digit in the test set transformed using the JSMA or iterated TGSM to each of the other 9 digits (we ensured that all models misclassified all examples as their target). Subjects were not given the original\nMNIST (JSMA)\nSVHN (TGSM)\nModel\nhuman\nfooled\nmistake\nreasonable\nhuman\nfooled\nmistake\nreasonable\nnormal\n2.0%\n26.0%\n40.0%\n63.3%\ndistilled\n0.0%\n23.5%\n1.7%\n25.4%\ngrad. reg.\n16.4%\n41.8%\n46.3%\n81.5%\nTable 3.1: Quantitative feedback from the human subject experiment. \u201chuman fooled\u201d columns record what percentage of examples were classified by humans as most plausibly their adversarial targets, and \u201cmistake reasonable\u201d records how often humans either rated the target plausible or marked the image unrecognizable as any label (N/A). label, but were asked to input what they considered the most and second-most plausible predictions for the image that they thought a reasonable classifier would make (entering N/A if they thought no label was a plausible choice). In the qualitative portion that came afterwards, users were shown three 10x10 confusion matrices for the different defenses on MNIST (Figure 3.7 shows the first two rows) and were asked to write comments about the differences between the examples. Afterwards, there was a short group discussion. This study was performed in compliance with the institution\u2019s IRB.\nlabel, but were asked to input what they considered the most and second-most plausible predictions for the image that they thought a reasonable classifier would make (entering N/A if they thought no label was a plausible choice). In the qualitative portion that came afterwards, users were shown three 10x10 confusion matrices for the different defenses on MNIST (Figure 3.7 shows the first two rows) and were asked to write comments about the differences between the examples. Afterwards, there was a short group discussion. This study was performed in compliance with the institution\u2019s IRB.\n# Study Results\nTable 3.1 shows quantitative results from the human subject experiment. Overall, subjects found gradient-regularized model adversarial examples most convincing. On SVHN and especially MNIST, humans were most likely to think that gradient-regularized (rather than distilled or normal) adversarial examples were best classified as their target rather than their original digit. Additionally, when they did not consider the target the most plausible label, they were most likely to consider gradient-regularized model mispredictions \u201creasonable\u201d (which we define in Table 3.1), and more likely to consider distilled model mispredictions unreasonable. p-values for the differences between normal and gradient regularized unreasonable error rates were 0.07 for MNIST and 0.08 for SVHN. In the qualitative portion of the study (comparing MNIST JSMA examples), all of the written responses described significant differences between the insensitive model\u2019s JSMA\nexamples and those of the other two methods. Many of the examples for the gradientregularized model were described as \u201cactually fairly convincing,\u201d and that the normal and distilled models \u201cseem to be most easily fooled by adding spurious noise.\u201d Few commentators indicated any differences between the normal and distilled examples, with several saying that \u201cthere doesn\u2019t seem to be [a] stark difference\u201d or that they \u201ccouldn\u2019t describe the difference\u201d between them. In the group discussion one subject remarked on how the perturbations to the gradient-regularized model felt \u201cmore intentional\u201d, and others commented on how certain transitions between digits led to very plausible fakes while others seemed inherently harder. Although the study was small, both its quantitative and qualitative results support the claim that gradient regularization, at least for the two CNNs on MNIST and SVHN, is a credible defense against the JSMA and the iterated TGSM, and that distillation is not.\n# 3.4.3 Connections to Interpretability\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/f40f/f40fa1b7-aa63-4c90-afd8-97624961baa2.png\" style=\"width: 50%;\"></div>\nFigure 3.9: Input gradients \u2207xH( 1 K, \u02c6y) that provide a local linear approximation of normal models (top), distilled models at T = 50 (second from top), adversarially trained models (middle), and models trained with \u2207xH( 1 K, \u02c6y) and \u2207xH(y, \u02c6y) gradient regularization (bottom two). Whitening black pixels or darkening white pixels makes the model more certain of its prediction. In general, regularized model gradients appear smoother and make more intuitive sense as local linear approximations.\n<div style=\"text-align: center;\">Figure 3.9: Input gradients \u2207xH( 1 K, \u02c6y) that provide a local linear approximation of normal models (top), distilled models at T = 50 (second from top), adversarially trained models (middle), and models trained with \u2207xH( 1 K, \u02c6y) and \u2207xH(y, \u02c6y) gradient regularization (bottom two). Whitening black pixels or darkening white pixels makes the model more certain of its prediction. In general, regularized model gradients appear smoother and make more intuitive sense as local linear approximations.</div>\nFinally, we present a qualitative evaluation suggesting a connection between adversarial robustness and interpretability. In the literature on explanations, input gradients are frequently used as explanations (Baehrens et al., 2010), but sometimes they are noisy and\nnot interpretable on their own. In those cases, smoothing techniques have been developed (Smilkov et al., 2017; Shrikumar et al., 2016; Sundararajan et al., 2017) to generate more interpretable explanations, but we have already argued that these techniques may obscure information about the model\u2019s sensitivity to background features. We hypothesized that if the models had more interpretable input gradients without the need for smoothing, then perhaps their adversarial examples, which are generated directly from their input gradients, would be more interpretable as well. That is, the adversarial example would be more obviously transformative away from the original class label and towards another. The results of the user study show that our gradient-regularized models have this property; here we ask if the gradients are more interpretable as explanations. In Figure 3.9 we visualize input gradients across models and datasets, and while we cannot make any quantitative claims, there does appear to be a qualitative difference in the interpretability of the input gradients",
    "paper_type": "method",
    "attri": {
        "background": "This paper addresses the issue of opacity in neural networks, which makes them difficult to trust in critical applications. Previous methods have attempted to provide explanations for machine learning models, but they often fail to scale effectively or correct the issues they reveal. This thesis explores training machine learning models by penalizing not only incorrect predictions but also explanations that are inconsistent with domain knowledge or overly complex.",
        "problem": {
            "definition": "The core problem is the lack of interpretability in machine learning models, particularly neural networks, which can lead to incorrect predictions that are not aligned with domain knowledge.",
            "key obstacle": "Existing methods do not effectively address the generalization gap that arises when training and test data distributions differ, which can result in models making decisions for the wrong reasons."
        },
        "idea": {
            "intuition": "The idea originated from the observation that explanations can help identify when models are making predictions for the wrong reasons, suggesting that regularizing explanations could improve model performance.",
            "opinion": "The proposed approach involves training models to provide accurate predictions while also ensuring their explanations are valid and understandable, thus enhancing interpretability.",
            "innovation": "The key innovation lies in the method of explanation regularization, which constrains the model's explanations to align with domain knowledge, thereby improving both interpretability and robustness."
        },
        "method": {
            "method name": "Explanation Regularization",
            "method abbreviation": "ER",
            "method definition": "A framework that incorporates penalties on the explanations generated by machine learning models to encourage them to be consistent with domain knowledge.",
            "method description": "The method involves training models with a loss function that includes terms for both prediction accuracy and explanation validity.",
            "method steps": [
                "Define a loss function that includes cross-entropy and explanation regularization terms.",
                "Train the model using gradient-based optimization methods.",
                "Iteratively adjust the explanation constraints based on model performance and expert feedback."
            ],
            "principle": "This method is effective because it aligns the model's decision-making process with human-understandable explanations, thus enhancing trust and interpretability."
        },
        "experiments": {
            "evaluation setting": "The experiments were conducted using a toy color dataset and three real-world datasets, employing a multilayer perceptron architecture with specific configurations for each dataset.",
            "evaluation method": "Performance was assessed based on accuracy metrics across different datasets and conditions, including evaluations against adversarial examples."
        },
        "conclusion": "The experiments demonstrated that models trained with explanation regularization not only improved interpretability but also exhibited enhanced robustness against adversarial examples, suggesting a strong connection between model explainability and performance.",
        "discussion": {
            "advantage": "The main advantages of the proposed approach include improved interpretability of model predictions and robustness against adversarial attacks, making it suitable for sensitive applications.",
            "limitation": "A limitation of the method is that input gradients can be difficult to interpret when features are not individually meaningful, and the requirement for domain knowledge can be a barrier in some contexts.",
            "future work": "Future research directions include exploring more general types of explanations, refining the regularization techniques, and developing user interfaces for interactive model training."
        },
        "other info": {
            "info1": "The code for the experiments is available at https://github.com/dtak/rrr.",
            "info2": {
                "info2.1": "The method has potential applications in healthcare and other critical domains.",
                "info2.2": "Further studies are needed to validate the effectiveness of explanation regularization across a wider range of datasets and models."
            }
        }
    },
    "mount_outline": [
        {
            "section number": "1.1",
            "key information": "The core problem is the lack of interpretability in machine learning models, particularly neural networks, which can lead to incorrect predictions that are not aligned with domain knowledge."
        },
        {
            "section number": "2.5",
            "key information": "The proposed approach involves training models to provide accurate predictions while also ensuring their explanations are valid and understandable, thus enhancing interpretability."
        },
        {
            "section number": "3.5",
            "key information": "The key innovation lies in the method of explanation regularization, which constrains the model's explanations to align with domain knowledge, thereby improving both interpretability and robustness."
        },
        {
            "section number": "5.2",
            "key information": "The experiments demonstrated that models trained with explanation regularization not only improved interpretability but also exhibited enhanced robustness against adversarial examples."
        },
        {
            "section number": "7.1",
            "key information": "A limitation of the method is that input gradients can be difficult to interpret when features are not individually meaningful, and the requirement for domain knowledge can be a barrier in some contexts."
        }
    ],
    "similarity_score": 0.6512859841648477,
    "image": null,
    "path": "/home/dany/codes/autosurvey/outputs/2025-01-07-2332_Out-o/papers/Training Machine Learning Models by Regularizing their Explanations.json"
}