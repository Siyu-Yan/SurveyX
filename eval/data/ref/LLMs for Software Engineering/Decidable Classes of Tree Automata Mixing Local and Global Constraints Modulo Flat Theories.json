{
    "from": "arxiv",
    "scholar_id": null,
    "detail_id": "arXiv:1302.6960",
    "title": "Decidable Classes of Tree Automata Mixing Local and Global Constraints Modulo Flat Theories",
    "abstract": "We define a class of ranked tree automata TABG generalizing both the tree automata with local tests between brothers of Bogaert and Tison (1992) and with global equality and disequality constraints (TAGED) of Filiot et al. (2007). TABG can test for equality and disequality modulo a given flat equational theory between brother subterms and between subterms whose positions are defined by the states reached during a computation. In particular, TABG can check that all the subterms reaching a given state are distinct. This constraint is related to monadic key constraints for XML documents, meaning that every two distinct positions of a given type have different values. We prove decidability of the emptiness problem for TABG. This solves, in particular, the open question of the decidability of emptiness for TAGED. We further extend our result by allowing global arithmetic constraints for counting the number of occurrences of some state or the number of different equivalence classes of subterms (modulo a given flat equational theory) reaching some state during a computation. We also adapt the model to unranked ordered terms. As a consequence of our results for TABG, we prove the decidability of a fragment of the monadic second order logic on trees extended with predicates for equality and disequality between subtrees, and cardinality.",
    "bib_name": "bargu2013decidableclassestreeautomata",
    "md_text": "# DECIDABLE CLASSES OF TREE AUTOMATA MIXING LOCAL AND GLOBAL CONSTRAINTS MODULO FLAT THEORIES \u2217\nDECIDABLE CLASSES OF TREE AUTOMATA MIXING LOCAL AND GLOBAL CONSTRAINTS MODULO FLAT THEORIES \u2217\nLUIS BARGU\u02dcN \u00b4O a, CARLES CREUS b, GUILLEM GODOY c, FLORENT JACQUEMARD d, AND CAMILLE VACHER e\na,b,c Universitat Polit`ecnica de Catalunya, Jordi Girona 1, Barcelona, Spain e-mail address: {luisbargu,ccreuslopez}@gmail.com, ggodoy@lsi.upc.edu\nd INRIA Saclay, LSV-CNRS/ENS Cachan e-mail address: florent.jacquemard@lsv.ens-cachan.fr\n INRIA Saclay, LSV-CNRS/ENS Cachan e-mail address: florent.jacquemard@lsv.ens-cachan.fr e LIFL, Univ. Lille I, INRIA Lille, 40 avenue Halley, 59650 Villeneuve d\u2019Ascq, France e-mail address: vacher@lsv.ens-cachan.fr\ne LIFL, Univ. Lille I, INRIA Lille, 40 avenue Halley, 59650 Villeneuve d\u2019Ascq, France e-mail address: vacher@lsv.ens-cachan.fr\nIFL, Univ. Lille I, INRIA Lille, 40 avenue Halley, 59650 Villeneuve d\u2019As mail address: vacher@lsv.ens-cachan.fr\nAbstract. We define a class of ranked tree automata TABG generalizing both the tree automata with local tests between brothers of Bogaert and Tison (1992) and with global equality and disequality constraints (TAGED) of Filiot et al. (2007). TABG can test for equality and disequality modulo a given flat equational theory between brother subterms and between subterms whose positions are defined by the states reached during a computation. In particular, TABG can check that all the subterms reaching a given state are distinct. This constraint is related to monadic key constraints for XML documents, meaning that every two distinct positions of a given type have different values. We prove decidability of the emptiness problem for TABG. This solves, in particular, the open question of the decidability of emptiness for TAGED. We further extend our result by allowing global arithmetic constraints for counting the number of occurrences of some state or the number of different equivalence classes of subterms (modulo a given flat equational theory) reaching some state during a computation. We also adapt the model to unranked ordered terms. As a consequence of our results for TABG, we prove the decidability of a fragment of the monadic second order logic on trees extended with predicates for equality and disequality between subtrees, and cardinality.\n2012 ACM CCS: [Theory of computation]: Formal languages and automata theory\u2014Tree languages; Logic\u2014Higher order logic. Key words and phrases: Logic, symbolic constraints, tree automata, XML processing. \u2217A preliminary version [BCG+10] appeared in the Proceedings of the 25th Annual IEEE Symposium on Logic In Computer Science (LICS 2010). Here, we generalize the results by allowing the constraints to be interpreted modulo a flat equational theory, and make the results stronger and easier to follow by presenting completely new proofs for the part on arithmetic constraints. a,b,c The first three authors were supported by the FORMALISM project (TIN2007-66523), by the SweetLogics project (TIN2010-21062-C02-01), and by an FI-DGR grant. d,e The last two authors were supported by the Future and Emerging Technologies (FET) program under the FET-Open grant agreement FOX number FP7-ICT-23359, and by the INRIA ARC 2010 project ACCESS.\nc \u20dd L. Bargu\u00f1\u00f3, C. Creus, G. Godoy, F. Jacquemard, and C. Vacher C \u20dd Creative Commons\n# 1. Introduction\nTree automata techniques are widely used in several domains like automated deduction (see e.g. [CDG+07]), static analysis of programs [BT05] or protocols [VGL07, FGVTT04], and XML processing [Sch07]. However, a severe limitation of standard tree automata (TA) is that they are not able to test for equality (isomorphism) or disequality between subterms in an input term. For instance, the language of terms matching a non-linear pattern such as f(x, x) is not regular (i.e. there exists no TA recognizing this language). Let us illustrate how this limitation can be problematic in the context of XML documents processing. XML documents are commonly represented as labeled trees, and they can be constrained by XML schemas, which define both typing restrictions and integrity constraints. All the typing formalisms currently used for XML are based on finite tree automata. The key constraints for databases are common integrity constraints expressing that every two distinct positions of a given type have different values. This is typically the kind of constraints that can not be characterized by TA. One first approach to overcome this limitation of TA consists in adding the possibility to make equality or disequality tests at each step of the computation of the automaton. The tests are performed locally, between subterms at a bounded distance from the current computation position in the input term. The emptiness problem, i.e. whether the language recognized by a given automaton is empty, is undecidable with such tests [Mon81]. A decidable subclass is obtained by restricting the tests to sibling subterms [BT92] (see [CDG+07] for a survey). Another approach was proposed more recently in [FTT07, FTT08] with the definition of tree automata with global equality and disequality tests (TAGED). The TAGED do not perform the tests during the computation steps but globally on the term, at the end of the computation, at positions which are defined by the states reached during the computation. For instance, they can express that all the subterms that reached a given state q are equal, or that every two subterms that reached respectively the states q and q\u2032 are different. Nevertheless, arbitrary disequalities are not allowed in TAGED, since such q and q\u2032 must be different. The emptiness has been shown decidable for several subclasses of TAGED [FTT07, FTT08], but the decidability of emptiness for the whole class remained a challenging open question. In this paper, we answer this question positively, for a class of tree recognizers more general than TAGED. We propose (in Section 3) a class of tree automata with local constraints between siblings and global constraints (TABG) which significantly extends TAGED in several directions: (i) TABG combine global constraints a la TAGED with local equality and disequality constraints between brother subterms a la [BT92], (ii) the equality and disequality constraints are treated modulo a given flat equational theory (here flat means that both sides of the equation have the same variables and height, and that this height is bounded by 1), allowing to consider relations more general than syntactic equalities and disequalities, like e.g. structural equalities and disequalities, (iii) testing global disequality constraints between subterms that reached the same state is allowed (such test specify key constraints, which are not expressible with TAGED), (iv) the global constraints are arbitrary Boolean combinations (including negation) of atomic equality and disequality (in TAGED, only conjunction of atoms are allowed, without negation).\nIn Section 4, we consider the addition to TABG of global counting constraints on the number |q| of occurrences of a given state q in a computation, or the number \u2225q\u2225of distinct equivalence classes (modulo the flat theory) of subterms reaching a given state q in a computation. These counting constraints are only allowed to compare states to constants, like in |q| \u22645 or \u2225q\u2225+ 2\u2225q\u2032\u2225\u22659 (with counting constraints being able to compare state cardinalities, like in |q| = |q\u2032|, the emptiness problem becomes undecidable). Using this formalism as an intermediate step, we show that negative literals and disjunctions can be eliminated without loss of generality in the global constraints of TABG, i.e. that TABG whose global constraints are restricted to be conjunctions of positive literals (namely positive conjunctive TABG) have already the same expressiveness of the full TABG class. In particular, the counting constraints do not improve the expressiveness of TABG. Our main result, presented in Section 5, is that emptiness is decidable for positive conjunctive TABG (and hence for TABG). The decision algorithm uses an involved pumping argument: every sufficiently large term recognized by the given TABG can be reduced by an operation of parallel pumping into a smaller term which is still recognized. The existence of the bound for the minimum accepted term is based on a particular well quasi-ordering. We show that the emptiness decision algorithm of Section 5 can also be applied to a generalization of the subclass TAG of TABG without the local constraints computing on unranked ordered labeled trees (Section 6). This demonstrates the robustness of the method. As an application of our results, in Section 7 we present a (strict) extension of the monadic second order logic on trees whose existential fragment corresponds exactly to TAG. In particular, we conclude its decidability.\nRelated Work. TABG is a strict (decidable) extension of TAG and TA with local equality and disequality constraints, since the expressiveness of both subclasses is incomparable (see e.g. [JKV09]). The tree automata model of [BT92] has been generalized from ranked trees to unranked ordered trees into a decidable class called UTASC [WL07, LW09]. In unranked trees, the number of brothers (under a position) is unbounded, and UTASC transitions use MSO formulae (on words) with 2 free variables in order to select the sibling positions to be tested for equality and disequality. The decidable generalization of TAG to unranked ordered trees proposed in Section 6 and the automata of [WL07, LW09] are incomparable. The combination of both formalisms could be the object of a further study. Another way to handle subterm equalities is to use automata computing on DAG representation of terms [Cha99, ANR05]. This model is incomparable to TAG whose constraints are conjunctions of equalities [JKV09]. The decidable extension of TA with one tree shaped memory [CC05] can simulate TAG with equality constraints only, providing that at most one state per run can be used to test equalities [FTT07]. We show in Section 3 that the TABG strictly generalize the TAGED of [FTT07, FTT08]. The latter have been introduced as a tool to decide a fragment of the spatial logic TQL [FTT07]. Decidable subclasses of TAGED were also shown decidable in correspondence with fragments of monadic second order logic on the tree extended with predicates for subtree (dis)equality tests. In Section 7, we generalize this correspondence to TAG and a more natural extension of MSO. There have been several approaches to extend TA with arithmetic constraints on cardinalities |q| described above: the constraints can be added to transitions in order to count between siblings [SSM03, DL06] (in this case we could call them local by analogy with\nequality tests) or they can be global [KR02]. We compare in Section 4 the latter approach (closer to our settings) with our extension of TABG, with respect to emptiness decision. To our knowledge, this is the first time that arithmetic constraints on cardinalities of the form \u2225q\u2225are studied.\n# 2. Preliminaries\n2.1. Terms, Positions, Replacements. We use the standard notations for terms and positions, see [BN98]. A signature \u03a3 is a finite set of function symbols with arity. We sometimes denote \u03a3 explicitly as {f1 : a1, . . . , fn : an} where f1, . . . , fn are the function symbols, and a1, . . . , an are the corresponding arities, or as {f1, . . . , fn} when the arities are omitted. We denote the subset of function symbols of \u03a3 of arity m as \u03a3m. The set of (ranked) terms over the signature \u03a3 is defined recursively as T (\u03a3) := {f(t1, . . . , tm) | f : m \u2208\u03a3, t1, . . . , tm \u2208T (\u03a3)}. Note that the base case of this definition is {f | f : 0 \u2208\u03a3}, which coincides with \u03a30 by omitting the arity. Elements of this subset are called constants. Positions in terms are denoted by sequences of natural numbers. With \u03bb we denote the empty sequence (root position), and p.p\u2032 denotes the concatenation of positions p and p\u2032. The set of positions of a term is defined recursively as Pos \ufffd f(t1, . . . , tm) \ufffd = {\u03bb} \u222a{i.p | i \u2208 {1, . . . , m} \u2227p \u2208Pos(ti)}. A term t \u2208T (\u03a3) can be seen as a function from its set of positions Pos(t) into \u03a3. For this reason, the symbol labeling the position p in t shall be denoted by t(p). By p < p\u2032 and p \u2264p\u2032 we denote that p is a proper prefix of p\u2032, and that p is a prefix of p\u2032, respectively. In these cases, p\u2032 is necessarily of the form p.p\u2032\u2032, and we define p\u2032 \u2212p as p\u2032\u2032. Two positions p1, p2 incomparable with respect to the prefix ordering are called parallel, and it is denoted by p1 \u2225p2. The subterm of t at position p, denoted t|p, is defined recursively as t|\u03bb = t and f(t1, . . . , tm)|i.p = ti|p. The replacement in t of the subterm at position p by s, denoted t[s]p, is defined recursively as t[s]\u03bb = s and f(t1, . . . , ti\u22121, ti, ti+1, . . . , tm)[s]i.p = f(t1, . . . , ti\u22121, ti[s]p, ti+1, . . . , tm). The height of a term t, denoted h(t), is the maximal length of a position of Pos(t). In particular, the length of \u03bb is 0.\n2.2. Tree automata. A tree automaton (TA, see e.g. [CDG+07]) is a tuple A = \u27e8Q, \u03a3, F, \u2206\u27e9 where Q is a finite set of states, \u03a3 is a signature, F \u2286Q is a subset of final (or accepting) states and \u2206is a set of transition rules of the form f(q1, . . . , qm) \u2192q where f : m \u2208\u03a3, q1, . . . , qm, q \u2208Q. Sometimes, we shall refer to A as a subscript of its components, like in QA to indicate that this is the set of states of A. A run of A is a pair r = \u27e8t, M\u27e9where t is a term in T (\u03a3) and M : Pos(t) \u2192\u2206A is a mapping satisfying the following statement for each p \u2208Pos(t): if t|p is written of the form f(t1, . . . , tm), and M(p.1), . . . , M(p.m) are rules with right-hand side states q1, . . . , qm \u2208 QA, respectively, then M(p) is a rule of the form f(q1, . . . , qm) \u2192q for some q \u2208QA. We write r(p) for the right-hand side state of M(p), and say that r is a run of A on t. Moreover, by term(r) we refer to t, and by symbol(r) we refer to t(\u03bb). The run r is called successful (or accepting) if r(\u03bb) is in FA. The language L(A) of A is the set of terms t for which there exists a successful run of A. A language L is called regular if there exists a TA A satisfying L = L(A). For facility of explanations, we shall use term-like notations for runs defined as follows in the natural way. For a run r = \u27e8t, M\u27e9, by Pos(r) we denote Pos(t), and by h(r) we denote h(t). Similarly, by r|p we denote the run \u27e8t|p, M|p\u27e9, where M|p is defined as\nM|p(p\u2032) = M(p.p\u2032) for each p\u2032 in Pos(t|p), and say that r|p is a subrun of r. Moreover, for a run r\u2032 = \u27e8t\u2032, M\u2032\u27e9such that the states r\u2032(\u03bb) and r(p) coincide, by r[r\u2032]p we denote the run \u27e8t[t\u2032]p, M[M\u2032]p\u27e9, where M[M\u2032]p is defined as M[M\u2032]p(p.p\u2032) = M\u2032(p\u2032) for each p\u2032 in Pos(t\u2032), and as M[M\u2032]p(p\u2032) = M(p\u2032) for each p\u2032 with p \u0338\u2264p\u2032.\n2.3. Tree automata with local constraints between brothers. A tree automaton with constraints between brothers (defined in [BT92] and called TACBB in [CDG+07]) is a tuple A = \u27e8Q, \u03a3, F, \u2206\u27e9where Q, \u03a3 and F are defined as for TA, but with the difference that \u2206is a set of constrained rules of the form f(q1, . . . , qm) C\u2192q, where C is a set of equalities and disequalities of the form i \u2248j or i \u0338\u2248j for i, j \u2208{1, . . . , m}. We call C a local constraint between brothers. By ta(A) we define the TA obtained from A by removing all constraints from \u2206. A run of a TACBB A is a pair r = \u27e8t, M\u27e9defined similarly to the case of TA; t is a term in T (\u03a3) and the mapping M : Pos(t) \u2192\u2206A satisfies the following statement for each p \u2208Pos(t): if t|p is written of the form f(t1, . . . , tm), and M(p.1), . . . , M(p.m) are rules with right-hand side states q1, . . . , qm \u2208QA, respectively, then M(p) is a rule of the form f(q1, . . . , qm) C\u2192q for some q \u2208QA and constraint between brothers C. Moreover, for each equality i \u2248j in C, ti = tj holds, and for each disequality i \u0338\u2248j in C, ti \u0338= tj holds. The notions of successful run and recognized language are defined for TACBB analogously to the case of TA.\n2.4. Term equations. Given a set of variables X, the set of (ranked) terms over \u03a3 and X is defined as T (\u03a3 \u222aX) by considering arity 0 for the elements of X. A substitution \u03c3 is a mapping from variables to terms \u03c3 : X \u2192T (\u03a3 \u222aX). It is also considered as a function from arbitrary terms to terms \u03c3 : T (\u03a3\u222aX) \u2192T (\u03a3\u222aX) by the recursive definition \u03c3(f(t1, . . . , tm)) = f(\u03c3(t1), . . . , \u03c3(tm)) for every function symbol f and subterms t1, . . . , tm. An equation between terms is an unordered pair of terms denoted l \u2248r. Given a set of equations E and two terms s, t, we say that s and t are equivalent modulo E, denoted s =E t, if there exist terms s1, s2, . . . , sn, n \u22651 satisfying the following statement: s = s1, sn = t, and for each i \u2208{1, . . . , n\u22121}, there exists an equation l \u2248r in E, a substitution \u03c3, and a position p, such that si|p = \u03c3(l) and si+1 = si[\u03c3(r)]p. A flat equation is an equation l \u2248r where l and r are terms satisfying h(l) = h(r) \u22641, and any variable x occurs in l if and only if x occurs in r. A flat theory is a set of flat equations. The following technical lemma shows that equivalence modulo a flat theory is preserved by certain replacements of subterms. It will be useful in Section 5. Lemma 2.1. Let E be a flat theory. Let s = f(s1, . . . , sn), t = g(t1, . . . , tm), s\u2032 = f(s\u2032 1, . . . , s\u2032 n) and t\u2032 = g(t\u2032 1, . . . , t\u2032 m) be terms satisfying the following conditions: \u2022 For each i \u2208{1, . . . , n}, (si \u2208\u03a30 \u21d4s\u2032 i \u2208\u03a30) and (si, s\u2032 i \u2208\u03a30 \u21d2si =E s\u2032 i) hold. \u2022 For each j \u2208{1, . . . , m}, (tj \u2208\u03a30 \u21d4t\u2032 j \u2208\u03a30) and (tj, t\u2032 j \u2208\u03a30 \u21d2tj =E t\u2032 j) hold. \u2022 For each i \u2208{1, . . . , n} and j \u2208{1, . . . , m}, (s\u2032 i =E t\u2032 j \u21d4si =E tj) holds. Then, s =E t \u21d4s\u2032 =E t\u2032 holds. Proof. We prove the left-to-right direction only. The other one is analogous by swapping the roles of s and t by the roles of s\u2032 and t\u2032, respectively.\n2.4. Term equations. Given a set of variables X, the set of (ranked) terms over \u03a3 and X is defined as T (\u03a3 \u222aX) by considering arity 0 for the elements of X. A substitution \u03c3 is a mapping from variables to terms \u03c3 : X \u2192T (\u03a3 \u222aX). It is also considered as a function from arbitrary terms to terms \u03c3 : T (\u03a3\u222aX) \u2192T (\u03a3\u222aX) by the recursive definition \u03c3(f(t1, . . . , tm)) = f(\u03c3(t1), . . . , \u03c3(tm)) for every function symbol f and subterms t1, . . . , tm. An equation between terms is an unordered pair of terms denoted l \u2248r. Given a set of equations E and two terms s, t, we say that s and t are equivalent modulo E, denoted s =E t, if there exist terms s1, s2, . . . , sn, n \u22651 satisfying the following statement: s = s1, sn = t, and for each i \u2208{1, . . . , n\u22121}, there exists an equation l \u2248r in E, a substitution \u03c3, and a position p, such that si|p = \u03c3(l) and si+1 = si[\u03c3(r)]p. A flat equation is an equation l \u2248r where l and r are terms satisfying h(l) = h(r) \u22641, and any variable x occurs in l if and only if x occurs in r. A flat theory is a set of flat equations. The following technical lemma shows that equivalence modulo a flat theory is preserved by certain replacements of subterms. It will be useful in Section 5.\nSince s =E t holds, there exist terms u1, u2, . . . , uk, k \u22651 satisfying the following statement: s = u1, uk = t, and for each i \u2208{1, . . . , k \u22121}, there exists an equation l \u2248r in E, a substitution \u03c3, and a position p, such that ui|p = \u03c3(l) and ui+1 = ui[\u03c3(r)]p. We prove the statement by induction on k. For k = 1, s = t holds. Thus, g is f, m is n, and for each i \u2208{1, . . . , n}, si = ti holds. In particular, each si =E ti holds. Therefore, each s\u2032 i =E t\u2032 i also holds, and hence s\u2032 = f(s\u2032 1, . . . , s\u2032 n) =E f(t\u2032 1, . . . , t\u2032 n) = t\u2032 holds. Now, assume k > 1. Let l \u2248r, p and \u03c3 be the rule, position and substitution satisfying u1|p = \u03c3(l) and u2 = u1[\u03c3(r)]p. Recall that u1 is s. First, suppose that p is not \u03bb. Then, p is of the form j.p\u2032 for some j \u2208{1, . . . , n} and position p\u2032. Note that u2|j =E u1|j holds, and for each i \u2208{1, . . . , n} \\ {j}, u2|i = u1|i holds. Thus, u2 is of the form f(v1, . . . , vn) and for each i \u2208{1, . . . , n}, vi =E si holds. Moreover, since E is a flat theory, the step at p preserves the height, and hence, for each i \u2208{1, . . . , n}, vi \u2208\u03a30 \u21d4si \u2208\u03a30 and vi, si \u2208\u03a30 \u21d2vi =E si hold. From the statement of the lemma, the following conditions follow: \u2022 For each i \u2208{1, . . . , n}, (vi \u2208\u03a30 \u21d4s\u2032 i \u2208\u03a30) and (vi, s\u2032 i \u2208\u03a30 \u21d2vi =E s\u2032 i) hold. \u2022 For each j \u2208{1, . . . , m}, (tj \u2208\u03a30 \u21d4t\u2032 j \u2208\u03a30) and (tj, t\u2032 j \u2208\u03a30 \u21d2tj =E t\u2032 j) hold. \u2022 For each i \u2208{1, . . . , n} and j \u2208{1, . . . , m}, (s\u2032 i =E t\u2032 j \u21d4vi =E tj) holds. By induction hypothesis, f(s\u2032 1, . . . , s\u2032 n) =E g(t\u2032 1, . . . , t\u2032 m) holds, and we are done. Now, consider the case where p is \u03bb. In this case s = u1 = \u03c3(l), and u2 = \u03c3(r). Since E is a flat theory, l and r are of the form f(\u03b11, . . . , \u03b1n) and h(\u03b21, . . . , \u03b2\u00b5), where either n, \u00b5 > 0 or n = \u00b5 = 0, and \u03b11, . . . , \u03b1n, \u03b21, . . . , \u03b2\u00b5 are either constants or variables. Moreover, a variable occurs in l if and only if it occurs in r. Note that \u03c3(\u03b11) = s1, . . . , \u03c3(\u03b1n) = sn holds. We call v1 = \u03c3(\u03b21), . . . , v\u00b5 = \u03c3(\u03b2\u00b5). Note that u2 = h(v1, . . . , v\u00b5). We define terms v\u2032 1, . . . , v\u2032 \u00b5 as follows for each i in {1, . . . , \u00b5}. If vi is a constant, then we define v\u2032 i as vi. Otherwise, if vi is not a constant, then \u03b2i is a variable x. Since E is a flat theory, some \u03b1j (we choose any) must be x. In this case we define v\u2032 i as s\u2032 j. With these definitions, the following conditions follow: \u2022 For each i \u2208{1, . . . , \u00b5}, (vi \u2208\u03a30 \u21d4v\u2032 i \u2208\u03a30) and (vi, v\u2032 i \u2208\u03a30 \u21d2vi =E v\u2032 i) hold. \u2022 For each j \u2208{1, . . . , m}, (tj \u2208\u03a30 \u21d4t\u2032 j \u2208\u03a30) and (tj, t\u2032 j \u2208\u03a30 \u21d2tj =E t\u2032 j) hold. \u2022 For each i \u2208{1, . . . , \u00b5} and j \u2208{1, . . . , m}, (v\u2032 i =E t\u2032 j \u21d4vi =E tj) holds. By induction hypothesis, h(v\u2032 1, . . . , v\u2032 \u00b5) =E g(t\u2032 1, . . . , t\u2032 m) holds. Now, let s\u2032\u2032 1, . . . , s\u2032\u2032 n be defined as follows for each i in {1, . . . , n}. If s\u2032 i is not a constant then define s\u2032\u2032 i as s\u2032 i. Otherwise, if s\u2032 i is a constant, then define s\u2032\u2032 i as si. By the condition (si, s\u2032 i \u2208\u03a30 \u21d2si =E s\u2032 i) we have that f(s\u2032 1, . . . , s\u2032 n) =E f(s\u2032\u2032 1, . . . , s\u2032\u2032 n) holds. Moreover, the same rule l \u2248r can be used to prove f(s\u2032\u2032 1, . . . , s\u2032\u2032 n) =E h(v\u2032 1, . . . , v\u2032 \u00b5). Hence, f(s\u2032 1, . . . , s\u2032 n) =E f(s\u2032\u2032 1, . . . , s\u2032\u2032 n) =E h(v\u2032 1, . . . , v\u2032 \u00b5) =E g(t\u2032 1, . . . , t\u2032 m) holds, and we are done.\n1 1 Now, let s\u2032\u2032 1, . . . , s\u2032\u2032 n be defined as follows for each i in {1, . . . , n}. If s\u2032 i is not a constant then define s\u2032\u2032 i as s\u2032 i. Otherwise, if s\u2032 i is a constant, then define s\u2032\u2032 i as si. By the condition (si, s\u2032 i \u2208\u03a30 \u21d2si =E s\u2032 i) we have that f(s\u2032 1, . . . , s\u2032 n) =E f(s\u2032\u2032 1, . . . , s\u2032\u2032 n) holds. Moreover, the same rule l \u2248r can be used to prove f(s\u2032\u2032 1, . . . , s\u2032\u2032 n) =E h(v\u2032 1, . . . , v\u2032 \u00b5). Hence, f(s\u2032 1, . . . , s\u2032 n) =E f(s\u2032\u2032 1, . . . , s\u2032\u2032 n) =E h(v\u2032 1, . . . , v\u2032 \u00b5) =E g(t\u2032 1, . . . , t\u2032 m) holds, and we are done.\n2.5. Well quasi-orderings. A well quasi-ordering [Gal91] \u2264on a set S is a reflexive and transitive relation such that any infinite sequence of elements e1, e2, . . . of S contains an increasing pair ei \u2264ej with i < j.\n3. Tree Automata with Global Constraints\nIn this subsection, we define a class of tree automata with global constraints strictly generalizing both the TACBB of [BT92] and the TAGED of [FTT08]. The generalization consists\nin considering more general global constraints, and interpreting all the constraints modulo a flat equational theory. As an intermediate step, we define an extension of the TACBB of [BT92] where the local constraints between brothers are considered modulo a flat equational theory. Definition 3.1. A tree automaton with constraints between brothers modulo a flat theory (TAB) is a tuple A = \u27e8Q, \u03a3, F, \u2206, E\u27e9where \u27e8Q, \u03a3, F, \u2206\u27e9is a TACBB and E is a flat equational theory. By ta(A) we denote ta(\u27e8Q, \u03a3, F, \u2206\u27e9). A run of a TAB A = \u27e8Q, \u03a3, F, \u2206, E\u27e9is a pair r = \u27e8t, M\u27e9defined analogously to a run of a TACBB, except that the constraints between brothers are interpreted modulo E. More specifically, for each position p in Pos(t), if t|p is written of the form f(t1, . . . , tm), and M(p.1), . . . , M(p.m) are rules with right-hand side states q1, . . . , qm \u2208Q, respectively, then M(p) is a transition rule of \u2206A of the form f(q1, . . . , qm) C\u2192q for some q \u2208Q and constraint between brothers C. Moreover, for each equality i \u2248j in C, ti =E tj holds, and for each disequality i \u0338\u2248j in C, ti \u0338=E tj holds. The notions of successful run and recognized language are defined for TAB analogously to the case of TA. We further extend this class TAB with global equality and disequality constraints generalizing those of TAGED [FTT08]. Definition 3.2. A tree automaton with global and brother constraints modulo a flat theory (TABG) is a tuple A = \u27e8Q, \u03a3, F, \u2206, E, C\u27e9where \u27e8Q, \u03a3, F, \u2206, E\u27e9is a TAB, denoted tab(A), and C is a Boolean combination of atomic constraints of the form q \u2248q\u2032 or q \u0338\u2248q\u2032, where q, q\u2032 \u2208Q. By ta(A) we denote ta(tab(A)). A run of a TABG A = \u27e8Q, \u03a3, F, \u2206, E, C\u27e9is a run r = \u27e8t, M\u27e9of tab(A) such that r satisfies C, denoted r |= C, where the satisfiability of constraints is defined as follows. For atomic constraints, r |= q \u2248q\u2032 (respectively r |= q \u0338\u2248q\u2032) holds if and only if for all different positions p, p\u2032 \u2208Pos(t) such that M(p) = q and M(p\u2032) = q\u2032, t|p =E t|p\u2032 (respectively t|p \u0338=E t|p\u2032) holds. This notion of satisfiability is extended to Boolean combinations as usual. As for TA, we say that r is a run of A on t. A run r of A on t \u2208T (\u03a3) is successful (or accepting) if r(\u03bb) \u2208F. The language L(A) of A is the set of terms t for which there exists a successful run of A. It is important to note that the semantics of \u00ac(q \u2248q\u2032) and q \u0338\u2248q\u2032 differ, as well as the semantics of \u00ac(q \u0338\u2248q\u2032) and q \u2248q\u2032. This is because we have a \u201cfor all\u201d quantifier in both definitions of semantics of q \u2248q\u2032 and q \u0338\u2248q\u2032. Let us introduce some notations, summarized in Figure 1 that we use below to characterize some classes of tree automata related to TABG (Figure 1 also refers to a class defined in Section 4). A TABG A is called positive if CA is a disjunction of conjunctions of atomic constraints and it is called positive conjunctive if CA is a conjunction of atomic constraints. The subclass of positive conjunctive TABG is denoted by TABG\u2227. We recall that a TAB where all the constraints are empty is just a TA. For a TABG A, when the theory EA is empty and tab(A) is just a TA, we say that A is just a tree automaton with global constraints (TAG). Its subclass with positive conjunctive constraints is denoted TAG\u2227. With the notation TABG[\u03c41, . . . , \u03c4m], we characterize the class of tree automata with global and brother constraints modulo a flat theory whose global constraints are Boolean\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/c81c/c81c04d8-fa82-4b34-a2d9-b4195c30c2ba.png\" style=\"width: 50%;\"></div>\nTABG[\u2248, \u0338\u2248, N] TABG[\u2248, \u0338\u2248] positive TABG[\u2248, \u0338\u2248] TABG\u2227[\u2248, \u0338\u2248] TAG[\u2248, \u0338\u2248] TAG[\u2248] TABG[\u2248] TABG[\u0338\u2248] TAG[\u0338\u2248] TAB TACBB TA\n<div style=\"text-align: center;\">: effective strict inclusion : effective equivalence</div>\n<div style=\"text-align: center;\">Figure 1: Decidable classes of TA with local and global constraints</div>\ncombination of atomic constraints of types \u03c41, . . . , \u03c4m. The types \u2248and \u0338\u2248denote respectively the atomic constraints of the form q \u2248q\u2032 and q \u0338\u2248q\u2032, where q, q\u2032 are states. For instance, the abbreviation TABG used in Definition 3.2 stands for TABG[\u2248, \u0338\u2248]. This notation is extended to the positive conjunctive fragment by TABG\u2227[\u03c41, . . . , \u03c4k] and to the fragment without local constraints between brother, by TAG[\u03c41, . . . , \u03c4k]. 3.1. Expressiveness. The class of regular languages is strictly included in the class of TABG languages due to the constraints. Example 3.3. Let \u03a3 = {a : 0, f : 2}. The set {f(t, t) | t \u2208T (\u03a3)} is not a regular tree language (this can be shown using a classical pumping argument). However, it is recognized by the following TAB:\n\ufffd {q0, qf}, \u03a3, {qf}, {a \u2192q0, f(q0, q0) \u2192q0, f(q0, q0) \u2212\u2212\u2212\u2192 1\u22482 qf}, \u2205 \ufffd , recognized by the following TAG[\u2248]:\n\ufffd and it is also recognized by the following TAG[\u2248]: A = \ufffd {q0, q1, qf}, \u03a3, {qf}, {a \u2192q0 | q1, f(q0, q0) \u2192q0 | q1, f(q1, q1) \u2192\n\ufffd \ufffd where t \u2192q | qr is an abbreviation for t \u2192q and t \u2192qr. An example of successful run of A on t = f(f(a, a), f(a, a)) is qf \ufffd q1(q0, q0), q1(q0, q0) \ufffd , where we use term-like notation for marking the reached state at each position.\nMoreover, the TAGED of [FTT08] are also a particular case of TAG[\u2248, \u0338\u2248], since they can be redefined in our setting as restricted TAG\u2227[\u2248, \u0338\u2248], where the equational theory is empty, and where q and q\u2032 are required to be distinct in any atomic constraint of the form q \u0338\u2248q\u2032. Reflexive disequality constraints such as q \u0338\u2248q correspond to monadic key constraints for XML documents, meaning that every two distinct positions of type q have different values. A state q of a TAG[\u2248, \u0338\u2248] can be used for instance to characterize unique identifiers as in the following example, which presents a TAG[\u2248, \u0338\u2248] whose language cannot be recognized by a TAGED. This example will be referred several times in Section 5, in order to illustrate the definitions used in the decision procedure of the emptiness problem for TAG[\u2248, \u0338\u2248].\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/a9b9/a9b95a2b-8187-4b36-9356-72bda3668c67.png\" style=\"width: 50%;\"></div>\n<div style=\"text-align: center;\">Figure 2: Term and successful run (Example 3.4).</div>\nExample 3.4. The TAG[\u2248, \u0338\u2248] of our running example accepts (in state qM) lists of dishes called menus, where every dish is associated with one identifier (state qid) and the time needed to cook it (state qt). We have other states accepting digits (qd), numbers (qN) and lists of dishes (qL). The TAG[\u2248, \u0338\u2248] A = \u27e8Q, \u03a3, F, \u2206, \u2205, C\u27e9is defined as follows: \u03a3 = {0, . . . , 9 : 0, N, L0 : 2, L, M :3}, Q = {qd, qN, qid, qt, qL, qM}, F = {qM}, and \u2206= {i \u2192qd|qN |qid|qt : 0 \u2264i \u22649} \u222a{N(qd, qN) \u2192qN | qid | qt, L0(qid, qt) \u2192qL, L(qid, qt, qL) \u2192qL, M(qid, qt, qL) \u2192qM}. The constraint C ensures that all the identifiers of the dishes in a menu are pairwise distinct (i.e. that qid is a key) and that the time to cook is the same for all dishes: C = qid \u0338\u2248qid \u2227qt \u2248qt. A term in L(A) together with an associated successful run are depicted in Figure 2. Althought this is a simple exercise, let us establish formally that TAG[\u2248, \u0338\u2248] are strictly more expressive than TAGED. Lemma 3.5. The class of languages recognized by TAG\u2227[\u2248, \u0338\u2248] strictly includes the class of languages recognized by TAGED. Proof. Since a TAGED is just a TAG\u2227[\u2248, \u0338\u2248] where no constraint of the form q \u0338\u2248q occurs, the inclusion holds. In order to see that it is strict, it suffices to show a language L which can be recognized by a TAG\u2227[\u2248, \u0338\u2248] but not by a TAGED. Let \u03a3 = {a : 0, s : 1, f : 2}. The set L of terms of T (\u03a3) of the form f(sn1(a), f(sn2(a), . . . , f(snk(a), a) . . .)), such that k \u22650 and the natural numbers ni, for i \u2264k, are pairwise distinct, is recognized by the following TAG\u2227[\u2248, \u0338\u2248]:\n\uf8f3 \uf8fe Assume that there exists a TAG\u2227[\u2248, \u0338\u2248] A without reflexive disequality constraints of the form q \u0338\u2248q (i.e. a TAGED), recognizing this language L. Then, there exists an accepting run r of A on the term t = f(s(a), f(s2(a), . . . f(s|QA|+1(a), a) . . .)) \u2208L. Therefore, r |= CA (the global constraint of A, which is positive by hypothesis).\nThere are two different positions pi = \ufffd \ufffd\ufffd \ufffd 2.2. . . . .2 .1 and pj = \ufffd \ufffd\ufffd \ufffd 2.2. . . . .2 .1, 0 \u2264i < j \u2264 |QA| such that r(pi) = r(pj). Let us show that r\u2032 = r[r|pi]pj is an accepting run of A on\nt\u2032 = t[t|pi]pj. Since r(pi) = r(pj) and r is a run of A on t, r\u2032 is a run of ta(A) on t\u2032. Hence, it suffices to prove that the constraint CA is satisfied by r\u2032. Consider a position p of the form 2.2. . . . .2 with |p| < j. We start by proving that any atomic constraint involving r\u2032(p) is satisfied. Note that r\u2032(p) = r(p) holds, and that the subterm t|p has only this occurrence in t. Thus, any atomic constraint involving r(p) and a state q occurring in r is necessarily of the form r(p) \u0338\u2248q. Since any state occurring in r\u2032 occurs also in r, any atomic constraint involving r\u2032(p) and a state q occurring in r\u2032 is of the form r\u2032(p) \u0338\u2248q. Moreover, the subterm t\u2032|p has only this occurrence in t\u2032. Thus, such a constraint is satisfied. Now consider two different positions p1, p2 which are not of the form described above. It remains to see that any atomic constraint involving r\u2032(p1) and r\u2032(p2) is satisfied. In the case where r\u2032|p1 and r\u2032|p2 are different, this is a direct consequence of the fact that both subruns r\u2032|p1 and r\u2032|p2 are also subruns of r at different positions. Otherwise, in the case where r\u2032|p1 and r\u2032|p2 are the same subrun, then, r\u2032(p1) = r\u2032(p2) holds, and any atomic constraint involving r\u2032(p1) and r\u2032(p2) must be of the form r\u2032(p1) \u2248r\u2032(p2) because A has no reflexive disequalities. Thus, the atomic constraint is also satisfied in this case. The following example shows a TABG recognizing a language that cannot be recognized by a TAG[\u2248, \u0338\u2248]. The proof is a simple exercise and it is left to the reader. Example 3.6. Assume that the terms of Example 3.4 are now used to record the activity of a restaurant. To this end, we transform the TAG of example 3.4 into a TABG as follows. First, in order to simplify the example we omit the restriction that all cooking times coincide, i.e. C = qid \u0338\u2248qid. Second, we add a new argument of type qt to L0, L and M, so that the old argument qt characterizes the theoretical time to cook, and the new qt characterizes the real time that was needed to cook the dish. Let us replace the transitions with L0, L and M in input by L0(qid, qt, qt) \u2212\u2212\u2212\u2192 2\u22483 qL, L0(qid, qt, qt) \u2212\u2212\u2212\u2192 2\u0338\u22483 q\u2032 L, L(qid, qt, qt, qL) \u2212\u2212\u2212\u2192 2\u22483 qL, L(qid, qt, qt, qL) \u2212\u2212\u2212\u2192 2\u0338\u22483 q\u2032 L, M(qid, qt, qt, qL) \u2212\u2212\u2212\u2192 2\u22483 qM, M(qid, qt, qt, qL) \u2212\u2212\u2212\u2192 2\u0338\u22483 q\u2032 M, where q\u2032 L is a new state meaning that there was an anomaly. We also add a transition L(qid, qt, qt, q\u2032 L) \u2192 q\u2032 L to propagate q\u2032 L and M(qid, qt, qt, q\u2032 L) \u2192q\u2032 M. By keeping the set of final states as {qM}, the recognized language of the TABG obtained is the set of records well cooked, i.e. such that for all dishes, the real time to cook is equal to the theoretical time. By redefining the set of final states as {q\u2032 M}, the recognized language is the set of records with an anomaly.\nABG A over \u03a3 whether t \u2208L(A).\nnd a TABG A over \u03a3 whether t \u2208L(A).\nProposition 3.7. Membership is NP-complete for TABG, by assuming that the maximum arity of the signature \u03a3 is a constant for the problem.\nProof. In order to prove that this problem is in NP, given a TABG A = \u27e8Q, \u03a3, F, \u2206, E, C\u27e9 and a term t \u2208T (\u03a3), we can non-deterministically guess a function M from Pos(t) into \u2206, and check that \u27e8t, M\u27e9is a successful run of A on t. The checking can be performed in polynomial time. In particular, testing equivalence modulo E can be performed in polynomial time using a dynamic programming scheme, by assuming that the maximum arity of \u03a3 is a constant of the problem, which is a usual assumption. More general results are given in [Nie96, CHJ94]. For NP-hardness, [FTT08, JKV09] present PTIME reductions of the satisfiability of Boolean expressions into membership for TAG\u2227[\u2248] whose constraints are conjunctions of equalities of the form q \u2248q.\nRecall that for plain TA, membership is in PTIME. The universality is the problem to decide, given a TABG A over \u03a3, whether L(A) = T (\u03a3). It is known to be undecidable already for a small subclass of TAG. Proposition 3.8. [FTT08, JKV09] Universality is undecidable for TAG\u2227[\u2248]. The following consequence is a new result for TAGED. Proposition 3.9. It is undecidable whether the language of a given TAG\u2227[\u2248] is regular. Proof. We show that universality is reducible to regularity using a new function symbol f with arity 2, and any non-regular language L which is recognizable by a TAG\u2227[\u2248] (such a language exists). Let A be an input of universality for TAG\u2227[\u2248] and let L\u2032 = \ufffd f(t1, t2) | t1 \u2208T (\u03a3) \u2227t2 \u2208L \ufffd \u222a \ufffd f(t1, t2) | t1 \u2208L(A) \u2227t2 \u2208T (\u03a3) \ufffd .\n\ufffd \ufffd \ufffd \ufffd It is possible to compute a new TAG\u2227[\u2248] A\u2032 recognizing the language L\u2032 (see Lemma 4.19). Thus, in order to conclude, it suffices to show that L(A) = T (\u03a3) if and only if L(A\u2032) is regular. For this purpose let us first define the quotient of a term language R by a term s with respect to a function symbol f: R/s := {t | f(s, t) \u2208R}. This operation preserves regular languages: for all s and f, if R is regular then R/s is regular. If L(A) = T (\u03a3), then L(A\u2032) is \ufffd f(t1, t2) | t1, t2 \u2208T (\u03a3) \ufffd , which is regular. Assume that L(A) \u0338= T (\u03a3) and let s \u2208T (\u03a3) \\ L(A). By construction, L(A\u2032)/s = L which is not regular. Hence L(A\u2032) is not regular.\n4. Arithmetic Constraints and Reduction to TABG\u2227\nThis section has two goals. The first goal is to present an extension of TABG by allowing certain global arithmetic constraints. They are interesting by themselves since they allow the representation of several natural properties in a simple way. The second goal is to show that the class of TABG languages coincides (in expressiveness) with the class of TABG\u2227 languages. In other words, for each TABG there exists a TABG\u2227recognizing the same language. This reduction will be very useful in Section 5 in order to prove decidability of emptiness of TABG. The reason for presenting both results in the same section is that arithmetic constraints simplify the task of transforming a TABG into a TABG\u2227representing the same language. This is because negations can be replaced by arithmetic constraints with an equivalent meaning in a first intermediate step, and such constraints are easier to deal with. All this work is developed in Subsection 4.2. Before that, in Subsection 4.1 we present a more general form of arithmetic constraints for which emptiness is undecidable. The motivation of this first subsection is to show the limits of positive results in this setting, and to justify the limited form of the constraints in Subsection 4.2.\n4.1. Global Integer Linear Constraints. Let Q be a set of states. A linear inequality over Q is an expression of the form \ufffd q\u2208Q aq \u00b7 |q| \u2265a or \ufffd q\u2208Q aq \u00b7 \u2225q\u2225\u2265a where every aq and a belong to Z. We consider the above linear inequalities as atomic constraints of tree automata with global constraints, and denote by |.|Z and \u2225.\u2225Z their respective types. The type Z denotes |.|Z and \u2225.\u2225Z together. Using the notation introduced in Section 3, TABG[\u2248, \u0338\u2248, |.|Z, \u2225.\u2225Z] (or TABG[\u2248, \u0338\u2248, Z]) denotes the class of tree automata with global and brother constraints modulo a flat theory of the form A = \u27e8Q, \u03a3, F, \u2206, E, C\u27e9such that \u27e8Q, \u03a3, F, \u2206, E\u27e9is a TAB (denoted tab(A)) and C is a Boolean combination of atomic constraints which can be linear inequalities as above or equality or disequality constraints of the form q \u2248q\u2032 or q \u0338\u2248q\u2032, with q, q\u2032 \u2208Q. Let A be a TABG[\u2248, \u0338\u2248, |.|Z, \u2225.\u2225Z] over \u03a3 and with state set Q and flat equational theory E, let r be a run of tab(A) on a term t \u2208T (\u03a3) and let q \u2208Q. Intuitively, the interpretation of |q| with respect to r is the number of occurrences of q in r, i.e. the number of positions p holding r(p) = q. The interpretation of \u2225q\u2225with respect to r is the number of different subterms (modulo E) in t reaching state q with r, i.e. the maximum number of positions p1, p2, . . . , pn holding r(p1) = r(p2) = . . . = r(pm) = q and such that the terms t|p1, t|p2, . . . , t|pn are pairwise different (modulo E). More formally, the interpretations of |q| and \u2225q\u2225with respect to r (and t) are defined, respectively, by the following cardinalities:\n\ufffd \ufffd \ufffd\ufffd \ufffd\ufffd This permits to define the satisfiability of linear inequalities with respect to r and t: r |= \ufffd q\u2208Q aq \u00b7 |q| \u2265a holds if and only if \ufffd q\u2208Q aq \u00b7 \ufffd|q| \ufffdr \u2265a holds, and r |= \ufffd q\u2208Q aq \u00b7 \u2225q\u2225\u2265a holds if and only if \ufffd q\u2208Q aq \u00b7 \ufffd\u2225q\u2225\ufffdr \u2265a holds. The satisfiability of the global constraint CA of A by r, denoted r |= CA is defined accordingly, and if r |= CA then r is called a run of A. A run of A on t \u2208T (\u03a3) is successful (or accepting) if r(\u03bb) \u2208FA. The language L(A) of A is the set of terms t for which there exists a successful run of A. Example 4.1. Let us add a new argument to the dishes of the menu of Example 3.4 which represents the price coded on two digits by a term N(d1, d0). We add a new state qp for the type of prices, and other states qcheap, qmoderate, qexpensive, qchic describing price level ranges, and transitions 0|1 \u2192qcheap, 2|3 \u2192qmoderate, 4|5|6 \u2192qexpensive, 7|8|9 \u2192qchic and N(qcheap, qd) \u2192qp, . . . . The price is a new argument of L0, L and M, hence we replace the transitions with these symbols in input by L0(qid, qt, qp) \u2192qL, L(qid, qt, qp, qL) \u2192qL, M(qid, qt, qp, qL) \u2192qM. We can use a linear inequality |qcheap| + |qmoderate| \u2212|qexpensive| \u2212 |qchic| \u22650 to characterize the moderate menus, and |qexpensive| + |qchic| \u22656 to characterize the menus with too many expensive dishes. A linear inequality \u2225qp\u2225\u22641 expresses that all the dishes have the same price. The class TAG[ |.|Z] has been studied under different names (e.g. Parikh automata in [KR02], linear constraint tree automata in [BMSL09]) and it has a decidable emptiness test. Indeed, the set of successful runs of a given TA with state set Q is a context-free language (seeing runs as words of Q\u2217), and the Parikh projection (the set of tuples over N|Q| whose components are the \ufffd|q| \ufffdr for every run r) of such a language is a semi-linear set. The idea for deciding emptiness for a TAG[ |.|Z] A is to compute this semi-linear set\nand to test the emptiness of its intersection with the set of solutions in N|Q| of CA, the arithmetic constraint of A (a Boolean combination of linear inequalities of type |.|Z) which is also semi-linear. This can be done in NPTIME, see [BMSL09]. To our knowledge, the class TAG[ \u2225.\u2225Z] with global constraints counting the number of distinct subterms in each state, has not been studied, even modulo an empty theory. Combining constraints of type \u2248and counting constraints of type |.|Z however leads to undecidability.\nand to test the emptiness of its intersection with the set of solutions in N|Q| of CA, the arithmetic constraint of A (a Boolean combination of linear inequalities of type |.|Z) which is also semi-linear. This can be done in NPTIME, see [BMSL09]. To our knowledge, the class TAG[ \u2225.\u2225Z] with global constraints counting the number of distinct subterms in each state, has not been studied, even modulo an empty theory.\nTheorem 4.2. Emptiness is undecidable for TAG\u2227[\u2248, |.|Z].\nProof. We consider the Hilbert\u2019s tenth problem, that is, solvability of an input equation P = 0 where P is a polynomial with integer coefficients and variables ranging over the natural numbers. This problem is known undecidable, and with the addition of new variables it is easily reducible to a question of the form \u2203x1 . . . \u2203xn : e1 \u2227. . . \u2227em, where x1, . . . , xn are variables ranging over the natural numbers, and e1, . . . , em are equations that are either of the form xj + xk = xt or xj \u2217xk = xt or xj = 1 or xj = 0. We reduce this last problem to emptiness of TAG\u2227[\u2248, |.|Z]. We consider an instance \u03d5 \u2261\u2203x1 . . . \u2203xn : e1 \u2227. . . \u2227em. Without loss of generality, we assume that e1, . . . , em\u2032 for m\u2032 \u2264m are all the equations of the form xj \u2217xk = xt, and that for each of such equations, the indexes j, k, t are different. We will construct a TAG\u2227[\u2248, |.|Z] A such that \u03d5 is true if and only if L(A) is not empty. Since the construction of A is technical, let us give first some intuitions (see Figure 3). Consider a possible assignment x1 := v1, . . . , xn := vn. A concrete run of A will be able to check whether this assignment proves that \u03d5 is true, and only accept the corresponding term if the answer is positive. In this run, there will be v1 occurrences of state q|x1|, v2 occurrences of state q|x2|, and so on. Equations of the form xj + xk = xt, xj = 1 and xj = 0 can directly be checked by constraints of the form |q|xj|| + |q|xk|| = |q|xt||, |q|xj|| = 1 and |q|xj|| = 0. For each equation ei of the form xj\u2217xk = xt there will be vk occurrences of a state called qei,|xk|. This is ensured by the constraint |qei,|xk|| = |q|xk||. Under each of these occurrences, there will be the same term, reaching a state qei,xj, and containing vj occurrences of a state qei,|xt|. The uniqueness of this term, as well as the number of occurrences of qei,|xt|, are both ensured by an equality constraint qxj \u2248qei,xj. In summary, there will be vj \u2217vk occurrences of state qei,|xt|. The satisfiability of the equation xj \u2217xk = xt will be checked by the constraint |q|xt|| = |qei,|xt||. The components of the TAG\u2227[\u2248, |.|Z] A = \u27e8Q, \u03a3, F, \u2206, C\u27e9are defined as follows: Q = {qaccept, qa} \u222a{q|xj|, qxj \ufffd\ufffdj \u2208{1, . . . , n}} \u222a{qei \ufffd\ufffdi \u2208{1, . . . , m\u2032}}\u222a {qei,xj, qei,|xt|, qei,|xk| \ufffd\ufffdi \u2208{1, . . . , m\u2032}, ei \u2261xj \u2217xk = xt} \u03a3 = {a : 0, g : 1, h : 2, f : n + m\u2032} F = {qaccept} \u2206 = {a \u2192qa, f(qx1, . . . , qxn, qe1, . . . , qem\u2032) \u2192qaccept}\u222a {g(qa) \u2192q|xj|, g(qa) \u2192qxj, g(q|xj|) \u2192q|xj|, g(q|xj|) \u2192qxj \ufffd\ufffdj \u2208{1, . . . , n}}\u222a {g(qa) \u2192qei,|xt|, g(qa) \u2192qei,xj, g(qei,|xt|) \u2192qei,|xt|, g(qei,|xt|) \u2192qei,xj, h(qei,xj, qa) \u2192qei,|xk|, h(qei,xj, qei,|xk|) \u2192qei,|xk|, h(qa, qei,|xk|) \u2192qei, h(qa, qa) \u2192qei \ufffd\ufffdi \u2208{1, . . . , m\u2032}, ei \u2261xj \u2217xk = xt}\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/7e28/7e2884e7-de5c-4e63-a546-6d52a383dbc4.png\" style=\"width: 50%;\"></div>\nFigure 3: Accepting run of s = f(gv1+1(a), . . . , gvn+1(a), se1, . . . , sem\u2032) and the subrun of sei, where ei is of the form xj \u2217xk = xt.\n\ufffd \ufffd \ufffd It remains to prove that \u03d5 is true if and only if L(A) is not empty. To this end, let us first assume that x1 := v1, . . . , xn := vn is a solution of \u03d5. In order to simplify the presentation, we denote the term h(a, h(s, h(s, . . . , h(s, a) . . .))), with k occurrences of s, by h[a, s, . . . (k) . . . , s, a], and given an equation ei \u2261xj \u2217xk = xt, we denote the term h[a, gvj+1(a), . . . (vk) . . . , gvj+1(a), a] by sei. Let us consider the term s = f(gv1+1(a), . . . , gvn+1(a), se1, . . . , sem\u2032). It is not difficult to see that the run of Figure 3 is an accepting run of s. Note that for each equation ei \u2261xj \u2217xk = xt, the constraints |qei,|xt|| = |q|xt||, |qei,|xk|| = |q|xk||, qxj \u2248qei,xj are satisfied, since xj := vj, xk := vk, xt := vt satisfies the equation. Now, assume that there is an accepting run r of A on a term s. Since r is accepting, the transition rule f(qx1, . . . , qxn, qe1, . . . , qem\u2032) \u2192qaccept is applied at the root of s. According to the form of the rules involving qx1, . . . , qxn, it holds that s is of the form s = f(gv1+1(a), . . . , gvn+1(a), se1, . . . , sem\u2032), for some natural numbers v1, . . . , vn and some terms se1, . . . , sem\u2032. Moreover, the states q|x1|, . . . , q|xn| have v1, . . . , vn occurrences, respectively. It remains to see that the assignment x1 := v1, . . . , xn := vn makes \u03d5 true. The satisfiability of a constraint of the form |q|xj|| + |q|xk|| = |q|xt|| (or |q|xj|| = 1 or |q|xj|| = 0) implies that vj + vk = vt (or vj = 1 or vj = 0), thus an equation of the form xj + xk = xt (or xj = 1 or xj = 0) holds with this assignment. It remains to see that every equation ei of the form xj \u2217xk = xt also holds with this assignment. According to the form of the rules of A and the satisfiability of the constraints |qei,|xk|| = |q|xk||, qxj \u2248qei,xj, the term sei is of the form h[a, gvj+1(a), . . . (vk) . . . , gvj+1(a), a]. Moreover, |qei,|xt|| has vj \u2217vk occurrences.\nTherefore, by the satisfiability of the constraint |qei,|xt|| = |q|xt||, it follows vj \u2217vk = vt, and hence the equation xj \u2217xk = xt holds with this assignment, and we are done.\n4.2. Global Natural Linear Constraints. We present now a restriction on linear inequalities which enables a decidable emptiness test when combined with \u2248and \u0338\u2248as global constraints. A natural linear inequality over Q is a linear inequality as above whose coefficients aq and a all have the same sign. We call them natural since it is equivalent to consider inequalities in both directions whose coefficients are all non-negative, like \ufffdaq \u00b7 |q| \u2264a, with aq, a \u2208N, to refer to \ufffd\u2212aq \u00b7|q| \u2265\u2212a. We also consider linear equalities \ufffdaq \u00b7|q| = a, with aq, a \u2208N, to refer to a conjunction of two natural linear inequalities. The types of the natural linear inequalities are denoted by |.|N and \u2225.\u2225N. Below, we shall abbreviate these two types by N. The main difference between the linear inequalities of type |.|Z and |.|N (and respectively \u2225.\u2225Z and \u2225.\u2225N) is that the former permits to compare the respective number of occurrences of two states, like e.g. in |q| \u2264|q\u2032|, whereas the latter only permits to compare the number of occurrences of one state (or a sum of the number occurrences of several states with coefficients) to a constant as e.g. in |q| \u22644 or |q| + 2|q\u2032| \u22649. In the rest of the subsection we show that TABG[\u2248, \u0338\u2248, N] has the same expressiveness as TABG\u2227[\u2248, \u0338\u2248]. The proof works in several steps: \u2022 First, we define the notion of normalized TABG[\u2248, \u0338\u2248, N], that is a TABG[\u2248, \u0338\u2248, N] with a constraint being a disjunction of conjunctions of literals in a simple form. \u2022 Second, we remove negative literals of the form \u00ac(q \u2248q\u2032) or \u00ac(q \u0338\u2248q\u2032), obtaining a list of TABG\u2227[\u2248, \u0338\u2248, N] such that the union of their languages coincides with the language of the original TABG[\u2248, \u0338\u2248, N]. In this step we use arithmetic constraints for simulating the removed negative literals. \u2022 Third, we remove arithmetic literals of type \u2225.\u2225N, obtaining a new list of TABG\u2227[\u2248, \u0338\u2248, |.|N] such that the union of their languages coincides with the language of the original TABG[\u2248 , \u0338\u2248, N]. In this step we use positive literals of types \u2248, \u0338\u2248, and |.|N in order to simulate the removed literals of type \u2225.\u2225N. \u2022 Fourth, we remove arithmetic literals of type |.|N, obtaining a new list of TABG\u2227[\u2248, \u0338\u2248] such that the union of their languages coincides with the language of the original TABG[\u2248, \u0338\u2248, N]. In this step, new states are used for counting the amount of occurrences of original states. \u2022 Finally, we show that TABG\u2227[\u2248, \u0338\u2248] are closed under union. Hence, we obtain a single TABG\u2227[\u2248, \u0338\u2248] whose language coincides with the one of the original TABG[\u2248, \u0338\u2248, N]. Definition 4.3. Let A = \u27e8Q, \u03a3, F, \u2206, E, C\u27e9be a TABG[\u2248, \u0338\u2248, N]. The constraint C is normalized if it is either true or false or a disjunction of conjunctions of literals, where all arithmetic literals are positive. Remember that the form of the positive arithmetic literals can be either a1\u2225q1\u2225+ . . . + an\u2225qn\u2225\u2297k or a1|q1|+. . .+an|qn|\u2297k, with \u2297in {\u2265, \u2264, =}, n > 0, k \u22650 and strictly positive a1, . . . , an. Lemma 4.4. Any TABG[\u2248, \u0338\u2248, N] can be effectively transformed into a normalized TABG[\u2248 , \u0338\u2248, N] with the same equational theory and preserving the language. Proof. First, by applying de Morgan laws, negations are moved inwards so that each negation is applied to just an atom. Second, negative arithmetic literals are made positive by\n4.2. Global Natural Linear Constraints. We present now a restriction on linear inequalities which enables a decidable emptiness test when combined with \u2248and \u0338\u2248as global constraints. A natural linear inequality over Q is a linear inequality as above whose coefficients aq and a all have the same sign. We call them natural since it is equivalent to consider inequalities in both directions whose coefficients are all non-negative, like \ufffdaq \u00b7 |q| \u2264a, with aq, a \u2208N, to refer to \ufffd\u2212aq \u00b7|q| \u2265\u2212a. We also consider linear equalities \ufffdaq \u00b7|q| = a, with aq, a \u2208N, to refer to a conjunction of two natural linear inequalities. The types of the natural linear inequalities are denoted by |.|N and \u2225.\u2225N. Below, we shall abbreviate these two types by N. The main difference between the linear inequalities of type |.|Z and |.|N (and respectively \u2225.\u2225Z and \u2225.\u2225N) is that the former permits to compare the respective number of occurrences of two states, like e.g. in |q| \u2264|q\u2032|, whereas the latter only permits to compare the number of occurrences of one state (or a sum of the number occurrences of several states with coefficients) to a constant as e.g. in |q| \u22644 or |q| + 2|q\u2032| \u22649. In the rest of the subsection we show that TABG[\u2248, \u0338\u2248, N] has the same expressiveness as TABG\u2227[\u2248, \u0338\u2248]. The proof works in several steps: \u2022 First, we define the notion of normalized TABG[\u2248, \u0338\u2248, N], that is a TABG[\u2248, \u0338\u2248, N] with a constraint being a disjunction of conjunctions of literals in a simple form. \u2022 Second, we remove negative literals of the form \u00ac(q \u2248q\u2032) or \u00ac(q \u0338\u2248q\u2032), obtaining a list of TABG\u2227[\u2248, \u0338\u2248, N] such that the union of their languages coincides with the language of the original TABG[\u2248, \u0338\u2248, N]. In this step we use arithmetic constraints for simulating the removed negative literals. \u2022 Third, we remove arithmetic literals of type \u2225.\u2225N, obtaining a new list of TABG\u2227[\u2248, \u0338\u2248, |.|N] such that the union of their languages coincides with the language of the original TABG[\u2248 , \u0338\u2248, N]. In this step we use positive literals of types \u2248, \u0338\u2248, and |.|N in order to simulate the removed literals of type \u2225.\u2225N. \u2022 Fourth, we remove arithmetic literals of type |.|N, obtaining a new list of TABG\u2227[\u2248, \u0338\u2248] such that the union of their languages coincides with the language of the original TABG[\u2248, \u0338\u2248, N]. In this step, new states are used for counting the amount of occurrences of original states. \u2022 Finally, we show that TABG\u2227[\u2248, \u0338\u2248] are closed under union. Hence, we obtain a single TABG\u2227[\u2248, \u0338\u2248] whose language coincides with the one of the original TABG[\u2248, \u0338\u2248, N]. Definition 4.3. Let A = \u27e8Q, \u03a3, F, \u2206, E, C\u27e9be a TABG[\u2248, \u0338\u2248, N]. The constraint C is normalized if it is either true or false or a disjunction of conjunctions of literals, where all arithmetic literals are positive. Remember that the form of the positive arithmetic literals can be either a1\u2225q1\u2225+ . . . + an\u2225qn\u2225\u2297k or a1|q1|+. . .+an|qn|\u2297k, with \u2297in {\u2265, \u2264, =}, n > 0, k \u22650 and strictly positive a1, . . . , an. Lemma 4.4. Any TABG[\u2248, \u0338\u2248, N] can be effectively transformed into a normalized TABG[\u2248 , \u0338\u2248, N] with the same equational theory and preserving the language. Proof. First, by applying de Morgan laws, negations are moved inwards so that each negation is applied to just an atom. Second, negative arithmetic literals are made positive by\nsimple transformations: inequalities are inverted and equalities become disjunctions of inequalities. Third, strict inequalities are converted into non-strict by adding or subtracting 1 to a side. Fourth, by applying simple arithmetic operations all such literals are made of the required form a1\u2225q1\u2225+. . .+an\u2225qn\u2225\u2297k or a1|q1|+. . .+an|qn|\u2297k, for \u2297in {\u2265, \u2264, =}, n > 0 and strictly positive a1, . . . , an. In this step, a trivially false literal is replaced by false, and a trivially true literal is replaced by true. Finally, by applying the standard transformation into disjunctive conjunctive normal form we get the desired result. In order to remove negative equality and disequality literals and positive arithmetic constraints, we use the idea of inserting new states which are synonyms of existing states. Intuitively, a synonym is a new state \u02c6q that behaves analogous to an existing state \u00afq, i.e. the rules and constraints are modified such that the relation of \u02c6q with the other states is the same as for \u00afq. Nevertheless, the constraints are further modified to ensure that, whenever \u00afq occurs in an execution, \u02c6q also occurs. Moreover, all subterms reaching \u02c6q are the same (or equivalent modulo the relation induced by the flat theory), but are different from (nonequivalent to) the ones reaching \u00afq. This way, an execution of the original automaton with occurrences of \u00afq can be transformed into an execution of the new automaton, where the occurrences of a concrete subterm (up to the equivalence relation) reaching \u00afq in the original execution now reach \u02c6q instead. Definition 4.5. Let A = \u27e8Q, \u03a3, F, \u2206, E, C\u27e9be a TABG[\u2248, \u0338\u2248, N]. Let \u00afq be a state in Q. Let \u02c6q be a state not in Q. We define F\u00afq\u2740\u02c6q as F if \u00afq is not in F, and as F \u222a{\u02c6q} if \u00afq is in F. We define \u2206\u00afq\u2740\u02c6q as the set of rules obtained from the rules of \u2206with all possible replacements of occurrences of \u00afq by \u02c6q. More formally, \u2206\u00afq\u2740\u02c6q is {f(q\u2032 1, . . . , q\u2032 n) \u2192q\u2032 n+1 | \u2203f(q1, . . . , qn) \u2192qn+1 \u2208\u2206: \u2200i \u2208{1, . . . , n + 1} : (qi = q\u2032 i \u2228(qi = \u00afq \u2227q\u2032 i = \u02c6q))}. We define C\u00afq\u2740\u02c6q as the constraint \ufffd (\u2225\u00afq\u2225= 0 \u2227\u2225\u02c6q\u2225= 0) \u2228(\u2225\u02c6q\u2225= 1 \u2227\u00afq \u0338\u2248\u02c6q) \ufffd \u2227C\u2032, where C\u2032 is obtained from the normalization of C by replacing each literal by a new formula according to the following description. \u2022 Each literal (q1 \u2248q2) is replaced by the conjunction of the literals of the set \ufffd q\u2032 1 \u2248q\u2032 2 \ufffd\ufffd ((q\u2032 1 = q1 \u2228(q1 = \u00afq \u2227q\u2032 1 = \u02c6q)) \u2227(q\u2032 2 = q2 \u2228(q2 = \u00afq \u2227q\u2032 2 = \u02c6q))) \ufffd . \u2022 Each literal (q1 \u0338\u2248q2) is replaced by the conjunction of the literals of the set \ufffd q\u2032 1 \u0338\u2248q\u2032 2 \ufffd\ufffd ((q\u2032 1 = q1 \u2228(q1 = \u00afq \u2227q\u2032 1 = \u02c6q)) \u2227(q\u2032 2 = q2 \u2228(q2 = \u00afq \u2227q\u2032 2 = \u02c6q))) \ufffd . \u2022 Each literal \u00ac(q1 \u2248q2) is replaced by the disjunction of the literals of the set \ufffd \u00ac(q\u2032 1 \u2248 q\u2032 2) \ufffd\ufffd((q\u2032 1 = q1 \u2228(q1 = \u00afq \u2227q\u2032 1 = \u02c6q)) \u2227(q\u2032 2 = q2 \u2228(q2 = \u00afq \u2227q\u2032 2 = \u02c6q))) \ufffd . \u2022 Each literal \u00ac(q1 \u0338\u2248q2) is replaced by the disjunction of the literals of the set \ufffd \u00ac(q\u2032 1 \u0338\u2248 q\u2032 2) \ufffd\ufffd((q\u2032 1 = q1 \u2228(q1 = \u00afq \u2227q\u2032 1 = \u02c6q)) \u2227(q\u2032 2 = q2 \u2228(q2 = \u00afq \u2227q\u2032 2 = \u02c6q))) \ufffd . \u2022 Each occurrence of |\u00afq| is replaced by |\u00afq| + |\u02c6q|, and each occurrence of \u2225\u00afq\u2225is replaced by \u2225\u00afq\u2225+ \u2225\u02c6q\u2225. We define A\u00afq\u2740\u02c6q as \u27e8Q \u222a{\u02c6q}, \u03a3, F\u00afq\u2740\u02c6q, \u2206\u00afq\u2740\u02c6q, E, C\u00afq\u2740\u02c6q\u27e9. We write (F\u00afq\u2740\u02c6q)\u00afq\u2032\u2740\u02c6q\u2032 for \u02c6q \u0338= \u00afq\u2032 and \u02c6q \u0338= \u02c6q\u2032 more succinctly as F\u00afq,\u00afq\u2032\u2740\u02c6q,\u02c6q\u2032, and similarly for \u2206\u00afq,\u00afq\u2032\u2740\u02c6q,\u02c6q\u2032, C\u00afq,\u00afq\u2032\u2740\u02c6q,\u02c6q\u2032 and A\u00afq,\u00afq\u2032\u2740\u02c6q,\u02c6q\u2032. The condition (\u2225\u00afq\u2225= 0 \u2227\u2225\u02c6q\u2225= 0) added to C\u00afq\u2740\u02c6q is necessary to satisfy L(A\u00afq\u2740\u02c6q) = L(A), as it is proved in Lemma 4.6. This lemma is not used in the rest of the article, since the introduction of synonyms is combined with other constraints in further transformations. Nevertheless, we preserve Lemma 4.6 since its proof gives intuition about the definition of synonyms, and the arguments are similar to other ones appearing later.\nLemma 4.6. Let A = \u27e8Q, \u03a3, F, \u2206, E, C\u27e9be a TABG[\u2248, \u0338\u2248, N]. Let \u00afq be a state in Q. Let \u02c6q be a state not in Q. Then, L(A\u00afq\u2740\u02c6q) = L(A).\nbe a state not in Q. Then, L(A\u00afq\u2740\u02c6q) = L(A). Proof. Accepting runs of A having no occurrence of \u00afq are also accepting runs of A\u00afq\u2740\u02c6q. An accepting run of A having occurrences of \u00afq can be converted into an accepting run of A\u00afq\u2740\u02c6q by choosing one subterm t reaching \u00afq and replacing \u00afq by \u02c6q at all positions with subterms equivalent to t by the relation induced by E. Accepting runs of A\u00afq\u2740\u02c6q can be converted into accepting runs of A by replacing each occurrence of \u02c6q by \u00afq. The following lemma makes use of synonyms in order to remove a negative literal of the form \u00ac(\u00afq \u2248\u00afq\u2032) preserving the language. The next one, Lemma 4.8, analogously permits to remove a negative literal of the form \u00ac(\u00afq \u0338\u2248\u00afq\u2032). Lemma 4.7. Let A = \u27e8Q, \u03a3, F, \u2206, E, C\u27e9be a TABG[\u2248, \u0338\u2248, N]. Let \u00afq, \u00afq\u2032 be states in Q. Let \u02c6q, \u02c6q\u2032 be distinct states not in Q. Let C be of the form \u00ac(\u00afq \u2248\u00afq\u2032) \u2227C\u2032. Let A\u2032 be \u27e8Q \u222a{\u02c6q, \u02c6q\u2032}, \u03a3, F\u00afq,\u00afq\u2032\u2740\u02c6q,\u02c6q\u2032, \u2206\u00afq,\u00afq\u2032\u2740\u02c6q,\u02c6q\u2032, E, (\u2225\u02c6q\u2225= 1 \u2227\u2225\u02c6q\u2032\u2225= 1 \u2227\u02c6q \u0338\u2248\u02c6q\u2032) \u2227C\u2032 \u00afq,\u00afq\u2032\u2740\u02c6q,\u02c6q\u2032\u27e9. Then, L(A\u2032) = L(A) holds. Proof. Accepting runs of A can be converted into accepting runs of A\u2032 as follows. First, we choose two subterms \u00aft and \u00aft\u2032 different modulo the equivalence relation induced by E and reaching \u00afq and \u00afq\u2032, respectively. Note that these terms must exist in order to satisfy the literal \u00ac(\u00afq \u2248\u00afq\u2032) of C. Second, we replace \u00afq by \u02c6q at all the positions with subterms equivalent to \u00aft by the relation induced by E. Similarly, we replace \u00afq\u2032 by \u02c6q\u2032 at all the positions with subterms equivalent to \u00aft\u2032 by the relation induced by E. This way, the subconstraint \u2225\u02c6q\u2225= 1 \u2227\u2225\u02c6q\u2032\u2225= 1 \u2227\u02c6q \u0338\u2248\u02c6q\u2032 is satisfied, but also C\u2032 \u00afq,\u00afq\u2032\u2740\u02c6q,\u02c6q\u2032 is satisfied. Accepting runs of A\u2032 can be converted into accepting runs of A by replacing each occurrence of \u02c6q by \u00afq, and each occurrence of \u02c6q\u2032 by \u00afq\u2032. Note that the subconstraint \u2225\u02c6q\u2225= 1 \u2227\u2225\u02c6q\u2032\u2225= 1 \u2227\u02c6q \u0338\u2248\u02c6q\u2032 ensures the existence of such occurrences, and with subterms which are different modulo the equivalence relation induced by E. Thus, the literal \u00ac(\u00afq \u2248\u00afq\u2032) of C is satisfied. The constraint C\u2032 is also satisfied. Lemma 4.8. Consider the same assumptions as in Lemma 4.7, except that C is of the form \u00ac(\u00afq \u0338\u2248\u00afq\u2032) \u2227C\u2032 and the constraint of A\u2032 is (\u2225\u02c6q\u2225= 1 \u2227\u2225\u02c6q\u2032\u2225= 1 \u2227\u02c6q \u2248\u02c6q\u2032) \u2227C\u2032 \u00afq,\u00afq\u2032\u2740\u02c6q,\u02c6q\u2032 Then, L(A\u2032) = L(A) holds. Proof. Analogous to the proof of Lemma 4.8. The following definition will be used to remove literals of type \u2225.\u2225N. Definition 4.9. Let C be a constraint, and let k be a natural number. By C\u2225\u00afq\u2225\u2740k we define the constraint obtained from C by replacing all occurrences of \u2225\u00afq\u2225by k. The following two lemmas show how to remove literals of the form \u2225q\u2225= 1 or \u2225q\u2225= 0 preserving the language. Lemma 4.10. Let A = \u27e8Q, \u03a3, F, \u2206, E, C\u27e9be a TABG[\u2248, \u0338\u2248, N]. Let \u00afq be a state in Q. Let C be of the form \u2225\u00afq\u2225= 1 \u2227C\u2032. Let A\u2032 be \u27e8Q, \u03a3, F, \u2206, E, |\u00afq| \u22651 \u2227\u00afq \u2248\u00afq \u2227C\u2032 \u2225\u00afq\u2225\u27401\u27e9. Then, L(A\u2032) = L(A) holds. Proof. Accepting runs of A\u2032 and A coincide because the constraints C and CA\u2032 have the same semantics.\n# \nLemma 4.11. Let A = \u27e8Q, \u03a3, F, \u2206, E, C\u27e9be a TABG[\u2248, \u0338\u2248, N]. Let \u00afq be a state in Q. Let C be of the form \u2225\u00afq\u2225= 0 \u2227C\u2032. Let A\u2032 be \u27e8Q, \u03a3, F, \u2206, E, |\u00afq| = 0 \u2227C\u2032 \u2225\u00afq\u2225\u27400\u27e9. Then, L(A\u2032) = L(A) holds.\nLemma 4.11. Let A = \u27e8Q, \u03a3, F, \u2206, E, C\u27e9be a TABG[\u2248, \u0338\u2248, N]. Let \u00afq be a state in Q. Let C be of the form \u2225\u00afq\u2225= 0 \u2227C\u2032. Let A\u2032 be \u27e8Q, \u03a3, F, \u2206, E, |\u00afq| = 0 \u2227C\u2032 \u2225\u00afq\u2225\u27400\u27e9. Then, L(A\u2032) = L(A) holds. Proof. Accepting runs of A\u2032 and A coincide because the constraints C and CA\u2032 have the same semantics. Now, we will use the above lemmas in order to iteratively remove all negative literals and the arithmetic literals of type \u2225.\u2225N. Each removal step is not defined for arbitrary normalized TABG[\u2248, \u0338\u2248, N], but just for normalized conjunctive TABG[\u2248, \u0338\u2248, N]. For this reason, we first describe how to transform a given normalized TABG[\u2248, \u0338\u2248, N] into a list of normalized conjunctive TABG[\u2248, \u0338\u2248, N] such that, the union of their languages coincides with the language of the original TABG[\u2248, \u0338\u2248, N]. Definition 4.12. Let A = \u27e8Q, \u03a3, F, \u2206, E, C\u27e9be a normalized TABG[\u2248, \u0338\u2248, N], such that C is of the form C1 \u2228C2 \u2228. . . \u2228Cn for conjunctive constraints C1, C2, . . . , Cn. Let A1 = \u27e8Q, \u03a3, F, \u2206, E, C1\u27e9, A2 = \u27e8Q, \u03a3, F, \u2206, E, C2\u27e9, . . . , An = \u27e8Q, \u03a3, F, \u2206, E, C",
    "paper_type": "theory",
    "attri": {
        "background": "This paper addresses the limitations of standard tree automata in testing for equality and disequality between subterms, particularly in the context of XML document processing, where such constraints are essential.",
        "problem": {
            "definition": "The problem is the inability of standard tree automata to recognize languages that require equality or disequality tests between subterms, leading to undecidability in certain cases.",
            "key obstacle": "The main challenge is that the emptiness problem for tree automata with equality and disequality tests is undecidable in general."
        },
        "idea": {
            "intuition": "The idea was inspired by the need to enforce constraints in tree structures, particularly for applications like XML processing, where distinctness of values at certain positions is crucial.",
            "opinion": "The proposed class of tree automata (TABG) combines both local and global constraints to enhance expressiveness while maintaining decidability.",
            "innovation": "The main innovation is the introduction of a class of tree automata that allows for testing equality and disequality modulo a flat equational theory, significantly extending previous models."
        },
        "Theory": {
            "perspective": "The theoretical perspective is built upon combining local constraints with global equality and disequality constraints within the framework of tree automata.",
            "opinion": "The authors assume that the combination of local and global constraints can be effectively managed to retain decidability.",
            "proof": "The authors prove the decidability of the emptiness problem for the proposed class of tree automata (TABG) by using a pumping argument and demonstrating that every sufficiently large term can be reduced to a smaller term still recognized by the automaton."
        },
        "experiments": {
            "evaluation setting": "The evaluation is conducted on various classes of tree automata, comparing TABG with TAGED and other existing models, using specific datasets derived from XML documents.",
            "evaluation method": "The evaluation method involves analyzing the decidability of the emptiness problem and demonstrating the expressiveness of the new automata class through theoretical proofs."
        },
        "conclusion": "The paper concludes that the emptiness problem for the class of tree automata with local and global constraints (TABG) is decidable, providing a significant advancement in the field of formal languages and automata theory.",
        "discussion": {
            "advantage": "The advantage of this paper is the establishment of a decidable framework for tree automata that can handle complex constraints, thus broadening their applicability.",
            "limitation": "A limitation noted is that while the class is expressive, the complexity of the constraints may lead to challenges in practical implementations.",
            "future work": "Future work can focus on exploring further extensions of TABG to include more complex constraints and investigating the efficiency of decision procedures for larger classes of automata."
        },
        "other info": [
            {
                "info1": "The paper discusses related work, highlighting how TABG generalizes previous models like TAGED and TACBB.",
                "info2": {
                    "info2.1": "The authors provide a thorough survey of existing literature on tree automata and their constraints.",
                    "info2.2": "They also mention ongoing projects and funding sources that supported their research."
                }
            }
        ]
    },
    "mount_outline": [
        {
            "section number": "1.1",
            "key information": "The paper addresses the limitations of standard tree automata in testing for equality and disequality between subterms, emphasizing the integration of formal languages and automata theory in software development."
        },
        {
            "section number": "1.4",
            "key information": "Highlight the need to enforce constraints in tree structures, particularly for applications like XML processing, where distinctness of values at certain positions is crucial."
        },
        {
            "section number": "2.2",
            "key information": "The paper provides a historical overview of the evolution of tree automata, particularly in the context of XML document processing and the constraints related to equality and disequality."
        },
        {
            "section number": "3.1",
            "key information": "Discuss specific applications of the proposed class of tree automata (TABG) in enhancing software development processes, particularly in XML processing."
        },
        {
            "section number": "4.1",
            "key information": "The proposed class of tree automata (TABG) combines both local and global constraints to enhance expressiveness while maintaining decidability, representing a novel approach in AI-driven code generation."
        },
        {
            "section number": "6.1",
            "key information": "Identify the challenges faced in practical implementations of the proposed tree automata class due to the complexity of the constraints."
        },
        {
            "section number": "6.3",
            "key information": "Future work can focus on exploring further extensions of TABG to include more complex constraints and investigating the efficiency of decision procedures for larger classes of automata."
        }
    ],
    "similarity_score": 0.5622927517410794,
    "image": null,
    "path": "/home/dany/codes/autosurvey/outputs/2025-01-11-1832_natur/papers/Decidable Classes of Tree Automata Mixing Local and Global Constraints Modulo Flat Theories.json"
}