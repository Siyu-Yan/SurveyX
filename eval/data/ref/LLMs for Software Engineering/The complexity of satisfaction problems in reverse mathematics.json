{
    "from": "arxiv",
    "scholar_id": null,
    "detail_id": "arXiv:1411.1592",
    "title": "The complexity of satisfaction problems in reverse mathematics",
    "abstract": "Satisfiability problems play a central role in computer science and engineering as a general framework for studying the complexity of various problems. Schaefer proved in 1978 that truth satisfaction of propositional formulas given a language of relations is either NP-complete or tractable. We classify the corresponding satisfying assignment construction problems in the framework of reverse mathematics and show that the principles are either provable over RCA or equivalent to WKL. We formulate also a Ramseyan version of the problems and state a different dichotomy theorem. However, the different classes arising from this classification are not known to be distinct.",
    "bib_name": "patey2015complexitysatisfactionproblemsreverse",
    "md_text": "# THE COMPLEXITY OF SATISFACTION PROBLEMS IN REVERSE MATHEMATICS\n13 Jan 2015\nAbstract. Satisfiability problems play a central role in computer science and engineering as a general framework for studying the complexity of various problems. Schaefer proved in 1978 that truth satisfaction of propositional formulas given a language of relations is either NP-complete or tractable. We classify the corresponding satisfying assignment construction problems in the framework of reverse mathematics and show that the principles are either provable over RCA0 or equivalent to WKL0. We formulate also a Ramseyan version of the problems and state a different dichotomy theorem. However, the different classes arising from this classification are not known to be distinct.\n# 1. Introduction\nA common way to solve a constrained problem in industry consists in reducing it to a satisfaction problem over propositional logic and using a SAT solver. The generality of the framework and its multiple applications make it a natural subject of interest for the scientific community and constraint satisfaction problems remains an active field of research. In 1978, Schaefer [10] gave a great insight in the understanding of the complexity of satisfiability problems by studying a parameterized class of problems and showing they admit a dichotomy between NP-completeness and tractability. Many other dichotomy theorems have been proven since, about refinements to AC0 reductions [1], variants about counting, optimization, 3-valued domains and many others [4, 7, 3]. The existence of dichotomies for n-valued domains with n > 3 remains open. Reverse mathematics is a vast program for the classification of the strength of mathematical theorems. It uses proof theoretic methods to reveal the computational content of theorems. This study has led to the main observation that many theorems are computationally equivalent to one of four axioms. One particular axiom is Weak K\u00f6nig\u2019s lemma (WKL0) which allows formalization of many compactness arguments and the solution to many satisfiability problems. We believe that studying constraint satisfaction problems (CSP) within this framework can lead to insights in both fields: in reverse mathematics, we can exploit the generality of constraint satisfaction problems to compare existing principles by reducing them to satisfaction problems. In CSP, reverse mathematics can yield a better understanding of the computational strength of satisfiability problems for particular classes of formulas. In particular we answer the question of Marek & Remmel [8] whether there are dichotomy theorems for infinite recursive versions of constraint satisfaction problems.1 Definition 1.1. Let \ufffd= {F,T} be the set of Booleans. An (infinite) set of Boolean formulas C is finitely satisfiable if every conjunction of a finite set of formulas in C is satisfiable.\nDate: November 5, 2018. 1 This paper is an extended version of a conference paper of the same name published in CiE 2014.\nSAT is the statement \u201cFor every finitely satisfiable set C of Boolean formulas over an infinite set of variables V, there exists an infinite assignment \u03bd : V \u2192\ufffdsatisfying C.\u201d The pair (V,C) forms an instance of SAT. The base axiom system for reverse mathematics is called RCA0, standing for Recursive Comprehension Axiom. It consists of basic Peano axioms together with a comprehension scheme restricted to \u22060 1 formulas and an the induction restricted to \u03a30 1 formulas.\nSAT is the statement \u201cFor every finitely satisfiable set C of Boolean formulas over an infinite set of variables V, there exists an infinite assignment \u03bd : V \u2192\ufffdsatisfying C.\u201d The pair (V,C) forms an instance of SAT.\nThe base axiom system for reverse mathematics is called RCA0, standing for Recursiv Comprehension Axiom. It consists of basic Peano axioms together with a comprehensio scheme restricted to \u22060 1 formulas and an the induction restricted to \u03a30 1 formulas.\nTheorem 1.2 (Simpson [11]). RCA0 \u22a2WKL0 \u2194SAT\nProof. WKL0 \u2192SAT: Let C be a finitely satisfiable set of formulas over a set of variables V. Let \u27e8xi | i \u2208\ufffd\u27e9enumerate V. For each \u03c3 \u22082<\ufffd, identify \u03c3 with the truth assignment \u03bd\u03c3 on {xi | i < |\u03c3|} given by (\u2200i < |\u03c3|)(\u03bd\u03c3(xi) = T \u2194\u03c3(i) = 1). Let T \u22862<\ufffdbe the tree T = {\u03c3 \u22082<\ufffd| \u00ac(\u2203\u03b8 \u2208C \u21be|\u03c3|)(\u03bd\u03c3(\u03b8) = F)}, where C \u21be|\u03c3| is the set of formulas in C coded by numbers less than |\u03c3|, and \u03bd\u03c3(\u03b8) is the truth value assigned to \u03b8 by \u03bd\u03c3 (note that \u03bd\u03c3(\u03b8) is undefined if \u03b8 contains a variable xm for m \u2265|\u03c3|). T exists by \u22060 1 comprehension and is downward closed. T is infinite because for any n \u2208\ufffd, any satisfying truth assignment of C \u21ben restricted to {xi | i < n} yields a string in T of length n. By WKL0 let P \u2286\ufffdbe a path through T. We show that every finite C0 \u2286C can be satisfied by the truth assignment \u03bd : V \u2192\ufffddefined for all xi \u2208V by \u03bd(xi) = T \u2194i \u2208P. Given C0 \u2286C finite, let n be such that C0 \u2286C \u21ben and such that Var(C0) \u2286{xi | i < n}. Now let \u03c3 \u227aP be such that |\u03c3| = n. Then (\u2200\u03b8 \u2208C0)(\u03bd\u03c3(\u03b8) = T) because \u03bd\u03c3(\u03b8) is defined for all \u03b8 \u2208C0 and \u03bd\u03c3(\u03b8) \u0338= F for all \u03b8 \u2208C0. Thus \u03bd\u03c3 satisfies C0. SAT \u2192WKL0: Let V = {xi | i \u2208\ufffd} be a set of distinct variables, and to each string \u03c3 \u22082<\ufffd, associate the formula \u03b8\u03c3 \u2261\ufffd i<|\u03c3| \u2113i, where \u2113i \u2261xi if \u03c3(i) = 1 and \u2113i \u2261\u00acxi if \u03c3(i) = 0. Let T \u22862<\ufffdbe an infinite tree, and, for each n \u2208\ufffd, let T n = {\u03c3 \u2208T | |\u03c3| = n}. Let C = {\ufffd \u03c3\u2208T n \u03b8\u03c3 | n \u2208\ufffd}. We show that every finite C0 \u2286C is satisfiable. Given C0 \u2286C finite, let n be maximum such that \ufffd \u03c3\u2208T n \u03b8\u03c3 \u2208C0 and, as T is infinite, let \u03c4 \u2208T have length n. Then \u03b8\u03c4 \u2192\u03c6 for every \u03c6 \u2208C0 because if \u03c6 = \ufffd \u03c3\u2208T m \u03b8\u03c3 \u2208C0, then m \u2264n, \u03b8\u03c4\u21bem is a disjunct of \u03c6, and \u03b8\u03c4 \u2192\u03b8\u03c4\u21bem. Therefore C0 is satisfiable by the truth assignment that satisfies \u03b8\u03c4. By SAT there exists a valid assignment \u03bd for C. Let P be {i \u2208\ufffd: \u03bd(xi) = T}. We show that P is a path through T. Given n \u2208\ufffd, let \u03c3 \u227aP be such that |\u03c3| = n. By definition of P, (\u2200i < n)(\u03c3(i) = 1 \u2194\u03bd(xi) = T), so \u03bd(\u03b8\u03c3) = T, from which it follows that \u03c3 \u2208T n. \u25a1 RWKL, a weakening of WKL0, has been recently introduced by Flood in [5]. Given an infinite binary tree, the principle does not assert the existence of a path, but rather of an infinite subset of a path through the tree. Initially called RKL, it has been renamed to RWKL in [2] to give a consistent R prefix to Ramseyan principles. This principle has been shown to be strictly weaker than SRT2 2 and WKL0 by Flood, and strictly stronger than DNR by Bienvenu & al. in [2]. By analogy with RWKL, we formulate Ramsey-type versions of satisfiability problems. Definition 1.3. Let C be a sequence of Boolean formulas over an infinite set of variables V. A set H is homogeneous for C if there is a truth value c \u2208\ufffdsuch that every conjunction of a finite set of formulas in C is satisfiable by a truth assignment \u03bd such that (\u2200a \u2208H)(\u03bd(a) = c).\nProof. WKL0 \u2192SAT: Let C be a finitely satisfiable set of formulas over a set of variables V. Let \u27e8xi | i \u2208\ufffd\u27e9enumerate V. For each \u03c3 \u22082<\ufffd, identify \u03c3 with the truth assignment \u03bd\u03c3 on {xi | i < |\u03c3|} given by (\u2200i < |\u03c3|)(\u03bd\u03c3(xi) = T \u2194\u03c3(i) = 1). Let T \u22862<\ufffdbe the tree T = {\u03c3 \u22082<\ufffd| \u00ac(\u2203\u03b8 \u2208C \u21be|\u03c3|)(\u03bd\u03c3(\u03b8) = F)}, where C \u21be|\u03c3| is the set of formulas in C coded by numbers less than |\u03c3|, and \u03bd\u03c3(\u03b8) is the truth value assigned to \u03b8 by \u03bd\u03c3 (note that \u03bd\u03c3(\u03b8) is undefined if \u03b8 contains a variable xm for m \u2265|\u03c3|). T exists by \u22060 1 comprehension and is downward closed. T is infinite because for any n \u2208\ufffd, any satisfying truth assignment of C \u21ben restricted to {xi | i < n} yields a string in T of length n. By WKL0 let P \u2286\ufffdbe a path through T. We show that every finite C0 \u2286C can be satisfied by the truth assignment \u03bd : V \u2192\ufffddefined for all xi \u2208V by \u03bd(xi) = T \u2194i \u2208P. Given C0 \u2286C finite, let n be such that C0 \u2286C \u21ben and such that Var(C0) \u2286{xi | i < n}. Now let \u03c3 \u227aP be such that |\u03c3| = n. Then (\u2200\u03b8 \u2208C0)(\u03bd\u03c3(\u03b8) = T) because \u03bd\u03c3(\u03b8) is defined for all \u03b8 \u2208C0 and \u03bd\u03c3(\u03b8) \u0338= F for all \u03b8 \u2208C0. Thus \u03bd\u03c3 satisfies C0. SAT \u2192WKL0: Let V = {xi | i \u2208\ufffd} be a set of distinct variables, and to each string \u03c3 \u22082<\ufffd, associate the formula \u03b8\u03c3 \u2261\ufffd i<|\u03c3| \u2113i, where \u2113i \u2261xi if \u03c3(i) = 1 and \u2113i \u2261\u00acxi if \u03c3(i) = 0. Let T \u22862<\ufffdbe an infinite tree, and, for each n \u2208\ufffd, let T n = {\u03c3 \u2208T | |\u03c3| = n}. Let C = {\ufffd \u03c3\u2208T n \u03b8\u03c3 | n \u2208\ufffd}. We show that every finite C0 \u2286C is satisfiable. Given C0 \u2286C finite, let n be maximum such that \ufffd \u03c3\u2208T n \u03b8\u03c3 \u2208C0 and, as T is infinite, let \u03c4 \u2208T have length n. Then \u03b8\u03c4 \u2192\u03c6 for every \u03c6 \u2208C0 because if \u03c6 = \ufffd \u03c3\u2208T m \u03b8\u03c3 \u2208C0, then m \u2264n, \u03b8\u03c4\u21bem is a disjunct of \u03c6, and \u03b8\u03c4 \u2192\u03b8\u03c4\u21bem. Therefore C0 is satisfiable by the truth assignment that satisfies \u03b8\u03c4. By SAT there exists a valid assignment \u03bd for C. Let P be {i \u2208\ufffd: \u03bd(xi) = T}. We show that P is a path through T. Given n \u2208\ufffd, let \u03c3 \u227aP be such that |\u03c3| = n. By definition of P, (\u2200i < n)(\u03c3(i) = 1 \u2194\u03bd(xi) = T), so \u03bd(\u03b8\u03c3) = T, from which it follows that \u03c3 \u2208T n. \u25a1 RWKL, a weakening of WKL0, has been recently introduced by Flood in [5]. Given\nDefinition 1.3. Let C be a sequence of Boolean formulas over an infinite set of variables V. A set H is homogeneous for C if there is a truth value c \u2208\ufffdsuch that every conjunction of a finite set of formulas in C is satisfiable by a truth assignment \u03bd such that (\u2200a \u2208H)(\u03bd(a) = c).\nDefinition 1.4. LRSAT is the statement \u201cLet C be a finitely satisfiable set of Boolean formulas over an infinite set of variables V. For every infinite set L \u2286V there exists an infinite set H \u2286L homogeneous for C.\u201d The corresponding instance of LRSAT is the tuple\n(V,C,L). RSAT is obtained by restricting LRSAT to L = V. Then an instance of RSAT is an ordered pair (V,C).\n(V,C,L). RSAT is obtained by restricting LRSAT to L = V. Then an instance of RSAT is an ordered pair (V,C). The equivalence between WKL0 and SAT over RCA0 extends to their Ramseyan version. The proof is relatively easy and directly adaptable from proof of Theorem 1.2. Theorem 1.5 (Bienvenu & al. [2]). RCA0 \u22a2RWKL \u2194RSAT \u2194LRSAT 1.1. Definitions and notations. Some classes of Boolean formulas \u2013 bijunctive, affine, horn, ... \u2013 have been extensively studied in complexity theory, leading to the well-known dichotomy theorem due to Schaefer. We give a precise definition of those classes in order to state our dichotomy theorems. Definition 1.6. A literal is either a Boolean variable (positive literal), or its negation (negative literal). A clause is a disjunction of literals. A clause is horn if it has at most one positive literal, co-horn if it has at most one negative literal and bijunctive if it has at most 2 literals. If we number Boolean variables, we can associate to each Boolean formula \u03d5 with Boolean variables x1,...,xn a relation [\u03d5] \u2286\ufffdn such that\u20d7a \u2208[\u03d5] iff \u03d5(\u20d7a) holds. If S is a set of relations, an S-formula over a set of variables V is a formula of the form R(y1,...,yn) for some R \u2208S and y1,...,yn \u2208V. Example 1.7. Let S = {\u2192}. (x \u2192y) is an S-formula but (x \u2192\u00acy) is not. Neither is (x \u2192y)\u2227(y \u2192z). The formula (x \u2192y) is equivalent to the horn clause (\u00acx\u2228y) where the literals are \u00acx and y. Definition 1.8. A formula \u03d5 is i-valid for i \u2208\ufffdif \u03d5(i,...,i) holds. It is horn (resp. cohorn, bijunctive) if it is a conjunction of horn (resp. co-horn, bijunctive) clauses. A formula is affine if it is a conjunction of formulas of the form x1 \u2295\u00b7\u00b7\u00b7\u2295xn = i for i \u2208\ufffdwhere \u2295is the exclusive or. A relation R \u2286{0,1}n is bijunctive (resp. horn, co-horn, affine, i-valid) if there is bijunctive (resp. horn, co-horn, affine, i-valid) formula \u03d5 such that R = [\u03d5]. A relation R is i-default for i \u2208\ufffdif for every\u20d7r \u2208R and every j < |\u20d7r|, the vector \u20d7s defined by \u20d7s( j) = i and\u20d7s(k) =\u20d7r(k) otherwise, is also in R. In particular every i-default relation is i-valid. We denote by ISAT(S) the class of satisfiable conjunctions of S-formulas. 1.2. Dichotomies. We first state the celebrated dichotomy theorem from Schaefer. Interestingly, the corresponding dichotomies in reverse mathematics are not based on the same classes of relations as the ones from Schaefer. Theorem 1.9 (Schaefer\u2019s dichotomy [10]). Let S be a finite set of Boolean relations. If S satisfies one of the conditions (a)\u2212( f) below, then ISAT(S) is polynomial-time decidable. Otherwise, ISAT(S) is log-complete in NP. (a) Every relation in S is F-valid. (b) Every relation in S is T-valid. (c) Every relation in S is horn (d) Every relation in S is co-horn (e) Every relation in S is affine. (f) Every relation in S is bijunctive. In the remainder of this paper, S will be a \u2013 possibly infinite \u2013 class of Boolean relations. Note that there is no effectiveness requirement on S. Definition 1.10. SAT(S) is the statement \u201cFor every finitely satisfiable set C of S-formulas over an infinite set of variables V, there exists an infinite assignment \u03bd : V \u2192\ufffdsatisfying C\u201d. We will prove the following theorem based on Schaefer\u2019s theorem.\n  1.1. Definitions and notations. Some classes of Boolean formulas \u2013 bijunctive, affine, horn, ... \u2013 have been extensively studied in complexity theory, leading to the well-known dichotomy theorem due to Schaefer. We give a precise definition of those classes in order to state our dichotomy theorems.\nTheorem 1.11. If S satisfies one of the conditions (a)\u2212(d) below, then SAT(S) is provable over RCA0. Otherwise SAT(S) is equivalent to WKL0 over RCA0. (a) Every relation in S is F-valid. (b) Every relation in S is T-valid. (c) If R \u2208S is not F-default then R = [x]. (d) If R \u2208S is not T-default then R = [\u00acx]. SAT(S) principles are not fully satisfactory as these are not robust notions: if we define SAT(S) in terms of satisfiable sets of conjunctions of S-formulas, this yields a different dichotomy theorems. In particular, RCA0 \u22a2SAT([x],[\u00acy]) whereas RCA0 \u22a2SAT([x \u2227 \u00acy]) \u2194WKL0. Ramseyan versions of satisfaction problems have better properties. Definition 1.12. RSAT(S) is the statement \u201cFor every finitely satisfiable setC of S-formulas over an infinite set of variables V, there exists an infinite set H \u2286V homogeneous for C\u201d. Usual reductions between satisfiability problems involve fresh variable introductions. This is why it is natural to define a localized version of those principles, i.e. where the homogeneous set has to lie within a pre-specified set. Definition 1.13. LRSAT(S) is the statement \u201cFor every finitely satisfiable set C of Sformulas over an infinite set of variables V and every infinite set X \u2286V, there exists an infinite set H \u2286X homogeneous for C\u201d. In particular, we define LRSAT(F-valid) (resp. LRSAT(T-valid), LRSAT(Horn), LRSAT(CoHo LRSAT(Bijunctive) or LRSAT(Affine)) to denote LRSAT(S) where S is the set of all Fvalid (resp. T-valid, horn, co-horn, bijunctive or affine) relations. We will prove the following dichotomy theorem. Theorem 1.14. Either RCA0 \u22a2LRSAT(S) or LRSAT(S) is equivalent to one of the following principles over RCA0: 1. LRSAT 2. LRSAT([x \u0338= y]) 3. LRSAT(Affine) 4. LRSAT(Bijunctive) As we will see in Theorem 4.1, each of those principles are equivalent to their non localized version. As well, LRSAT([x \u0338= y]) coincides with an already existing principle about bipartite graphs [2] called RCOLOR2 and LRSAT is equivalent to RWKL over RCA0. Hence LRSAT(S) is either provable over RCA0, or equivalent to one of RCOLOR2, RSAT(Affine), RSAT(Bijunctive) and RWKL over RCA0.\nTheorem 1.11. If S satisfies one of the conditions (a)\u2212(d) below, then SAT(S) is provable over RCA0. Otherwise SAT(S) is equivalent to WKL0 over RCA0. (a) Every relation in S is F-valid. (b) Every relation in S is T-valid. (c) If R \u2208S is not F-default then R = [x]. (d) If R \u2208S is not T-default then R = [\u00acx].\nIn particular, we define LRSAT(F-valid) (resp. LRSAT(T-valid), LRSAT(Horn), LRSAT(CoHorn), LRSAT(Bijunctive) or LRSAT(Affine)) to denote LRSAT(S) where S is the set of all Fvalid (resp. T-valid, horn, co-horn, bijunctive or affine) relations. We will prove the fol-\n3. LRSAT(Affine) 4. LRSAT(Bijunctive)\n \u0338 As we will see in Theorem 4.1, each of those principles are equivalent to their non localized version. As well, LRSAT([x \u0338= y]) coincides with an already existing principle about bipartite graphs [2] called RCOLOR2 and LRSAT is equivalent to RWKL over RCA0. Hence LRSAT(S) is either provable over RCA0, or equivalent to one of RCOLOR2, RSAT(Affine), RSAT(Bijunctive) and RWKL over RCA0.\n# 2. Schaefer\u2019s dichotomy theorem\nDefinition 2.1. Let S be a set of Boolean relations and V be a set of variables. Let \u03d5 be an S-formula over V. We denote by Var(\u03d5) the set of variables occurring in \u03d5. An assignment for \u03d5 is a function \u03bd : Var(\u03d5) \u2192{T,F}. An assignment can be naturally extended to a function over formulas by the natural interpretation rules for logical connectives. Then an assignment \u03bd satisfies \u03d5 if \u03bd(\u03d5) = T. The set of assignments satisfying \u03d5 is written Assign(\u03d5). Variable substitution is defined in the usual way and is written \u03d5[y/x], meaning that all occurrences of x in \u03d5 are replaced by y. We will also write \u03d5[y/X] where X is a set of variables to denote substitution of all occurrences of a variable of X in \u03d5 by y. A constant is either F or T. Definition 2.2. Let S be a set of Boolean relations. The class of existentially quantified Sformulas \u2013 i.e. of the form (\u2203\u20d7x)R[\u20d7x,\u20d7y] with R \u2208S \u2013 is denoted by Gen\u2217 NC(S). We also define\nDefinition 2.2. Let S be a set of Boolean relations. The class of existentially quantified S formulas \u2013 i.e. of the form (\u2203\u20d7x)R[\u20d7x,\u20d7y] with R \u2208S \u2013 is denoted by Gen\u2217 NC(S). We also defin\nRep\u2217 NC(S) = \ufffd [R] : R \u2208Gen\u2217 NC(S) \ufffd , ie. the relations represented by existentially quantified S-formula. By abuse of notation, we may use Rep\u2217 NC(R) when R is a relation to denote Rep\u2217 NC({R}). Given some set of Boolean realtions S, the set Rep\u2217 NC(S) might not exist over RCA0. However, we shall not use it as a set, but within relations of the form [R] \u2208Rep\u2217 NC(S), which can be seen as an abbreviation for an arithmetical statement using only R and S as parameters. Also note that the definition of Gen\u2217 NC(S) and Rep\u2217 NC(S) differ from Schaefer\u2019s definition of GenNC(S) and RepNC(S) in that the latter are closed under conjunction. Therefore, reusing Schaefer\u2019s lemmas must be done with some precautions, checking that his proofs do not use conjunction. This is the case of the following lemma: Lemma 2.3 (Schaefer in [10, 4.3]). RCA0 proves that at least one of the following holds: (a) Every relation in S is F-valid. (b) Every relation in S is T-valid. (c) [x] and [\u00acx] are contained in Rep\u2217 NC(S). (d) [x \u0338= y] \u2208Rep\u2217 NC(S). One easily sees that if every relation in S is F-valid (resp. T-valid) then RCA0 \u22a2SAT(S) as the assignment always equal to F (resp. T) is a valid assignment and is computable. We will now see that problems parameterized by relations either F-default or [x] (resp. Tdefault or [\u00acx]) are also solvable over RCA0. The proof of the following lemma justifies the name F-default (resp. T-default) by using a strategy for solving an instance (V,C) of SAT(S) consists in defining an assignment which given a variable x will give it the default value F (resp. T) unless it finds the clause (x) \u2208C, where (x) is the clause with x as the unique literal.\nRep\u2217 NC(S) = \ufffd [R] : R \u2208Gen\u2217 NC(S) \ufffd , ie. the relations represented by existentially quantified S-formula. By abuse of notation, we may use Rep\u2217 NC(R) when R is a relation to denote Rep\u2217 NC({R}). Given some set of Boolean realtions S, the set Rep\u2217 NC(S) might not exist over RCA0. However, we shall not use it as a set, but within relations of the form [R] \u2208Rep\u2217 NC(S), which can be seen as an abbreviation for an arithmetical statement using only R and S as parameters. Also note that the definition of Gen\u2217 NC(S) and Rep\u2217 NC(S) differ from Schaefer\u2019s definition of GenNC(S) and RepNC(S) in that the latter are closed under conjunction. Therefore, reusing Schaefer\u2019s lemmas must be done with some precautions, checking that his proofs do not use conjunction. This is the case of the following lemma: Lemma 2.3 (Schaefer in [10, 4.3]). RCA0 proves that at least one of the following holds: (a) Every relation in S is F-valid. (b) Every relation in S is T-valid. (c) [x] and [\u00acx] are contained in Rep\u2217 NC(S). (d) [x \u0338= y] \u2208Rep\u2217 NC(S). One easily sees that if every relation in S is F-valid (resp. T-valid) then RCA0 \u22a2SAT(S) as the assignment always equal to F (resp. T) is a valid assignment and is computable. We will now see that problems parameterized by relations either F-default or [x] (resp. Tdefault or [\u00acx]) are also solvable over RCA0. The proof of the following lemma justifies the name F-default (resp. T-default) by using a strategy for solving an instance (V,C) of SAT(S) consists in defining an assignment which given a variable x will give it the default value F (resp. T) unless it finds the clause (x) \u2208C, where (x) is the clause with x as the unique literal. Lemma 2.4. RCA0 proves that if the only relation in S which is not F-default is [x] or the only relation which is not T-default is [\u00acx] then SAT(S) holds. Proof. Assume [x] is the only relation of S which is not F-default. Given an instance (V,C) of SAT(S), define the assignment \u03bd : V \u2192{F,T} as follows: \u03bd(x) = T iff (x) \u2208C. The assignment \u03bd exists by \u22060 1-comprehension. Suppose for the sake of contradiction that there is a formula \u03d5 \u2208C such that \u03bd(\u03d5) = F. If \u03d5 = (x) for some variable x, then by definition of \u03bd, \u03bd(x) = T hence \u03bd(\u03d5) = T. So suppose \u03d5 = R(x1,...,xn) for some n \u2208\ufffd, where R is a F-default relation. Let I = {i < n : (xi) \u2208C}. As C is finitely satisfiable, so is \u03d5 \ufffd i\u2208I(xi). Let \u00b5 be an assignment satisfying \u03d5 \ufffd i\u2208I(xi). In particular \u00b5(xi) = T for each i \u2208I and \u00b5 satisfies \u03d5. By F-defaultness of R, the vector\u20d7r defined by\u20d7r(i) = T for i \u2208I and\u20d7r(i) = F otherwise is in R. But by definition of \u03bd, \u03bd(xi) = T iff i \u2208I, hence\u20d7r = \u03bd(x1)...\u03bd(xn) \u2208R and \u03bd(\u03d5) = T. So \u03bd is a valid assignment and the proof can easily be formalized over RCA0. Hence RCA0 \u22a2SAT(S). The same reasoning holds whenever the only relation of S which is not T-default is [\u00acx]. \u25a1\nLemma 2.4. RCA0 proves that if the only relation in S which is not F-default is [x] or the only relation which is not T-default is [\u00acx] then SAT(S) holds.\nonly relation which is not T-default is [\u00acx] then SAT(S) holds. Proof. Assume [x] is the only relation of S which is not F-default. Given an instance (V,C) of SAT(S), define the assignment \u03bd : V \u2192{F,T} as follows: \u03bd(x) = T iff (x) \u2208C. The assignment \u03bd exists by \u22060 1-comprehension. Suppose for the sake of contradiction that there is a formula \u03d5 \u2208C such that \u03bd(\u03d5) = F. If \u03d5 = (x) for some variable x, then by definition of \u03bd, \u03bd(x) = T hence \u03bd(\u03d5) = T. So suppose \u03d5 = R(x1,...,xn) for some n \u2208\ufffd, where R is a F-default relation. Let I = {i < n : (xi) \u2208C}. As C is finitely satisfiable, so is \u03d5 \ufffd i\u2208I(xi). Let \u00b5 be an assignment satisfying \u03d5 \ufffd i\u2208I(xi). In particular \u00b5(xi) = T for each i \u2208I and \u00b5 satisfies \u03d5. By F-defaultness of R, the vector\u20d7r defined by\u20d7r(i) = T for i \u2208I and\u20d7r(i) = F otherwise is in R. But by definition of \u03bd, \u03bd(xi) = T iff i \u2208I, hence\u20d7r = \u03bd(x1)...\u03bd(xn) \u2208R and \u03bd(\u03d5) = T. So \u03bd is a valid assignment and the proof can easily be formalized over RCA0. Hence RCA0 \u22a2SAT(S). The same reasoning holds whenever the only relation of S which is not T-default is [\u00acx]. \u25a1\nThe following lemma simply reflects the fact that SAT([x \u0338= y]) can be seen as a reformulation of COLOR2 which is equivalent to WKL0 over RCA0 [6].\n \u0338 \u2208  \u2194 Proof. As RCA0 \u22a2WKL0 \u2192SAT, it suffices to prove that RCA0 \u22a2SAT(S) \u2192WKL0 to obtain desired equivalence. Fix an infinite, locally bipartite, computable graph G = (V,E) and let \u03b8 \u2208Gen\u2217 NC(S) be such that [\u03b8] = [x \u0338= y]. By definition, \u03b8 = (\u2203\u20d7z)R(x,y,\u20d7z) for some R \u2208S. Take an infinite set W of fresh variables disjoint from V and define\nan instance (V \u222aW,C) of SAT(S) by taking C = {R(x,y,\u20d7z) : x < y \u2227{x,y} \u2208E \u2227(\u20d7z \u2208 W has not yet been used)}. The set C is finitely satisfiable because G is locally bipartite. Let \u03bd : V \u222aW \u2192\ufffdbe an assignment satisfying C and let P0 = {x \u2208V : \u03bd(x) = F} and P1 = {x \u2208V : \u03bd(x) = T}. We claim that P0,P1 is a bipartition of G. Suppose for the sake of absurd that the exists an i < 2 and two elements x < y \u2208Pi such that {x,y} \u2208E. Then there exists fresh variables\u20d7z \u2208W such that R(x,y,\u20d7z) \u2208C. In particular, \u03bd satisfies R(x,y,\u20d7z), hence the formula \u03b8(x,y) so \u03bd(x) \u0338= \u03bd(y), contradicting the assumption that x,y \u2208Pi. Hence RCA0 \u22a2SAT(S) \u2192COLOR2. \u25a1\nTheorem 1.11 is proven by a case analysis using Lemma 2.3, by noticing that when we are not in cases already handled by Lemma 2.4 and Lemma 2.5, we can find n-ary formulas encoding [x] and [\u00acx] with n \u22652. Thus diagonalizing against some values becomes a \u03a30 1 event.\nProof of Theorem 1.11. We reason by case analysis. Cases where every relation in S is Fvalid (resp. T-valid) are trivial. Cases where the only relation in S which is not F-default (resp. T-default) is [x] (resp. [\u00acx]), and whenever [x \u0338= y] \u2208Rep\u2217 NC(S) are already handled by Lemma 2.4 and Lemma 2.5. In the remaining case, by Lemma 2.3, [x] and [\u00acx] \u2208Rep\u2217 NC(S). First we show that it suffices to find two relations R1,R2 \u2208S together with two formulas \u03c81,\u03c82 \u2208Gen\u2217 NC(S) such that x1 \u0338\u2208Var(\u03c81)\u222aVar(\u03c82) and the following holds\n[(\u2203\u20d7z)R1(x1,\u20d7z)\u2227\u03c81(\u20d7z)] = [x1] and [(\u2203\u20d7z)R2(x1,\u20d7z)\u2227\u03c82(\u20d7z)] = [\u00acx1]\nto prove the existence of a path through an infinite binary tree. Then, we show that such relations exist. Note that the difference with the assumption that [x] and [\u00acx] \u2208Rep\u2217 NC(S) is that the relations R1 and R2 have arity greater than 1, hence the relations R1 and R2 may be added arbitrarily late to the set of formulas with fresh variables. Fix two disjoint sets of variables: V = \ufffd x\u03c3 : \u03c3 \u22082<\ufffd\ufffd and W = {y1,...}. Let T \u22862<\ufffdbe an infinite tree. We define an instance (V \u222aW,C) of SAT(S) such that every satisfying assignment computes an infinite path through T. We define the set C by stages C0 = /0 \u2286C1 \u2286... Assume that at stage s, the existence of each S-formula over variables \ufffd x\u03c3,yi : \u03c3 \u22082i,i < s \ufffd has been decided. Given some string \u03c3 \u22082<\ufffd, we denote by T [\u03c3] s the set of strings \u03c4 \u2208T of length s such that \u03c4 \u2ab0\u03c3. 1. If T [\u03c3\u23220] s is empty but not T [\u03c3\u23221] s for some \u03c3 \u22082<s, then add R2(x\u03c3,\u20d7y) and \u03c82(\u20d7y) to Cs for some fresh variables\u20d7y \u2208W \u2216{yi : i < s}. 2. If T [\u03c3\u23221] s is empty but not T [\u03c3\u23220] s for some \u03c3 \u22082<s, then add R1(x\u03c3,\u20d7y) and \u03c81(\u20d7y) to Cs for some fresh variables\u20d7y \u2208W \u2216{yi : i < s}. This finishes the construction. We have ensured that for any satisfying assignment \u03bd for C and any string \u03c3 \u2208T inducing an infinite subtree, \u03c3\u2322\u03bd(x\u03c3) also induces an infinite subtree. Define the strictly increasing sequence of strings \u03c30 = \u03b5 \u227a\u03c31 \u227a... by \u03c3s+1 = \u03c3\u2322 s \u03bd(x\u03c3s). The set P = \ufffd s \u03c3s is an infinite path through T. This proof can easily be formalized in RCA0. Hence RCA0 \u22a2SAT(S) \u2192WKL0. We now find the relations R1,R2 \u2208S and define the formulas \u03c81 and \u03c82 \u2208Gen\u2217 NC(S). Suppose there exists a relation R1 \u2208S which is not F-valid and is different from [x]. Define the formula \u03d5 = R1(x1,...) and let \u03bd \u2208Assign(\u03d5) be such that \u2200U \u2286\u03bd\u22121({T}), the assignment which coincides with \u03bd except for U does not satisfy \u03d5. Because R1 is not F-valid, \u03bd\u22121({T}) \u0338= /0. Suppose w.l.o.g. that x1 \u2208\u03bd\u22121({T}). Then the following holds\nfor some constants i2,i3,...\nSuppose now the only non F-valid relation in S is [x], in which case there is a F-valid relation R1 \u2208S which is not F-default. Thus there is a non-empty finite set I \u2282\u03c9 and a vector \u20d7r \u2208R1 such that \u20d7r(i) = T for each i \u2208I, but for every such \u20d7r \u2208R1, \u2203j \u0338\u2208I such that\u20d7r( j) = T. Consider a minimal (in pointwise natural order) such\u20d7r. Define the formula \u03d5 = R1(x1,...). Suppose without loss of generality that 1 \u0338\u2208I and \u20d7r(1) = T. Then the following holds for some constants i2,i3,...\nSimilarly we can take any relation R2 of S which is not T-valid and is different from [\u00acx] or which is T-valid but not T-default to construct an S-formula \u03c82 \u2208Gen\u2217 NC(S) with y \u0338\u2208Var(\u03c82) and constants i2,i3,... such that [R2(x1,...)\u2227\u03c82] = [\u00acx1 \u2227(x2 = i2)\u2227(x3 = i3)...]. This finishes the proof. \u25a1\n# 3. Ramsey-type Schaefer\u2019s dichotomy theorem\nThe proof of Theorem 1.14 can be split into four steps, each of them being dichotomies themselves. The first one, Theorem 3.4, states the existence of a gap between provability in RCA0 and implying LRSAT([x \u0338= y]) over RCA0. Then we focus successively on two classes of boolean formulas: bijunctive formulas (Theorem 3.12) and affine formulas (Theorem 3.16) whose corresponding principles happen to be either a consequence of LRSAT([x \u0338= y]) or equivalent to the full class of bijunctive (resp. affine) formulas. Remaining cases are handled by Theorem 3.17. We first state a trivial relation between a satisfaction principle and its Ramseyan version.\nLemma 3.1. RCA0 \u22a2SAT(S) \u2192LRSAT(S)\n# Lemma 3.1. RCA0 \u22a2SAT(S) \u2192LRSAT(S)\n  Proof. Let (V,C,L) be an instance of LRSAT(S). Let \u03bd :V \u2192\ufffdbe a satisfying assignme for C. Then either {x \u2208L : \u03bd(x) = T} or {x \u2208L : \u03bd(x) = F} is infinite, and both sets exi by \u22060 1-comprehension.\nDefinition 3.2. Let S be a set of relations over Booleans. The class of existentially quantified S-formulas with constants and closed under conjunction \u2013 i.e. of the form (\u2203\u20d7x)\ufffd i<n Ri[\u20d7x,\u20d7y,T,F] with Ri \u2208S \u2013 is denoted by Gen(S). We also define Rep(S) = {[R] : R \u2208Gen(S)}, ie. the relations represented by existentially quantified S-formula with constants and closed under conjunction. By abuse of notation, we may use Rep(R) when R is a relation to denote Rep({R}). We can also define similar relations without constants, denoted by GenNC and RepNC.\nLemma 3.3. RCA0 proves: If T is a sequence of Boolean relations such that [x \u0338= y] \u2208 RepNC(T), and S is a sequence of relations in RepNC(T), then LRSAT(T) \u2192LRSAT(S)\nProof. Let (V,C,L) be an instance of LRSAT(S). SayV = {x0,x1,...} andC = {\u03d50,\u03d51,...} Define an instance (V \u222aF,D,L) of LRSAT(T) where F = {y0,y1,...} is a set of fresh variables disjoint from V, and D is a set of formulas defined by stages as follows. At stage 0, D = /0. In order to make D computable, we will ensure that after stage s, no formula over {xi,yi : i < s} will be added to D. At stage s, we want to add constraints of \u03d5s to D. Because S \u2286RepNC(T) and T is c.e., we can effectively find a formula\n\u25a1\n\u03c8 \u2208GenNC(T) equivalent to \u03d5s and translate it into a finite set of formulas \u03c8\u2217as follows: (\u2203z.\u03c81)\u2217\u2243(\u03c81[y/z])\u2217where y \u2208F is a fresh variable, (\u03c81 \u2227\u03c82)\u2217\u2243\u03c8\u2217 1 \u222a\u03c8\u2217 2, R(xi1,...,xin)\u2217\u2243{R(yj1,...,yjn),xi1 = yj1,...,xin = yjn} where yjk are fresh variables of F and x = y is a notation for the composition of (\u2203z)x \u0338= z\u2227z \u0338= y. Add \u03c8\u2217to D. It is easy to check that any solution to (V \u222aF \u222a{c0,c1},D,L) is a solution to (V,C,L). \u25a1\nThe proof of Theorem 3.4 follows Theorem 3.10.\nLemma 3.5 (Schaefer in [10, 3.2.1]). RCA0 proves: If S contains some relation which is not horn and some relation which is not co-horn, then [x \u0338= y] \u2208Rep(S).\nLemma 3.6. RCA0 proves that at least one of the following holds:\n(a) Every relation in S is F-valid.\n(b) Every relation in S is T-valid.\n(c) Every relation in S is horn.\n(d) Every relation in S is co-horn.\n(e) [x \u0338= y] \u2208RepNC(S).\nProof. Assume none of cases (a), (b) and (e) holds. Then by Lemma 2.3, [x] and [\u00acx] are contained in RepNC(S), hence RepNC(S) = Rep(S). So by Lemma 3.5, either every relation in S is horn, or every relation in S is co-horn. \u25a1 It is easy to see that LRSAT(F-valid) and LRSAT(T-valid) both hold over RCA0. We will now prove that so do LRSAT(Horn) and LRSAT(CoHorn), but first we must introduce the powerful tool of closure under functions. Definition 3.7. We say that a relation R \u2286\ufffdn is closed or invariant under an m-ary function f and that f is a polymorphism of R if for every m-tuple \u27e8v1,...,vm\u27e9of vectors of R, \u20d7f(v1,...,vm) \u2208R where \u20d7f is the coordinate-wise application of the function f.\nWe denote the set of all polymorphisms of R by Pol(R), and for a set \u0393 of Boolean relations we define Pol(\u0393) = {f : f \u2208Pol(R) for every R \u2208\u0393}. Similarly for a set B of Boolean functions, Inv(B) = {R : B \u2286Pol(R)} is the set of invariants of B. One easily sees that the projection functions are polymorphism of every Boolean relation R. In particular, the identity function is a polymorphism of R. As well, the composition of polymorphisms of R form again a polymorphism of R. So given a set of Boolean relations S, Pol(S) contains all projection functions and is closed under composition. The sets of functions satisfying those closure properties have been studied in universal algebra under the name of clones. We have seen that for every set of Boolean relations S, Pol(S) is a clone. Post [9] studied the lattice of clones of Boolean functions and proved that they admit a finite basis. The lattice structure of the Boolean clones has connections with the complexity of satifiability problems. Indeed, if some clone A is a subset of another clone B, then Inv(A) \u2287 Inv(B). But then trivially LRSAT(Inv(A)) \u2192LRSAT(Inv(B)). As well, we shall see that as soon as [x = y] \u2208RepNC(S), the sets RepNC(S) and Inv(Pol(S)) coincide. Therefore, assuming that the equality relation is representable in S, the study of the strength of LRSAT(S) can be reduced to the study of the strength of LRSAT(Inv(A)) for every clone in Post\u2019s lattice.\n\u25a1\nDefinition 3.8. The conjunction function conj : \ufffd2 \u2192\ufffdis defined by conj(a,b) = a \u2227b, the disjunction function disj : \ufffd2 \u2192\ufffdby disj(a,b) = a\u2228b, the affine function aff : \ufffd3 \u2192\ufffd by aff(a,b,c) = a \u2295b \u2295c = T and the majority function maj : \ufffd3 \u2192\ufffdby maj(a,b,c) = (a\u2227b)\u2228(a\u2227c)\u2228(b\u2227c). The following theorem due to Schaefer characterizes relations in terms of closure under some functions. The proof is relativizable and involves finite objects. Hence it can be easily proven to hold over RCA0.\n# Theorem 3.9 (Schaefer [10]). A relation is\n(1) horn iff it is closed under conjunction function (2) co-horn iff it is closed under disjunction function (3) affine iff it is closed under affine function (4) bijunctive iff it is closed under majority function\nIn other words, using Post\u2019s lattice, a relation R is horn iff E2 \u2286Pol(R), co-horn if V2 \u2286Pol(R), affine iff L2 \u2286Pol(R) and bijunctive iff D2 \u2286Pol(R). In the case of horn and co-horn relations, we will use the closure of the valid assignments under the conjunction and disjunction functions to prove that LRSAT(Horn) and LRSAT(CoHorn) both hold over RCA0.\n \u22a2 Proof. We will prove it over RCA0 for the horn case. The proof for co-horn relations is similar. Let (V,C,L) be an instance of LRSAT(Horn) and F \u2286L be the collection of variables x \u2208L such that there exists a finite set Cfin \u2286C for which every valid assignment \u03bd satisfies \u03bd(x) = T. Case 1: F is infinite. Because F is \u03a30 1, we can find an infinite \u22060 1 subset H of F. The set H is homogeneous for C with color T. Case 2: F is finite. We take H = L \u2216F and claim that H is homogeneous for C with color F. If H is not homogeneous for C, then there exists a finite set Cfin \u2286C witnessing it. Let Hfin = Var(Cfin) \u2229H. By definition of not being homogeneous with color F, for every assignment \u03bd satisfying Cfin, there exists a variable x \u2208Hfin such that \u03bd(x) = T. By definition of H, for each variable x \u2208H there exists a valid assignment \u03bdx such that \u03bdx(x) = F. By Theorem 3.9, the class valid assignments of a finite horn formula is closed under conjunction. So \u03bd = \ufffd x\u2208Hfin \u03bdx is a valid assignment for Cfin such that \u03bd(x) = F for each x \u2208Hfin. Contradiction. \u25a1 Proof of Theorem 3.4. If every relation in S is F-valid (resp. T-valid) then LRSAT(S) holds obviously over RCA0. If every relation in S is horn (resp. co-horn) then by Theorem 3.10, LRSAT(S) holds also over RCA0. By Lemma 3.6, the only remaining case is where [x \u0338= y] \u2208RepNC(S). There exists a finite (hence c.e.) subset T \u2286S such that [x \u0338= y] \u2208RepNC(T). By Lemma 3.3, RCA0 \u22a2LRSAT(T) \u2192LRSAT([x \u0338= y]), hence RCA0 \u22a2LRSAT(S) \u2192LRSAT([x \u0338= y]). \u25a1 The following technical lemma will be very useful for the remainder of the paper. Lemma 3.11. RCA0 proves the following: Suppose T is a sequence of Boolean relations such that\n  Proof. We will prove it over RCA0 for the horn case. The proof for co-horn relations is similar. Let (V,C,L) be an instance of LRSAT(Horn) and F \u2286L be the collection of variables x \u2208L such that there exists a finite set Cfin \u2286C for which every valid assignment \u03bd satisfies \u03bd(x) = T. Case 1: F is infinite. Because F is \u03a30 1, we can find an infinite \u22060 1 subset H of F. The set H is homogeneous for C with color T. Case 2: F is finite. We take H = L \u2216F and claim that H is homogeneous for C with color F. If H is not homogeneous for C, then there exists a finite set Cfin \u2286C witnessing it. Let Hfin = Var(Cfin) \u2229H. By definition of not being homogeneous with color F, for every assignment \u03bd satisfying Cfin, there exists a variable x \u2208Hfin such that \u03bd(x) = T. By definition of H, for each variable x \u2208H there exists a valid assignment \u03bdx such that \u03bdx(x) = F. By Theorem 3.9, the class valid assignments of a finite horn formula is closed under conjunction. So \u03bd = \ufffd x\u2208Hfin \u03bdx is a valid assignment for Cfin such that \u03bd(x) = F for each x \u2208Hfin. Contradiction. \u25a1\n1. T contains a relation which is not F-valid 2. T contains a relation which is not T-valid 3. [x \u0338= y] \u2208RepNC(T)\nIf S is a sequence such that S \u2286RepNC(T \u222a{[x],[\u00acx]}) then LRSAT(T) \u2192LRSAT(S). Proof. We reason by case analysis. Suppose that [x] and [\u00acx] are both in RepNC(T). Then S \u2286RepNC(T), so by Lemma 3.3, RCA0 \u22a2LRSAT(T) \u2192LRSAT(S). Suppose now that either [x] or [\u00acx] is not in RepNC(T). Then by Lemma 4.3 of [10], every relation in T is complementive, that is, if\u20d7r \u2208R for some R \u2208T, then the pointwise negation of\u20d7r is also in R. By Lemma 3.3, it suffices to ensure that RCA0 \u22a2LRSAT(RepNC(T)) \u2192 LRSAT(T \u222a{[x],[\u00acx]}) to conclude, as RCA0 \u22a2LRSAT(T) \u2192LRSAT(RepNC(T)). Let (V,C,L) be an instance of LRSAT(T \u222a{[x],[\u00acx]}). SayV = {x0,x1,...} andC = {\u03d50,\u03d51,...} Define an instance (V \u222a{c0,c1},D,L) of LRSAT(RepNC(T)) such that c0,c1 \u0338\u2208V and with the set of formulas\nD = {c0 \u0338= c1}\u222a{R(\u20d7x) \u2208C : R \u0338= [x]\u2227R \u0338= [\u00acx]}\u222a{x = c0 : (\u00acx) \u2208C}\u222a{x = c1 : (x) \u2208C} Note that [x = y] \u2208RepNC(T) as [x = y] = [(\u2203z)x \u0338= z\u2227z \u0338= y] and [x \u0338= y] \u2208RepNC(T). The instance (V \u222a{c0,c1},D,L) is obviously finitely satisfiable as every valid assignment \u03bd of (V,C,L) induces an assignment of (V \u222a{c0,c1},D,L) by setting \u03bd(c0) = F and \u03bd(c1) = T. Conversely, we prove that for every assignment \u03bd satisfying (V \u222a{c0,c1},D,L), the assignment \u00b5 defined to be \u03bd if \u03bd(c0) = F and the pointwise negation of \u03bd if \u03bd(c0) = T satisfies (V,C,L). Suppose there exists a finite subset E \u2282C such that \u00b5(\ufffdE) = F. For every formula (\u00acx) \u2208E, \u00b5(x) = \u00b5(c0) = F and for every (x) \u2208E, \u00b5(x) = \u00b5(c1) = T. So there must exist a relation R \u2208T such that R(\u20d7x) \u2208E and \u00b5(R(\u20d7x)) = F. By complementation of R, \u03bd(R(\u20d7x)) = F, but R(\u20d7x) \u2208D, contradicting the assumption that \u03bd satisfies D. Therefore, every infinite set H \u2286L homogeneous for D is homogeneous for C. \u25a1\n3.2. Bijunctive satisfiability. Our second dichotomy theorem concerns bijunctive relations. Either the related principle is a consequence of LRSAT([x \u0338= y]) over RCA0, or it has full strength of LRSAT(Bijunctive). In the remainder of this subsection, we will make the following assumptions and denote them by the shorthand in the right column of the table: (i) S contains only bijunctive relations (D2 \u2286Pol(S)) (ii) S contains a relation which is not F-valid (I0 \u0338\u2286Pol(S)) (iii) S contains a relation which is not T-valid (I1 \u0338\u2286Pol(S)) (iv) [x \u0338= y] \u2208RepNC(S) (Pol(S) \u2286D)\nTheorem 3.12. If S contains only affine relations then RCA0 \u22a2LRSAT([x \u0338= y]) \u2192LRSAT(S). Otherwise RCA0 \u22a2LRSAT(S) \u2194LRSAT(Bijunctive).\n# The proof of Theorem 3.12 follows Lemma 3.15.\nDefinition 3.13. For any set S of relations, the co-clone of S is the closure of S by existential quantification, equality and conjunction. We denote it by \u27e8S\u27e9.\nRemark that in general, RepNC(S) may be different from \u27e8S\u27e9if [x = y] \u0338\u2208RepNC(S). However in our case, we assume that [x \u0338= y] \u2208RepNC(S), hence [x = y] \u2208RepNC(S) and RepNC(S) = \u27e8S\u27e9. The following property will happen to be very useful for proving that a relation R \u2208RepNC(S).\nLemma 3.15. One of the following holds: (a) RepNC(S) contains all bijunctive relations. (b) S \u2286RepNC({[x],[x \u0338= y]}).\n\u25a1\nProof. By the blanket assumption of the subsection, D2 \u2286Pol(S) \u2286D. Either D1 \u2286Pol(S) or Pol(S) = D2. If D1 \u2286Pol(S), then every relation in S is affine, so S \u2286Inv(D1) = RepNC({[x],[x \u0338= y]}). If Pol(S) = D2 then RepNC(S) = \u27e8S\u27e9= Inv(Pol(S)) = Inv(D2) which is the set of all bijunctive relations. \u25a1 Proof of Theorem 3.12. By Lemma 3.15, either RepNC(S) contains all bijunctive relations or S \u2286RepNC({[x],[x \u0338= y]}). In the latter case, by Lemma 3.11 LRSAT([x \u0338= y]) implies LRSAT(S) over RCA0. In the former case, there exists a finite basis S0 \u2286S such that RepNC(S0) contains all bijunctive relations. In particular S0 is a c.e. set, so RCA0 \u22a2 LRSAT(S0) \u2192LRSAT(Bijunctive). Any instance of LRSAT(S0) being an instance of LRSAT(S), RCA0 \u22a2LRSAT(S) \u2192LRSAT(Bijunctive). The reverse implication follows directly from the assumption that every relation in S is bijunctive. So RCA0 \u22a2LRSAT(S) \u2194 LRSAT(Bijunctive). \u25a1 3.3. Affine satisfiability. In this section, we will prove that if S satisfies none of the previ-\nProof. By the blanket assumption of the subsection, D2 \u2286Pol(S) \u2286D. Either D1 \u2286Pol(S) or Pol(S) = D2. If D1 \u2286Pol(S), then every relation in S is affine, so S \u2286Inv(D1) = RepNC({[x],[x \u0338= y]}). If Pol(S) = D2 then RepNC(S) = \u27e8S\u27e9= Inv(Pol(S)) = Inv(D2) which is the set of all bijunctive relations. \u25a1 Proof of Theorem 3.12. By Lemma 3.15, either RepNC(S) contains all bijunctive relations or S \u2286RepNC({[x],[x \u0338= y]}). In the latter case, by Lemma 3.11 LRSAT([x \u0338= y]) implies LRSAT(S) over RCA0. In the former case, there exists a finite basis S0 \u2286S such that RepNC(S0) contains all bijunctive relations. In particular S0 is a c.e. set, so RCA0 \u22a2 LRSAT(S0) \u2192LRSAT(Bijunctive). Any instance of LRSAT(S0) being an instance of LRSAT(S), RCA0 \u22a2LRSAT(S) \u2192LRSAT(Bijunctive). The reverse implication follows directly from the assumption that every relation in S is bijunctive. So RCA0 \u22a2LRSAT(S) \u2194 LRSAT(Bijunctive). \u25a1 3.3. Affine satisfiability. In this section, we will prove that if S satisfies none of the previous cases and contains only affine relations, then the corresponding Ramseyan satisfaction problem is equivalent to LRSAT(Affine) over RCA0. So suppose that (i) S contains only affine relations (L2 \u2286Pol(S)) (ii) S contains a relation which is not bijunctive (D2 \u0338\u2286Pol(S)) (iii) S contains a relation which is not F-valid (I0 \u0338\u2286Pol(S)) (iv) S contains a relation which is not T-valid (I1 \u0338\u2286Pol(S)) (v) [x \u0338= y] \u2208RepNC(S) (Pol(S) \u2286D) In particular, Pol(S) \u228aD.\n3.3. Affine satisfiability. In this section, we will prove that if S satisfies none of the previous cases and contains only affine relations, then the corresponding Ramseyan satisfaction problem is equivalent to LRSAT(Affine) over RCA0. So suppose that\n(i) S contains only affine relations (ii) S contains a relation which is not bijunctive (iii) S contains a relation which is not F-valid (iv) S contains a relation which is not T-valid (v) [x \u0338= y] \u2208RepNC(S) n particular, Pol(S) \u228aD.\n# Theorem 3.16. RCA0 \u22a2LRSAT(S) \u2194LRSAT(Affine)\n  Proof. By assumption, every relation in S is affine. Hence RCA0 \u22a2LRSAT(Affine) \u2192 LRSAT(S). As L2 \u2286Pol(S) \u228aD, Pol(S) is either L3 or L2. In particular, Pol(S \u222a {[x],[\u00acx]}) = L2 Considering the corresponding invariants,\nThere exists a finite basis S0 such that RepNC(S0) contains all affine relations. Inv(L2 being the set of affine relations, S0 \u2282RepNC(S \u222a{[x],[\u00acx]}). There exists a finite (henc c.e.) subset T of S such that S0 \u2286RepNC(T \u222a{[x],[\u00acx]}). In particular,\nBy Lemma 3.11, RCA0 \u22a2LRSAT(T) \u2192LRSAT(Affine), hence RCA0 \u22a2LRSAT(S) \u2192 LRSAT(Affine). \u25a1\n\u222a{} \u27e8\u222a{}\u27e9\u222a{} \u2287 Note that Inv(I2) is the set of all Boolean relations. As Inv(I2) has a finite basis, there exists a finite S0 \u2286S such that RepNC(S0 \u222a{[x]}) contains all Boolean relations. By Lemma 3.11, RCA0 \u22a2LRSAT(S0) \u2192LRSAT. Hence RCA0 \u22a2LRSAT(S) \u2194LRSAT. \u25a1\n\u25a1\nProof of Theorem 1.14. By case analysis over Pol(S). If I0, I1, E2 and V2 are included in Pol(S) (that is, if S contains only F-valid, T-valid, horn or co-horn relations) then by Theorem 3.4, RCA0 \u22a2LRSAT(S). If D1 \u2286Pol(S) \u2286D then RCA0 \u22a2LRSAT(S) \u2194LRSAT([x \u0338= y]) by Theorem 3.12. By the same theorem, if Pol(S) = D2 then RCA0 \u22a2LRSAT(S) \u2194 LRSAT(Bijunctive). If L2 \u2286Pol(S) \u2286L3 then by Theorem 3.16, RCA0 \u22a2LRSAT(S) \u2194 LRSAT(Affine). Otherwise, I2 \u2286Pol(S) \u2286N2 in which case RCA0 \u22a2LRSAT(S) \u2194 LRSAT by Theorem 3.17. \u25a1 The principle LRSAT([x \u0338= y]) coincides with an already existing principle about bipartite graphs. For k \u2208\ufffd, we say that a graph G = (V,E) is k-colorable if there is a function f : V \u2192k such that (\u2200(x,y) \u2208E)( f(x) \u0338= f(y)), and we say that a graph is finitely k-colorable if every finite induced subgraph is k-colorable.\nProof of Theorem 1.14. By case analysis over Pol(S). If I0, I1, E2 and V2 are included in Pol(S) (that is, if S contains only F-valid, T-valid, horn or co-horn relations) then by Theorem 3.4, RCA0 \u22a2LRSAT(S). If D1 \u2286Pol(S) \u2286D then RCA0 \u22a2LRSAT(S) \u2194LRSAT([x \u0338= y]) by Theorem 3.12. By the same theorem, if Pol(S) = D2 then RCA0 \u22a2LRSAT(S) \u2194 LRSAT(Bijunctive). If L2 \u2286Pol(S) \u2286L3 then by Theorem 3.16, RCA0 \u22a2LRSAT(S) \u2194 LRSAT(Affine). Otherwise, I2 \u2286Pol(S) \u2286N2 in which case RCA0 \u22a2LRSAT(S) \u2194 LRSAT by Theorem 3.17. \u25a1 The principle LRSAT([x \u0338= y]) coincides with an already existing principle about bipartite graphs. For k \u2208\ufffd, we say that a graph G = (V,E) is k-colorable if there is a function f : V \u2192k such that (\u2200(x,y) \u2208E)( f(x) \u0338= f(y)), and we say that a graph is finitely k-colorable if every finite induced subgraph is k-colorable. Definition 3.18. Let G = (V,E) be a graph. A set H \u2286V is homogeneous for G if every finite V0 \u2286V induces a subgraph that is k-colorable by a coloring that colors every v \u2208V0 \u2229 H color 0. LRCOLORk is the statement \u201cFor every infinite, finitely k-colorable graph G = (V,E) and every infinite L \u2286V there exists an infinite H \u2286L that is homogeneous for G\u201d. RCOLORk is the restriction of LRCOLORk with L = V. An instance of LRCOLORk is a pair (G,L). For RCOLORk, it is simply the graph G.\nDefinition 3.18. Let G = (V,E) be a graph. A set H \u2286V is homogeneous for G if every finite V0 \u2286V induces a subgraph that is k-colorable by a coloring that colors every v \u2208V0 \u2229 H color 0. LRCOLORk is the statement \u201cFor every infinite, finitely k-colorable graph G = (V,E) and every infinite L \u2286V there exists an infinite H \u2286L that is homogeneous for G\u201d. RCOLORk is the restriction of LRCOLORk with L = V. An instance of LRCOLORk is a pair (G,L). For RCOLORk, it is simply the graph G.\nTheorem 3.19. RCA0 \u22a2RCOLOR2 \u2194LRSAT([x \u0338= y])\n# Theorem 3.19. RCA0 \u22a2RCOLOR2 \u2194LRSAT([x \u0338= y])\n   Proof. See [2] for a proof of RCA0 \u22a2RCOLOR2 \u2194LRCOLOR2. There exists a direct mapping between an instance (V,C,L) of LRSAT([x \u0338= y]) and an instance (G,L) of LRCOLOR2 where G = (V,E) by taking E = {{x,y} : x \u0338= y \u2208C}. \u25a1\n# 4. The strength of satisfiability\nLocalized principles are relatively easy to manipulate as they can express relations defined using existential quantifier by restricting the localized set L to the variables not captured by any quantifier. However we will see that when the set of relations has some good closure properties, the unlocalized version of the principle is as expressive as its localized one.\nTheorem 4.1. RCA0 proves that if S be a \u03a30 1 co-clone then RSAT(S) \u2194LRSAT(S)\n# Theorem 4.1. RCA0 proves that if S be a \u03a30 1 co-clone then RSAT(S) \u2194LRSAT(S)\n \u2194 Proof. The implication LRSAT(S) \u2192RSAT(S) is obvious. To prove the converse, let (V,C,L) be an instance of LRSAT(S) with V = {xi : i \u2208\u03c9} and C = {\u03b8i : i \u2208\u03c9}. Let CL be a computable enumeration of formulas \u03c6(\u20d7x) = R(\u20d7x) with R \u2208S and\u20d7x \u2282L such that there exists a finite subset Cfin of C for which every valid truth assignment \u03bd over Cfin satisfies \u03bd(\u03c6) = T. If CL is finite, then there is a bound m such that if \u03c6 \u2208CL then max(i : xi \u2208Var(\u03c6)) \u2264m. Then take H = {xi \u2208L : i > m}. H \u2286L and is infinite because L is infinite.\nClaim. For every c \u2208\ufffd, H is homogeneous for C with color c.\nProof of claim. If not then there exists a finite subset Cfin of C such that H is not homogeneous for Cfin with color c. Let \u20d7y = Var(Cfin) \u2216L. Because S is a co-clone, it is closed under finite conjunction and projection, hence (\u2203\u20d7y)\ufffdCfin is equivalent to an Sformula, say \u03d5. In particular Var(\u03d5) \u2286Var(Cfin)\u2229L and \u03d5 \u2208CL. For every assignment \u03bd satisfying \u03d5, there is a variable x \u2208H such that \u03bd(x) = \u00acc. Then Var(\u03d5)\u2229H \u0338= /0. However \u03d5 \u2208CL, so Var(\u03d5) \u2229H = /0 by definition of H. Contradiction. This finishes the proof of the claim.\n\u25a1\nSo suppose instead CL = {\u03c6i : i \u2208\ufffd} is infinite, and suppose each \u03c6i is unique. We construct an instance (V \u2032,C\u2032) of RSAT(S) by taking V \u2032 = L\u222a{yn : n \u2208\ufffd} and constructing C\u2032 by stages as follows: At stage 0, C\u2032 = /0. At stage s+1, look at \u03c6s = R(x1,...,xm) and let xi be the greatest variable in lexicographic order among x1,...,xm. Add the formula xi = ys and the formula R(x1,...,xi\u22121,ys,xi+1,...,xm) to C\u2032. Then go to next stage. This finishes the construction. Note that C\u2032 is satisfiable, otherwise by definition there would be a finite unsatisfiable subset Cfin \u2282CL from which we could extract an unsatisfiable subset of C. Also note that, by assuming that \u03c6i is unique and xi is the greatest variable in lexicographic order, the number of stages s such that the formula x = ys is added to C\u2032 is finite for each variable x. Let H\u2032 be an infinite set homogeneous for C\u2032 with color c. We can extract from H\u2032 an infinite subset of L homogeneous forC\u2032 with color c because either L\u2229H\u2032 or {x \u2208L : (x = yn)  is infinite and both are homogeneous for C\u2032 with color c. So fix H \u2286L, an infinite set homogeneous for C\u2032 (and for CL) with color c.\n# Claim. H is homogeneous for C with color c.\nProof of claim. By the same argument as previous claim, suppose there is a finite subset Cfin of C such that H is not homogeneous for Cfin with color c. Let \u03d5 be the S-formula equivalent to (\u2203\u20d7y)\ufffdCfin where \u20d7y = Var(Cfin) \u2216L. For every valid assignment \u03bd for \u03d5, there is a variable x \u2208H such that \u03bd(x) = \u00acc. But \u03d5 \u2208CL and hence H is homogeneous for \u03d5 with color c. Contradiction. This last claims finishes the proof of Theorem 4.1. \u25a1 Noticing that affine (resp. bijunctive) relations form a co-clone, we immediately deduce the following corollary. Corollary 4.2. RSAT(Affine) and RSAT(Bijunctive) are equivalent to their local version over RCA0. A useful principle below WKL0 for studying the strength of a statement is the notion of diagonally non-computable function. Definition 4.3. A total function f is diagonally non-computable if (\u2200e)f(e) \u0338= \u03a6e(e). DNR is the corresponding principle, i.e. for every X, there exists a function d.n.c. relative to X. DNR is known to coincide with the restriction of RWKL to trees of positive measure ([5, 2]). On the other side, there exists an \u03c9-model of DNR which is not a model of RCOLOR2 ([2]). We will now prove that we can compute a diagonally non-computable function from any infinite set homogeneous for a particular set of affine formulas. As RSAT implies LRSAT(Affine) over RCA0, it gives another proof of RCA0 \u22a2RWKL \u2192 DNR.\nDNR is known to coincide with the restriction of RWKL to trees of positive measure ([5, 2]). On the other side, there exists an \u03c9-model of DNR which is not a model of RCOLOR2 ([2]). We will now prove that we can compute a diagonally non-computable function from any infinite set homogeneous for a particular set of affine formulas. As RSAT implies LRSAT(Affine) over RCA0, it gives another proof of RCA0 \u22a2RWKL \u2192 DNR.\n# Theorem 4.4. RCA0 \u22a2RSAT(Affine) \u2192DNR.\nProof. We construct a computable set C of affine formulas over a computable set V of variables such that every infinite set homogeneous for C computes a diagonally noncomputable function. Relativization is straightforward. Let t : \ufffd\u2192\ufffdbe the computable function defined by t(0) = 2 and t(e + 1) = 2 + \u2211e i=0t(i). Note that every image by t is even. For every e \u2208\ufffd, let \ufffd De,j : j \u2208\ufffd \ufffd denote the canonical enumeration of all finite sets of size t(e). We fix a countable set of variables V = {x0,x1,...} a define a set of formulas C satisfying the following requirements: \ufffde : \u03a6e(e) \u2193\u21d2De,\u03a6e(e) is not homogeneous for C\nWe first show how to construct a d.n.c. function from an infinite set H homogeneous for C, assuming that each requirement is satisfied. Let g(\u00b7) be such that De,g(e) are the least t(e) elements of H. We claim that g is a d.n.c. function: If \u03a6e(e) \u2191then obviously g(e) \u0338= \u03a6e(e). If \u03a6e(e) \u2193then because of requirement \ufffde, De,\u03a6e(e) \u2229\u00afH \u0338= /0, hence De,g(e) \u0338= De,\u03a6e(e) so g(e) \u0338= \u03a6e(e). We define C by stages. At stage 0, C = /0. To make C computable, we will not add to C any formula over {xi : i \u2264s} after stage s. Suppose at stage s \u03a6e,s(e) \u2193for some e < s \u2013 we can assume w.l.o.g. that at most one e halts at each stage \u2013. Then add xs \u2295xs \ufffdDe,\u03a6e,s(e) to C. This finishes stage s. One easily check that each requirements is satisfied as xs \u2295 xs \ufffdDe,\u03a6e,s is logically equivalent to \ufffdDe,\u03a6e,s(e), and as De,\u03a6e,s(e) has even size, so the relation is neither F-valid nor T-valid, hence De,\u03a6e,s(e) is not homogeneous for C.\n#   Claim. The resulting instance is satisfiable.\n  Claim. The resulting instance is satisfiable.\nProof of claim. If not, there exists a finite Cfin \u2282C which is not satisfiable. For a given Turing index e, define Ce to be the set of formulas added in some stage s at which \u03a6i,s(i) \u2193for some i < e. There exists an emax such that Cfin \u2286Cemax. We will define a valid assignment \u03bde of Ce by \u03a31-induction over e. If e = 0, then C0 = /0 and \u03bd0 = /0 is a valid assignment. Suppose we have a valid assignment \u03bde for some Ce. We will construct a valid assignment \u03bde+1 for Ce+1. If \u03a6e(e) \u2191 then Ce+1 = Ce and \u03bde is a valid assignment for Ce+1. Otherwise \u03a6e(e) \u2193. Ce+1 = Ce \u222a \ufffd xs \u2295xs \ufffdDe,\u03a6e(e) \ufffd . Var(Ce) has at most \u2211e\u22121 i=0 elements, hence De,\u03a6e(e) \u2216Var(Ce) is not empty. We can hence easily extend our valuation \u03bde to De,\u03a6e(e) such that the resulting valuation satisfies Ce+1. This claim finishes the proof of Theorem 4.4. \u25a1\n# 5. Conclusions and questions\nSatisfaction principles happen to collapse in the case of a full assignment existence statement. The definition is not robust and the conditions of the corresponding dichotomy theorem evolves if we make the slight modification of allowing conjunctions in our definition of formulas. However, the proposed Ramseyan version leads to a much more robust dichotomy theorem with four main subsystems. The conditions of \u201ctractability\u201d \u2013 here provability over RCA0 \u2013 differ from those of Schaefer dichotomy theorem but the considered classes of relations remain the same. We obtain the surprising result that infinite versions of horn and co-horn satisfaction problems are provable over RCA0 and strictly weaker than bijunctive and affine corresponding principles, whereas the complexity classification of [1] has shown that horn satisfiability was P-complete under AC0 reduction, hence at least as strong as bijunctive satisfiability which is NL-complete. 5.1. Summary of principles considered. The following diagram summarizes the known relations between the principles considered here. Single arrows express implication over RCA0. Double arrows mean that implications are strict. A crossed arrow denotes a nonimplication over \u03c9-models. Localized and non-localized principles coincide for the main principles because of Theorem 4.1. By [2], there exists an \u03c9-model of DNR \u2013 and even WWKL0 \u2013which is not a model of RCOLOR2. The missing arrows are all unknown. 5.2. Open questions. Very few relations are known between the four main subsystems studied in this paper: RSAT, RSAT(Affine), RSAT(Bijunctive) and RCOLOR2. Theorem 1.14 states that LRSAT(S) is equivalent to one of the above mentioned principles, or\nSatisfaction principles happen to collapse in the case of a full assignment existence statement. The definition is not robust and the conditions of the corresponding dichotomy theorem evolves if we make the slight modification of allowing conjunctions in our definition of formulas. However, the proposed Ramseyan version leads to a much more robust dichotomy theorem with four main subsystems. The conditions of \u201ctractability\u201d \u2013 here provability over RCA0 \u2013 differ from those of Schaefer dichotomy theorem but the considered classes of relations remain the same. We obtain the surprising result that infinite versions of horn and co-horn satisfaction problems are provable over RCA0 and strictly weaker than bijunctive and affine corresponding principles, whereas the complexity classification of [1] has shown that horn satisfiability was P-complete under AC0 reduction, hence at least as strong as bijunctive satisfiability which is NL-complete.\n5.1. Summary of principles considered. The following diagram summarizes the known relations between the principles considered here. Single arrows express implication over RCA0. Double arrows mean that implications are strict. A crossed arrow denotes a nonimplication over \u03c9-models. Localized and non-localized principles coincide for the main principles because of Theorem 4.1. By [2], there exists an \u03c9-model of DNR \u2013 and even WWKL0 \u2013which is not a model of RCOLOR2. The missing arrows are all unknown.\n5.2. Open questions. Very few relations are known between the four main subsystem studied in this paper: RSAT, RSAT(Affine), RSAT(Bijunctive) and RCOLOR2. Theo rem 1.14 states that LRSAT(S) is equivalent to one of the above mentioned principles, o\n\n\n\n\nFigure 1. Summary of principles\nis provable over RCA0. However those principles are not known to be pairwise distinct. In particular the principle RCOLOR2 introduced in [2] is not even known to be strictly below RWKL. Question 5.1. What are the relations between RSAT, RSAT(Affine), RSAT(Bijunctive) and RCOLOR2 ?\nis provable over RCA0. However those principles are not known to be pairwise distinct. In particular the principle RCOLOR2 introduced in [2] is not even known to be strictly below RWKL.\ns provable over RCA0. However those principles are not known to be pairwise distinct. In particular the principle RCOLOR2 introduced in [2] is not even known to be strictly below\nQuestion 5.1. What are the relations between RSAT, RSAT(Affine), RSAT(Bijunctive and RCOLOR2 ?\non 5.2. Does RCOLOR2 imply DNR over RCA0 ? Does it imply RWKL\nAcknowledgements. The author is thankful to Laurent Bienvenu and Paul Shafer for their availability during the different steps giving birth to the paper, and for their useful suggestions. The author is funded by the John Templeton Foundation (\u2018Structure and Randomness in the Theory of Computation\u2019 project). The opinions expressed in this publication are those of the author(s) and do not necessarily reflect the views of the John Templeton Foundation.\n# References\n[1] Eric Allender, Michael Bauland, Neil Immerman, Henning Schnoor, and Heribert Vollmer. The complexity of satisfiability problems: Refining schaefer\u2019s theorem. In Mathematical Foundations of Computer Science 2005, pages 71\u201382. Springer, 2005. [2] Laurent Bienvenu, Ludovic Patey, and Paul Shafer. A Ramsey-Type K\u00f6nig\u2019s lemma and its variants. in preparation. [3] Andrei A Bulatov. A dichotomy theorem for constraints on a three-element set. In Proceedings of the 43rd Annual IEEE Symposium on Foundations of Computer Science (FOCS\u201902), pages 649\u2013658. IEEE, 2002. [4] Nadia Creignou and Miki Hermann. Complexity of generalized satisfiability counting problems. Information and Computation, 125(1):1\u201312, 1996.\n\n[5] Stephen Flood. Reverse mathematics and a Ramsey-type K\u00f6nig\u2019s Lemma. Journal of Symbolic Logic, 77(4):1272\u20131280, 2012. [6] Jeffry L. Hirst. Marriage theorems and reverse mathematics. In Logic and computation (Pittsburgh, PA, 1987), volume 106 of Contemp. Math., pages 181\u2013196. Amer. Math. Soc., Providence, RI, 1990. [7] Sanjeev Khanna and Madhu Sudan. The optimization complexity of constraint satisfaction problems. In Electonic Colloquium on Computational Complexity. Citeseer, 1996. [8] Victor W Marek and Jeffrey B Remmel. The complexity of recursive constraint satisfaction problems. Annals of Pure and Applied Logic, 161(3):447\u2013457, 2009. [9] Emil L Post. The two-valued iterative systems of mathematical logic. Number 5. Princeton University Press, 1942. [10] Thomas J. Schaefer. The complexity of satisfiability problems. In Conference Record of the Tenth Annual ACM Symposium on Theory of Computing (San Diego, Calif., 1978), pages 216\u2013226. ACM, New York, 1978. [11] Stephen G. Simpson. Subsystems of second order arithmetic. Perspectives in Logic. Cambridge University Press, Cambridge; Association for Symbolic Logic, Poughkeepsie, NY, second edition, 2009.\n<div style=\"text-align: center;\"><img src=\"https://public-pdf-extract-kit.oss-cn-shanghai.aliyuncs.com/2ef7/2ef75b4e-f1bb-4fa7-ae0b-4d95ea4ce265.png\" style=\"width: 50%;\"></div>\nLUDOVIC PATEY\nLaboratoire PPS, Universit\u00e9 Paris Diderot, Paris, FRANCE E-mail address: ludovic.patey@computability.fr\nClass\nDefinition\nBase(s)\nBF\nall Boolean functions\n{\u2227,\u00ac}\nR0\n{ f \u2208BF | f is 0-reproducing }\n{\u2227,\u2295}\nR1\n{ f \u2208BF | f is 1-reproducing }\n{\u2228,x\u2295y\u22951}\nR2\nR1 \u2229R0\n{\u2228,x\u2227(y\u2295z\u22951)}\nM\n{ f \u2208BF | f is monotonic }\n{\u2227,\u2228,0,1}\nM1\nM\u2229R1\n{\u2227,\u2228,1}\nM0\nM\u2229R0\n{\u2227,\u2228,0}\nM2\nM\u2229R2\n{\u2227,\u2228}\nSn\n0\n{ f \u2208BF | f is 0-separating of degree n }\n{\u2192,dual(tn)}\nS0\n{ f \u2208BF | f is 0-separating }\n{\u2192}\nSn\n1\n{ f \u2208BF | f is 1-separating of degree n }\n{x\u2227y, tn}\nS1\n{ f \u2208BF | f is 1-separating }\n{x\u2227y}\nSn\n02\nSn\n0 \u2229R2\n{x\u2228(y\u2227z),dual(tn)}\nS02\nS0 \u2229R2\n{x\u2228(y\u2227z)}\nSn\n01\nSn\n0 \u2229M\n{dual(tn),1}\nS01\nS0 \u2229M\n{x\u2228(y\u2227z),1}\nSn\n00\nSn\n0 \u2229R2 \u2229M\n{x\u2228(y\u2227z),dual(tn)}\nS00\nS0 \u2229R2 \u2229M\n{x\u2228(y\u2227z)}\nSn\n12\nSn\n1 \u2229R2\n{x\u2227(y\u2228z),tn}\nS12\nS1 \u2229R2\n{x\u2227(y\u2228z)}\nSn\n11\nSn\n1 \u2229M\n{tn,0}\nS11\nS1 \u2229M\n{x\u2227(y\u2228z),0}\nSn\n10\nSn\n1 \u2229R2 \u2229M\n{x\u2227(y\u2228z),tn}\nS10\nS1 \u2229R2 \u2229M\n{x\u2227(y\u2228z)}\nD\n{ f | f is self-dual }\n{(x\u2227y)\u2228(x\u2227z)\u2228(y\u2227z)}\nD1\nD\u2229R2\n{(x\u2227y)\u2228(x\u2227z)\u2228(y\u2227z)}\nD2\nD\u2229M\n{(x\u2227y)\u2228(y\u2227z)\u2228(x\u2227z)}\nL\n{ f | f is linear}\n{\u2295,1}\nL0\nL\u2229R0\n{\u2295}\nL1\nL\u2229R1\n{\u2194}\nL2\nL\u2229R2\n{x\u2295y\u2295z}\nL3\nL\u2229D\n{x\u2295y\u2295z\u22951}\nV\n{ f | f is an \u2228-function or a constant function}\n{\u2228,0,1}\nV0\n[{\u2228}]\u222a[{0}]\n{\u2228,0}\nV1\n[{\u2228}]\u222a[{1}]\n{\u2228,1}\nV2\n[{\u2228}]\n{\u2228}\nE\n{ f | f is an \u2227-function or a constant function}\n{\u2227,0,1}\nE0\n[{\u2227}]\u222a[{0}]\n{\u2227,0}\nE1\n[{\u2227}]\u222a[{1}]\n{\u2227,1}\nE2\n[{\u2227}]\n{\u2227}\nN\n[{\u00ac}]\u222a[{0}]\u222a[{1}]\n{\u00ac,1}, {\u00ac,0}\nN2\n[{\u00ac}]\n{\u00ac}\nI\n[{id}]\u222a[{1}]\u222a[{0}]\n{id,0,1}\nI0\n[{id}]\u222a[{0}]\n{id,0}\nI1\n[{id}]\u222a[{1}]\n{id,1}\nI2\n[{id}]\n{id}\n<div style=\"text-align: center;\">Class Definition</div>\nFigure 2. The list of all Boolean clones with definitions and bases, where tn := \ufffdn+1 i=1 \ufffdn+1 j=1, j\u0338=i xj and dual( f)(a1,...,an) = \u00ac f(\u00aca1 ...,\u00acan).\n",
    "paper_type": "theory",
    "attri": {
        "background": "Satisfiability problems play a central role in computer science and engineering as a general framework for studying the complexity of various problems. Schaefer proved in 1978 that truth satisfaction of propositional formulas given a language of relations is either NP-complete or tractable. The study of these problems within the framework of reverse mathematics can yield insights into both fields.",
        "problem": {
            "definition": "The paper explores the classification of satisfying assignment construction problems in the framework of reverse mathematics, particularly focusing on the principles that are either provable over RCA0 or equivalent to WKL0.",
            "key obstacle": "The challenge lies in determining the distinct classes arising from this classification and proving their properties."
        },
        "idea": {
            "intuition": "The idea was inspired by previous work in complexity theory and reverse mathematics, particularly Schaefer's dichotomy theorem.",
            "opinion": "The authors propose that studying CSP within the reverse mathematics framework can provide a deeper understanding of computational strength.",
            "innovation": "The main difference compared to previous methods is the formulation of a Ramseyan version of the problems and the introduction of a different dichotomy theorem."
        },
        "Theory": {
            "perspective": "The perspective is grounded in reverse mathematics, which classifies mathematical theorems based on their provability.",
            "opinion": "The authors assume that many satisfiability problems can be linked to the principles of reverse mathematics.",
            "proof": "The paper presents proofs that link RCA0 to WKL0 through the study of various satisfiability problems."
        },
        "experiments": {
            "evaluation setting": "The evaluation involves various classes of Boolean formulas, including bijunctive, affine, and horn formulas, and their corresponding satisfiability problems.",
            "evaluation method": "The authors apply proof-theoretic methods to demonstrate the relationships between different classes of satisfiability problems and their complexity."
        },
        "conclusion": "The paper concludes that there is a significant relationship between the principles of satisfiability and reverse mathematics, with implications for understanding the complexity of these problems.",
        "discussion": {
            "advantage": "The advantage of this study is the establishment of a clear connection between complexity classes and reverse mathematics principles.",
            "limitation": "A limitation is the uncertainty regarding the distinctness of the classes and the implications of the results in broader contexts.",
            "future work": "Future work could focus on exploring the relationships between the various principles further and investigating their applications in other areas of mathematics and computer science."
        },
        "other info": [
            {
                "info1": "The paper builds on previous research in complexity theory and reverse mathematics, particularly Schaefer's work."
            },
            {
                "info2": {
                    "info2.1": "The authors acknowledge the contributions of other researchers in the field.",
                    "info2.2": "The paper includes a comprehensive list of references for further reading."
                }
            }
        ]
    },
    "mount_outline": [
        {
            "section number": "1.1",
            "key information": "The paper explores the classification of satisfying assignment construction problems in the framework of reverse mathematics, particularly focusing on the principles that are either provable over RCA0 or equivalent to WKL0."
        },
        {
            "section number": "1.4",
            "key information": "The study of satisfiability problems within the framework of reverse mathematics can yield insights into both fields of computer science and engineering."
        },
        {
            "section number": "2.2",
            "key information": "The paper discusses the historical context of satisfiability problems and their relationship to complexity theory, particularly Schaefer's dichotomy theorem."
        },
        {
            "section number": "3.1",
            "key information": "The evaluation involves various classes of Boolean formulas, including bijunctive, affine, and horn formulas, and their corresponding satisfiability problems."
        },
        {
            "section number": "6.1",
            "key information": "The key obstacle lies in determining the distinct classes arising from the classification of satisfiability problems and proving their properties."
        },
        {
            "section number": "6.3",
            "key information": "Future work could focus on exploring the relationships between the various principles further and investigating their applications in other areas of mathematics and computer science."
        }
    ],
    "similarity_score": 0.5618038472804097,
    "image": null,
    "path": "/home/dany/codes/autosurvey/outputs/2025-01-11-1832_natur/papers/The complexity of satisfaction problems in reverse mathematics.json"
}